\textbf{Proof of correctness}

To prove that the algorithm does compute the word with the best weight, we use the following invariant :
$$
<q_1, q_2> \notin Q \iff d_{bot} (q_1, q_2) = b_{bot} (q_1, q_2)
$$
In other words, a tuple $<q_1, q_2>$ is removed from the queue during an iteration only when $d_{bot}(q1, q2)$ has its minimal value.

Initialization : Before the while loop, no tuple has been extracted from the queue, so the invariant is trivially true.

Recursion : 

Let's show by contradiction that at each iteration of the while loop, for the tuple $<q, q'>$ extracted from Q we have:
$$
d_{bot}(q, q') = b_{bot}(q, q'), 
$$


Let's consider the states $q_0$, $q_1$, $q_2$ and $q_3$ $\in Q$ such as they form a path $q$ ~...~>$q_0$ -> $q_1$ -> $q_2$ -> $q_3$ ~..~> $q'$.

We take $<q_0, q_1>$ as the first tuple to be removed from the queue. Then when $<q_0, q_1>$ is extracted from the queue, the algorithms updates $d_{bot}(q_0, q_2)$ and $d_{bot}(q_0, q_3)$. Thus, we have:
$$
d_{bot}(q_0, q_2) \geq b_{bot}(q_0, q_1) \\
d_{bot}(q_0, q_3) \geq b_{bot}(q_0, q_1)
$$
Let's show that it is true for each update possible, shown in Figure 3. TODO

Let $<q_0, q_3>$ be the first tuple for which the invariant is false:
$$
For <q_0, q_3> \notin Q, d_{bot} (q_0, q_3) \neq b_{bot} (q_0, q_3)
$$
Since $d_{bot}(q_0, q_2)$ has to be computed to compute $d_{bot}(q_0, q3)$, and because the invariant is true for  $d_{bot}(q_0, q_2)$ we can say:
$$
d_{bot}(q_0, q_2) = b_{bot}(q_0, q_2) \\
d_{bot}(q_0, q_2) \leq b_{bot}(q_0, q_3) \\
\\d_{bot}(q_0, q_2) \leq d_{bot}(q_0, q_3) \\
$$
 However, when $<q_0, q_3>$ was extracted, $<q_0, q_2>$ was still in $Q$. Thus, by definition 
$$
d_{bot}(q_0, q_2) \geq d_{bot}(q_0, q_3) \\
$$
Then the two inequalities are actually equal : 
$$
d_{bot}(q_0, q_2) = b_{bot}(q_0, q_2) = d_{bot}(q_0, q_3) = b_{bot}(q_0, q_3) \\
$$
We find that $d_{bot}(q_0, q_3) = b_{bot}(q_0, q_3)$, so by contradiction, we find that indeed $d_{bot}(q_0, q_3) = b_{bot}(q_0, q_3) iff <q_0, q_3> \notin Q$.


Termination: TODO 