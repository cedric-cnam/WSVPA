
% SWT without epsilon-transitions
% SWT do not read the other tape in "skip" transitions 10 or 01
%     (hence this version is simpler  than V2)
% SWA without epsilon-transitions
% SW-VPA read top of stack (when not empty) at every transition
%        (6 kinds of transitions).

% default style article.cls
%\input{main-article}

% Springer llncs style
% https://www.springer.com/gp/computer-science/lncs/conference-proceedings-guidelines
\input{main-llncs}

% EPTCS style
% http://www.eptcs.org
%\input{main-eptcs}

% LIPICS v.2021 style
% https://submission.dagstuhl.de/documentation/authors
%\input{main-lipics}

% comments in margin with \todo command
\usepackage[colorinlistoftodos]{todonotes} % option disable to hide todos
% command todo : options
% - noline: no line connecting the note with the place in the text
%   where the note occurs in the latex code
% - fancyline : curved arrow from note to inssertion point
% - inline: place a todonote inside the text instead of in the margin
% - author=name
\newcommand{\florent}[1]{\todo[noline,size=\tiny,color=yellow!40]{#1}}
%\renewcommand{\florent}[1]{} % uncomment for final
\newcommand{\lydia}[1]{\todo[noline,size=\tiny,color=red!30]{#1}}
%\renewcommand{\lydia}[1]{} % uncomment for final
\newcommand{\philippe}[1]{\todo[noline,size=\tiny,color=green!30]{#1}}
%\renewcommand{\philippe}[1]{} % uncomment for final
\newcommand{\reviews}[1]{\todo[noline,size=\tiny,color=blue!30]{#1}}
%\renewcommand{\reviews}[1]{} % uncomment for final

\usepackage{hyperref}
%\usepackage[bookmarks,bookmarksnumbered,naturalnames,plainpages=false]{hyperref}
%usepackage{url}

% for footnote ref
\usepackage{refcount}

% array and tabular
\usepackage{array}
\newcolumntype{C}[1]{>{\centering\arraybackslash\hspace{0pt}}p{#1}}

% extension of enumerate env. (style for displaying counters)
% \usepackage{enumerate}

%% pictures
% \usepackage{graphicx}
% \DeclareGraphicsExtensions{.pdf,.png,.jpg}
% \graphicspath{fig/}

%% PGF, Tikz
\usepackage{tikz-cd}
%% \usepackage{pgfplots}
%% \usepgfplotslibrary{dateplot}
%% \usepackage{pgf,pgfarrows,pgfnodes, pgfautomata}
% \usepackage{tikz}
% \usetikzlibrary{cd}
%% \usetikzlibrary{arrows}
%% \usetikzlibrary{calc}
%% \usetikzlibrary{snakes}
%% \usetikzlibrary{backgrounds}
% \usetikzlibrary{trees}
%% \usetikzlibrary{automata}
%% \usetikzlibrary{positioning}
%% \usetikzlibrary{matrix}
%% \usetikzlibrary{patterns}
%% \usetikzlibrary{shapes}

% symbols
\usepackage{amsmath}
\allowdisplaybreaks
\usepackage{amssymb}
\usepackage{amsbsy}
\usepackage{bbold}
\usepackage{latexsym}
%\usepackage{amsfonts}
\usepackage{stmaryrd}
%\usepackage{mathabx}
%\usepackage{MnSymbol}
\usepackage{harmony} % simple music fonts
\usepackage{mathtools} % for arrows
%\usepackage{mathptmx}
\usepackage{comment}

%% algorithms
%\usepackage{algorithm}
%\usepackage{program}
\usepackage[ruled,vlined]{algorithm2e}

%% allows for page break within arrays
\usepackage{longtable}

%% arrows etc
%\input{rewriting}

%% music symbols
% see http://tug.ctan.org/info/latex4musicians/latex4musicians.pdf
\usepackage{musicography}

%% for new macros
\usepackage{xspace}

%% Misc macros
\def\ie{\textit{i.e.}\xspace}
\def\eg{\textit{e.g.}\xspace}
\def\wrt{\textit{wrt}\xspace}
%\def\wlog{\textit{wlog}\xspace}
\def\etc{\textit{etc}\xspace}

\def\<#1>{\langle #1 \rangle}
\newcommand{\pair}[2]{\langle{#1}, {#2}\rangle}

%\newcommand{\config}[2]{\ensuremath \genfrac{[}{]}{0pt}{}{#1}{#2}}
\newcommand{\config}[2]{\ensuremath{#1}[{#2}]}
\newcommand{\configup}[2]{\ensuremath{#1}\left[\begin{array}{c} #2 \end{array}\right]}
\def\stacksep{\cdot}
\def\stackup{\\}

\newcommand{\opluseq}{\ensuremath\mathrel{\oplus}=}

% \bigominus
\DeclareFontFamily{U}{mathx}{\hyphenchar\font45}
\DeclareFontShape{U}{mathx}{m}{n}{
<-6> mathx5 <6-7> mathx6 <7-8> matha7
<8-9> mathx8 <9-10> mathx9
<10-12> mathx10 <12-> mathx12
}{}
\DeclareSymbolFont{mathx}{U}{mathx}{m}{n}
\DeclareMathSymbol{\bigominus}{\mathop}{mathx}{"C1}

\newcommand{\A}{\mathcal{A}} % automata, VPA
\newcommand{\B}{\mathcal{B}} % automata (in constructions)
\newcommand{\C}{\mathcal{C}} % automata (in constructions)
\newcommand{\D}{\mathcal{D}}  % transducer = distance
\newcommand{\E}{\mathbb{E}}
\newcommand{\F}{\mathcal{F}}
\newcommand{\G}{\mathcal{G}}
%\newcommand{\P}{\mathcal{P}}
\newcommand{\Q}{\mathcal{Q}}
\newcommand{\R}{\mathcal{R}}
\newcommand{\T}{\mathcal{T}}
\newcommand{\W}{\mathbb{W}}
\newcommand{\Semiring}{\mathbb{S}}
\newcommand{\zero}{\mathbb{0}}
\newcommand{\one}{\mathbb{1}}
\newcommand{\dom}{\ensuremath{\mathit{dom}}}
\newcommand{\seq}{\ensuremath{\mathit{seq}}}
\newcommand{\word}{\mathit{word}}

\def\SA{\textsf{sA}\xspace}
\def\WA{\textsf{wA}\xspace}
\def\SW{\textsf{sw}\xspace}
\def\swM{\textsf{swM}\xspace}
\def\SWT{\textsf{swT}\xspace}
\def\SWA{\textsf{swA}\xspace}
\def\SWTA{\textsf{swTA}\xspace}
\def\SWVPA{\textsf{sw-VPA}\xspace}
\def\VPA{\textsf{VPA}\xspace}
\def\SVPA{\textsf{sVPA}\xspace}
\def\weight{\mathsf{weight}}
\def\mei{\mathsf{m}}
\def\init{\mathsf{in}}
\def\final{\mathsf{out}}
\def\Omegai{{\Omega_\mathsf{i}}}
\def\Omegac{{\Omega_\mathsf{c}}}
\def\Omegar{{\Omega_\mathsf{r}}}
\def\Sigmai{{\Sigma_\mathsf{i}}}
\def\Sigmac{{\Sigma_\mathsf{c}}}
\def\Sigmar{{\Sigma_\mathsf{r}}}
\def\Deltai{{\Delta_\mathsf{i}}}
\def\Deltac{{\Delta_\mathsf{c}}}
\def\Deltar{{\Delta_\mathsf{r}}}
\def\Phii{{\Phi_\mathsf{i}}}
\def\Phic{{\Phi_\mathsf{c}}}
\def\Phir{{\Phi_\mathsf{r}}}
\def\Phix{{\Phi_\mathsf{x}}}
\def\Phici{{\Phi_\mathsf{ci}}}
\def\Phicc{{\Phi_\mathsf{cc}}}
\def\Phicr{{\Phi_\mathsf{cr}}}
\def\Phicx{{\Phi_\mathsf{cx}}}
\def\wei{\mathsf{w}}
\def\weii{{\wei_\mathsf{i}}}
\def\weic{{\wei_\mathsf{c}}}
\def\weir{{\wei_\mathsf{r}}}
\newcommand{\weie[1]}{\wei_{#1}^\mathsf{e}}
\def\weiei{\weie[\mathsf{i}]}
\def\weiec{\weie[\mathsf{c}]}
\def\weier{\weie[\mathsf{r}]}
\def\weiex{\weie[\mathsf{x}]}
\newcommand{\ioi}[1]{\mathsf{ioi}({#1})}
\newcommand{\rank}{\mathsf{rk}}
\newcommand{\lin}{\mathsf{lin}}
\newcommand{\tstamp}[1]{\mathpunct{:}{\scriptstyle #1}} % timestamp marker
%\newcommand{\ts}[1]{^{#1}} % timestamp marker
\newcommand{\call}[1]{\ensuremath #1} %{\ensuremath \langle_{#1}}
\newcommand{\return}[1]{\ensuremath #1} %{\ensuremath {}_{#1}{\rangle}} % $\prescript{}{a}{)}$
\newcommand{\ccall}[1]{\ensuremath \lceil_{#1}}   % \langle
\newcommand{\creturn}[1]{\ensuremath \rceil_{#1}}
%\newcommand{\creturn}[1]{\ensuremath {}_{#1}{\rangle}} % $\prescript{}{a}{)}$
\newcommand{\src}{\mathit{src}}
\newcommand{\trg}{\mathit{trg}}
\newcommand{\fst}{\mathit{fst}}
\newcommand{\snd}{\mathit{snd}}

%\sloppy

% Parsing over infinite alphabet as optimal alignment computation
% as edit-distance between string and language
%
%\title{Symbolic Weighted Parsing and Automated Music Transcription}
%\title{Symbolic Weighted Language Models and Automated Music Transcription}
\title{Symbolic Weighted Language Models and\\ Quantitative Parsing over Infinite Alphabets}
%\title{Weighted Visibly Pushdown Automata and Automated Music Transcription}
%\titlerunning{WVPA \& AMT}
%\titlerunning{Symbolic Weighted Parsing} % and Automated Music Transcription
%\authorrunning{Florent Jacquemard}

\date{\today}

\begin{document}
\thispagestyle{empty}
\maketitle

\begin{abstract}
\input{abstract}
\end{abstract}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% intro
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction} \label{sec:intro}
\input{introduction}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% prelin
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Preliminary Notions}
\label{section:prelim}\label{sec:prelim}

%notations: for set $S$ : sets of sequences $S^*$ and $S^+$...
%interval $[i..j]$ of natural numbers

%\paragraph*{Semirings}
\label{section:semiring}\label{sec:semiring}
\input{semiring}

%\paragraph*{Label Theory}
\label{section:symbols}
\input{labels}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% SWT & SWA
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{SW Automata and Transducers}
\label{section:transducer}\label{sec:transducer}
\label{section:SWA}\label{sec:SWA}
\label{section:SWT}\label{sec:SWT}

We follow the approach of~\cite{Mohri03ijfcs} for the computation of distances
between words and languages
and extend it to infinite alphabets.
% with models of symbolic weighted automata and transducers.
%
The models introduced in this section generalize
weighted automata and transducers~\cite{Droste09handbook}
%over finite alphabets, see \eg~\cite{Mohri03ijfcs},
by labeling each transition with a weight function
that takes the input and output symbols as parameters.
These functions are similar to the guards of symbolic automata~\cite{dAntoniVeanes17CAV,dAntoni21CACM},
but the latter guards are restricted to the Boolean semiring.
%

%\subsection{Definitions} \label{sec:SWTdef}\label{sec:SWAdef}
%(SWT)
\noindent
Let $\Semiring$ be a commutative semiring,
$\Sigma$ and $\Delta$ be alphabets called \emph{input} and \emph{output} respectively, %{alphabets},
and $\bar\Phi$ be a label theory over $\Semiring$
containing $\Phi_\Sigma$, $\Phi_\Delta$, $\Phi_{\Sigma, \Delta}$.

\begin{definition}
\label{def:transducer} \label{def:SWT}
A \emph{symbolic-weighted transducer} (\SWT)
over $\Sigma$, $\Delta$, $\Semiring$ and $\bar\Phi$
%the input and output alphabets~$\Sigma$ and $\Delta$ with label theory $\bar\Phi$, and the semiring $\Semiring$
is a tuple
$T = \< Q, \init, \bar{\wei}, \final >$,
where $Q$ is a finite set of states,
$\mathsf{in} \colon Q \to \Semiring$   %\Phi_{\Sigma, \Delta}
(respectively $\mathsf{out} \colon Q \to \Semiring$)  %\Phi_{\Sigma, \Delta}
are functions defining the weight for entering
(respectively leaving) computation in a state,
and $\bar{\wei}$ is a triplet of transition functions
$\wei_{10}: Q \times Q \to \Phi_{\Sigma}$,
$\wei_{01}: Q \times Q \to \Phi_{\Delta}$, and
$\wei_{11}: Q \times Q \to \Phi_{\Sigma, \Delta}$.
\end{definition}
%
\noindent
%We call the \emph{number of transitions} of $T$ the number of pairs of states
%$q, q' \in Q$ such that $\wei_{10}$ or $\wei_{01}$ or $\wei_{11}$
%is not the constant $\zero$.
%
\noindent
A tuple of $Q \times (\Sigma \cup \{ \varepsilon \}) \times (\Delta \cup \{ \varepsilon \}) \times Q \to \Semiring$
is called a \emph{transition} of $T$.
For convenience, we shall sometimes present the above $\wei_{10}$, $\wei_{01}$, $\wei_{11}$
%(overloading the function names),
as mappings associating to every transition a weight value in $\Semiring$ as follows,
for every $q, q' \in Q$, $a \in \Sigma$,  $b \in \Delta$:
\[
\begin{array}{rcll}
\wei_{10}(q, a, \varepsilon, q') & = & \phi(a) & %\wei_\Sigma(q, q')(a)
\quad\mathrm{where~} \phi = \wei_{10}(q, q') \in \Phi_\Sigma,\\
\wei_{01}(q, \varepsilon, b, q') & = & \psi(b) &
\quad\mathrm{where~} \psi = \wei_{01}(q, q') \in \Phi_\Delta,\\
\wei_{11}(q, a, b, q') & = & \eta(a, b) &
\quad\mathrm{where~} \eta = \wei_{11}(q, q') \in \Phi_{\Sigma, \Delta}.\\
\end{array}
\]
%
\noindent
% The symbolic-weighted transducer
The \SWT $T$ computes on pairs $\< s, t> \in \Sigma^* \times \Delta^*$,
$s$ and $t$, being respectively called \emph{input} and \emph{output} word.
\florent{It compute asynchronously: advance in $s$ and not in $t$ ($\wei_{10}$),
or the opposite ($\wei_{01}$),
or advance in both $s$ and $t$ ($\wei_{11}$).}
% \noindent
$T$ is
based on an intermediate function $\weight_T$
defined recursively, for every states $q, q' \in Q$,
and every pairs of strings $\< s, t> \in \Sigma^* \times \Delta^*$.
% \setminus \{ \< \varepsilon, \varepsilon >\}$,
%
%$a \in \Sigma$, $u \in \Sigma^*$, $b\in \Delta$, $v\in \Delta^*$, by:
%
\begin{align}
%\weight_T(q, \varepsilon, \varepsilon, q)  & = \one \label{eq:SWT-weight}\\ %\final(q)\\
%\weight_T(q, \varepsilon, \varepsilon, q') & = \zero \quad \mathrm{if~} q \neq q'\nonumber\\
\weight_T(q, \varepsilon, \varepsilon, q')  & = \one
 \quad \mathrm{if~} q = q' \mathrm{~and~} \zero \mathrm{~otherwise} \label{eq:SWT-weight}\\
\weight_T(q, s, t, q') & = \displaystyle\bigoplus_{\begin{array}{c}
                                                   \scriptstyle q'' \in Q\\[-1ex]
                                                   \scriptstyle s = au,\, a \in \Sigma
                                                   \end{array}}
    \wei_{10}(q, a, \varepsilon, q'') \otimes \weight_T(q'', u, t, q')\nonumber\\
                    & \oplus \displaystyle\bigoplus_{\begin{array}{c}
                                                     \scriptstyle q'' \in Q\\[-1ex]
                                                     \scriptstyle t = bv,\, b \in \Delta\\
                                                     \end{array}}
    \wei_{01}(q, \varepsilon, b, q'') \otimes \weight_T(q'', s, v, q')\nonumber\\
                    & \oplus \displaystyle\bigoplus_{\begin{array}{c}
                                                     \scriptstyle q'' \in Q\\[-1ex]
                                                     \scriptstyle s = au,\, t = bv\\
                                                     \end{array}}
    \wei_{11}(q, a, b, q'') \otimes \weight_T(q'', u, v, q')\nonumber
\end{align}


%
We recall that, by definition (Section~\ref{sec:prelim}),
an empty sum with $\bigoplus$ is equal to~$\zero$.
%
Intuitively,  a transition $\wei_{ij}(q, a, b, q')$ is interpreted as follows:
when reading $a$ and $b$ in the input and output words,
increment the current position in the input word if and only if $i = 1$,
and in the output word iff $j = 1$, %(otherwise, do not change it),
and change state from $q$ to $q'$.
When $a = \varepsilon$ (resp. $b = \varepsilon$), the current symbol
in the input (resp. output) is not read.
%
%In contrast with the models of weighted transducers over finite alphabets~\cite{Mohri03ijfcs},
%the input and output symbols at current positions are always read by transitions,
%even when they do not change the reading position the head's position.
%This is an important feature in the case of an infinite alphabet in
%order to compare input and output symbols.
%which cannot be stored in the finite memory of the transducer.
%
Since~$\zero$ is absorbing for~$\otimes$ in~$\Semiring$,
one term $\wei_{ij}(q, a, b, q'')$ equal to $\zero$ in the above expression
will be ignored in the sum, meaning that there is no possible transition
from state $q$ into state $q'$ while reading $a$ and $b$.
This is analogous to the case of a transition's guard not satisfied by $\<a, b>$ for
symbolic transducers.

%whereas considering the current symbol may be useful to compute a transition weight.
%(even when it does not change the head's position, like with $\varepsilon$-transitions).
%
%The cases $\weight_T(q, au, \varepsilon, q')$ and $\weight_T(q, \varepsilon, bv, q')$
%are missing in the definition of $\weight_T$.
%It means that $T$ must avoid configurations where it reached the end of
%the output word and not of the input one, or vice-versa.
%This can be done by using $\wei_{10}$ and $\wei_{01}$
%before reaching the end of word, and using a special state for this purpose.

The expression \eqref{eq:SWT-weight}
can be seen as a stateful definition of
an edit-distance between a word $s \in \Sigma^*$ and a word $t \in \Delta^*$,
see also~\cite{Mohri03ijfcs}.
Intuitively,
$\wei_{10}(q, a, \varepsilon, r)$ is the cost of
the deletion of the symbol~$a \in \Sigma$ in~$s$,
$\wei_{01}(q, \varepsilon, b, r)$ is the cost
of the insertion of~$b \in \Delta$ in $t$,
and $\wei_{11}(q, a, b, r)$ is the cost
of the substitution of  $a \in \Sigma$ by~$b \in \Delta$.
%
The cost of a sequence of such operations transforming $s$ into $t$
is the product in terms of $\otimes$ of the individual costs of the operations involved;
and the distance between $s$ and $t$ is the sum in terms of $\oplus$
of all possible products.
%
\medskip\noindent
%Let $\< s, t> \in \Sigma^* \times \Delta^*$, with $s = s_1\ldots s_n$, and $t = t_1\ldots t_m$.
Formally, the weight associated by $T$ to $\< s, t> \in \Sigma^* \times \Delta^*$ is:
%defined as follows:
\begin{equation}
T(s, t)  =
\displaystyle\bigoplus_{q, q' \in Q} \init(q)
\mathop{\otimes} \weight_T(q, s, t, q') \mathop{\otimes} \final(q')
\label{eq:SWT-value}
\end{equation}

\begin{comment}
%\begin{example}
%We can define with a \SWT the computation of a similarity measure
%between timed sequences
%similar to dynamic time warping (DTW).
%
%Let $\Semiring$  be the tropical (\emph{min-plus}) semiring of Figure~\ref{fig:semirings} and
%let $\Sigma = \Delta = \mathbb{R}_+$ be sets of timestamps.
%We consider a \SWT with one state $q$ and transitions
%$\wei_{11}(q, d, d', q) =
% \wei_{01}(q, d, d', q) =
% \wei_{10}(q, d, d', q) = |d' - d|$,
%for all $d, d' \in \mathbb{R}_+$.
%% needs reading input/output symbols even by epsilon-transitions.
%The recursive definition of $\weight_T$ correspond to the dynamic programming equations of DTW
%for the computation of an optimal match between words,
%the matching cost for two symbols being the
%the time distance between them.
%\endex
%\end{example}
\end{comment}

\begin{example}\label{ex:SWT}
We build a small \SWT over the alphabets $\Sigma$ and $\Deltai$
(Ex.~\ref{ex:running} and \ref{distance-time}),
%weighted transducer model
with two states $q_0$ and $q_1$, that
calculates the temporal distance between an input performance in~$\Sigma^*$
and the subsequence
of $\Deltai$ events in a score.
%the performance $I$ and
%the score $O$ of Example~\ref{ex:running}.
%
Given  a performed event $\mu$
and the corresponding notated event $\nu$
(\eg MIDI pitch 69 and note $\mbox{\footnotesize A4}$),
the weight  computed by the \SWT is the time distance between both,
as modeled by transitions $\wei_{11}$ below.
%
The continuation symbol $'-'$
(met for instance in \emph{ties}
$\musQuarter\!\!\!\mathrel{\raisebox{-1.5mm}{$\smile$}}\!\!\!\musEighth$,
or \emph{dots} \musQuarterDotted{})
%that represents continuation
is  skipped with no cost (transitions $\wei_{01}$).
%Likewise, the markups are ignored.
\[
\begin{array}{lclclcll}
\wei_{11}(q_0, \mu\tstamp{\tau}, \nu\tstamp{\tau'}, q_0) & = &
     \delta(\mu\tstamp{\tau}, \nu\tstamp{\tau'}) & \quad & %|\tau' - \tau| & \quad &
\wei_{11}(q_1, \mu\tstamp{\tau}, \nu\tstamp{\tau'}, q_0) & = &
     \delta(\mu\tstamp{\tau}, \nu\tstamp{\tau'}) &
     \mbox{if~} \nu \neq - \\ %|\tau' - \tau| & \quad &
\wei_{01}(q_0, \varepsilon, \mathsf{-}\tstamp{\tau'}, q_0) & = & \one & &
\wei_{01}(q_1, \varepsilon, \mathsf{-}\tstamp{\tau'}, q_0) & = & \one\\
\wei_{10}(q_0, \mu\tstamp{\tau}, \varepsilon, q_1) & = & \alpha & & %\multicolumn{3}{l}{\mathrm{for~all~} b \in \Delta}
\end{array}
\]
%
We also want to take performing errors into account,
since a performer could, for example, play an unwritten extra note.
%\lydia{reformulated this sentence}
%
%Reading such a note is modelled by
The transition $\wei_{10}$,
with a fixed weight value $\alpha \in \Semiring$,
switches from state $q_0$ (normal) to $q_1$ (error)
when reading an extra note $\mu$.
%\philippe{Comprends pas cette phrase}
%\florent{$\to$ reformulation}
The transitions in the second column below switch back to the normal state $q_0$.
% the metric computed by the \SWT is the smallest sum of point wise distances
% between dates of input and output events.
At last, we let $q_0$ be the only initial and final state, with
$\init(q_0) = \final(q_0) = \one$, and
$\init(q_1) = \final(q_1) = \zero$.
%\florent{dernière phrase utile?}
%This \SWT is capable of evaluating the differences between a score and a performance,
%all the while ensuring that performance errors are plausible.
%$\init(q_0, d, b) = \final(q_0, d, b) = \one$, and
%$\init(q_1, d, b) = \final(q_1, d, b) = \zero$,
%for all $d \in \Sigma$ and $b \in \Delta$.
\endex
\end{example}

\begin{comment}
\begin{example}
In Common Western Music Notation~\cite{Gould11Notation},
several symbols may be used to represent one single sounding event.
\lydia{unique $\to$ similar}
\florent{similar $\to$ single}
For instance, several notes can be combined with a tie,
like in $\musQuarter\!\!\!\mathrel{\raisebox{-1.5mm}{$\smile$}}\!\!\!\musEighth$,
and one note can be augmented by half its duration with a dot like in~\musQuarterDotted{}.
\lydia{modif.}
These notations are perceived equivalent when played, as their duration is equal, yet the notation is different.
We thus want to be able to compare a music score with music played by a performer.
\lydia{changed end}
%
\noindent
We propose a small weighted transducer model with two states $q_0$ and $q_1$
that calculates the distance between an input sequence of sounding
events (music "performance")
to an output sequence of written events (music "score").
% simple pointwise distance between two sequences of timestamped events **
%
Let us consider the tropical (\emph{min-plus}) semiring~$\Semiring$
of Figure~\ref{fig:semirings} and
let $\Sigma = \mathbb{R}_+$ be an input alphabet of event dates
and $\Delta = \{ \mathsf{e}, \mathsf{-} \} \times \mathbb{R}_+$
be an output alphabet of symbols with timestamps.
A symbol $\< \mathsf{e}, d > \in \Delta$ represents an event starting at date $d$,
and $\< \mathsf{-}, d >$ is a continuation of the previous event.
%More precisely, we let
%$\Sigma = \{ a, - \} \times \R_+$ and
%This example of $\Delta$ is motivated by the case of music notation,
%where several notated events (notes) can be tied together,
%with a \emph{tie} or a \emph{dot}
%meaning that they will be played as a unique sounding event.
%The timestamp of $a \in \Sigma$, denoted by $\mathsf{t}(a)$, is expressed as a rational number.

We consider a \SWT with two states $q_0$ and $q_1$ whose purpose
is to compare a recorded performance $s \in \Sigma^*$
with a notated music sheet $t \in \Delta^*$.
One timestamp $d_i \in \Sigma$ may correspond
to one notated event $\<\mathsf{e}, d'_i> \in \Delta$, in which case
the weight value computed by the \SWT is the time distance between both
(see transitions $\wei_{11}$ below).
%
If $\<\mathsf{e}, d'_i>$ is followed by continuations
$\<\mathsf{-}, d'_{i+1}>$..., they are just skipped with no cost (transitions $\wei_{01}$ or weight $\one$).
%transitions
\[
\begin{array}{rclcrcl}
\wei_{11}(q_0, d, \< \mathsf{e}, d'>, q_0) & = & |d' - d| & \quad &
\wei_{11}(q_1, d, \< \mathsf{e}, d'>, q_0) & = & |d' - d|\\
\wei_{01}(q_0, \varepsilon, \< \mathsf{-}, d'>, q_0) & = & \one & &
\wei_{01}(q_1, \varepsilon, \< \mathsf{-}, d'>, q_0) & = & \one\\
\wei_{10}(q_0, d, \varepsilon, q_1) & = & \alpha & & %\multicolumn{3}{l}{\mathrm{for~all~} b \in \Delta}
\end{array}
\]
%
We also must be able to take performing errors into account, while still being able to compare with the score,
since a performer could, for example, play an unwritten extra note.
\lydia{reformulated this sentence}
%
This is modelled by the transition $\wei_{10}$ with an arbitrary weight value $\alpha \in \Semiring$,
switching from state $q_0$ (normal) to $q_1$ (error).
The transitions in the second column below switch back to the normal state $q_0$.
% the metric computed by the \SWT is the smallest sum of point wise distances
% between dates of input and output events.
At last, we let $q_0$ be the only initial and final state, with
$\init(q_0) = \final(q_0) = \one$, and
$\init(q_1) = \final(q_1) = \zero$.

\lydia{ccl to the ex}
That way, an \SWT is capable of evaluating the differences between a score and a performance,
all the while ensuring that performance errors are plausible.

%$\init(q_0, d, b) = \final(q_0, d, b) = \one$, and
%$\init(q_1, d, b) = \final(q_1, d, b) = \zero$,
%for all $d \in \Sigma$ and $b \in \Delta$.
\endex
\end{example}
\end{comment}


\noindent
 \emph{Symbolic Weighted Automata} %$A = \< Q, \init, \weight, \final >$
%over $\Sigma$,  $\Semiring$ and $\bar\Phi$
are defined  as the transducers of Definition~\ref{def:SWT},
by simply omitting the output symbols.
%
%In this case, the label theory $\bar\Phi$ can be reduced to a singleton $\< \Phi_\Sigma>$.
%
\begin{definition} \label{def:SWA}
A \emph{symbolic-weighted automaton} (\SWA)
over $\Sigma$, $\Semiring$ and $\bar\Phi$
%the input alphabet~$\Sigma$ and the commutative semiring $\Semiring$
is a tuple
$A = \< Q, \init, {\wei_1}, \final >$,
where $Q$ is a finite set of states,
$\mathsf{in} : Q \to \Semiring$ %\Phi_\Sigma$,
, respectively $\mathsf{out} : Q \to \Semiring$,  %\Phi_\Sigma,$
are functions defining the weight for entering
(respectively leaving) computation in a state,
and ${\wei_1}$ is a transition function
from $Q \times Q$ into~$\Phi_{\Sigma}$.
\end{definition}
%
\noindent
%\florent{mv formal def. weight for \SWA to app.?}
A \SWA \emph{transition} is a triplet of $Q \times \Sigma \times Q$, 
and, as in the case of \SWT,
we may write $\wei_1(q, a, q')$ for~$\phi(a)$
when $\wei_1(q, q') = \phi \in \Phi_\Sigma$.
%respectively $\mathsf{in}(q) = \phi$, $\mathsf{out}(q') = \phi$,
%respectively $\mathsf{in}(q, a) = \phi(a)$, $\mathsf{out}(q', a) = \phi(a)$.
%$\wei_1: Q \times \Sigma \times Q \to \Semiring$,
The computation of $A$ on words $s \in \Sigma^*$
is based on an intermediate function $\weight_A$,
defined as follows for $q, q' \in Q$, $a \in \Sigma$, $u \in \Sigma^*$
%
\begin{align}
\weight_A(q, \varepsilon, q') & = \one\ \mathrm{if}\  q = q'\ 
          \mathrm{and}\  \zero\  \mathrm{otherwise}\\
%\weight_A(q, \varepsilon, q') & = \zero \quad \mathrm{if~} q \neq q'\nonumber\\
\weight_A(q, au, q') & =  \displaystyle\bigoplus_{q'' \in Q}
    \wei_{1}(q, a, q'') \otimes \weight_A(q'', u, q')\nonumber
\label{eq:SWA-weight}
\end{align}
%
\noindent
and the weight value associated by $A$ to
$s \in \Sigma^*$ is defined as follows: %$s = s_1\ldots s_n \in \Sigma^+$
\begin{equation}
A(s)  =
\displaystyle\bigoplus_{q, q' \in Q} \init(q)
\mathop{\otimes} \weight_A(q, s, q') \mathop{\otimes} \final(q')
\label{eq:SWA-value}
\end{equation}


%
%When $\wei_\varepsilon(q, q') = \zero$ for all $q, q' \in Q$,
%the automaton~$A$ is called \emph{without $\varepsilon$-transitions}.

%The \emph{summary} of a $\SWT$, resp. a $\SWA$, is ***



%\subsection{Properties}
\noindent
The following property will be useful for
symbolic weighted parsing (Section~\ref{sec:parsing}).

\begin{proposition} \label{prop:epsilon}
Given a \SWT $T$ over $\Sigma$, $\Delta$,
$\Semiring$ commutative, bounded and complete,
and $\bar\Phi$ effective,
and a $\SWA$ $A$ over $\Sigma$, $\Semiring$ and $\bar\Phi$,
there exists a \SWA $B_{A, T}$ over $\Delta$, $\Semiring$ and $\bar\Phi$,
effectively constructible in PTIME, 
such that for every $t \in \Delta^+$,
$B_{A, T}(t) = \displaystyle\bigoplus_{s\in \Sigma^*} A(s) \otimes T(s, t)$.
\end{proposition}
%
\begin{proof}
(sketch, see Appendix~\ref{sec:closure} for details).
The state set of $B_{A, T}$ is the Cartesian product of
the state sets of $A$ and $T$ and its transitions simulate,
while reading an output word $t \in \Delta^*$, the
synchronized behaviour of $A$ and $T$ on $t$
and some input word $s \in \Sigma^*$.
The weight for reading the input $s$ is obtained with
$\bigoplus^1_\Sigma$.
%
The main difficulty comes from the transitions
of the form $\wei_{10}$, which read in input and ignore the output.
Such transition shall be simulated by $\varepsilon$-transitions in $B_{A, T}$,
but $\varepsilon$-transitions are not defined for $\SWA$.
Therefore, the $\varepsilon$-transitions
are eliminated on-the-fly during the construction of~$B_{A, T}$,
following a procedure of~\cite{LombardySakarovitch12ciaa}.
%\qed
\end{proof}

%The complexity of construction
%\noindent
%The construction time and size for $B_{A, T}$ are $O(\| T \|^3 . \| A \|^2)$,
%where the sizes $\| T \|$ and $\| A \|$ are their number of states.
%%of~$T$ is its number of states $|Q|$.
%\florent{revise complexity with nb. of tr. and states? 
%         or skip details and just say polynomial?}
%
The particular case of Proposition~\ref{prop:epsilon} with a singleton $A$,
\ie such that $A(s) = \one$ for a given $s \in \Sigma^*$
and $A(s') = \zero$ for every $s' \neq s$,
corresponds to a construction of a \SWA for the partial application of the \SWT $T$,
fixing the first argument $s$.
\begin{corollary} \label{cor:epsilon}
Given a \SWT $T$ over $\Sigma$, $\Delta$,
$\Semiring$ commutative, bounded and complete,
and $\bar\Phi$ effective,
and $s \in \Sigma^+$,
there exists an effectively constructible \SWA
$B_{s, T}$ over $\Delta$, $\Semiring$ and $\bar\Phi$,
such that for every $t \in \Delta^+$, $B_{s, T}(t) = T(s, t)$.
\end{corollary}


%\noindent
%The construction time and size for $B_{T, s}$ are $O(\| T \|^3 . | s |^2)$,
%where the size $\| T \|$ of~$T$ is its number of states $|Q|$.







%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% SW-VPA
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{SW Visibly Pushdown Automata}
\label{section:SWVPA}\label{sec:SWVPA}
The model presented now generalizes symbolic \VPA
(\SVPA~\cite{dAntonyAlur14SVPDA},
 themselves generalizing \VPA~\cite{AlurMadhusudan09nested} to infinite alphabets)
from Boolean semirings to arbitrary semiring domains.
It associates to every nested word over an infinite alphabet a weight value
in a semiring.
Nested words can describe structures of labeled trees.
In the context of parsing, they will be useful to
represent AST % parse trees.
(see Section~\ref{sec:parsing} and Appendix~\ref{app:trees}). % parse trees. 
%\florent{see \S 5 and App.A}

%\subsection{Definition}
\noindent
\label{sec:SWVPA-def}
\reviews{3) pb countable}
Let $\Delta$ be a countable alphabet,
%finite (large) or infinite,
partitioned into three
pairwise disjoint subsets~$\Deltai$, $\Deltac$, $\Deltar$,
whose elements are respectively called
\emph{internal}, \emph{call} and \emph{return} symbols~\cite{AlurMadhusudan09nested}.
% names are  coined by application to functional program verification
% \begin{itemize}
% \item a set $\Deltai$ of \emph{internal symbols} denoted $a$,
% \item a set $\Deltac$ of \emph{call symbols} denoted $\call{a}$,
% \item a set $\Deltar$ of \emph{return symbols} denoted $\return{a}$.
% \end{itemize}
Let~$\< \Semiring, \oplus, \zero, \otimes, \one>$ be a commutative and complete semiring and let
$\bar\Phi = \< \Phii, \Phic, \Phir, \Phici, \Phicc, \Phicr>$
be a label theory over $\Semiring$
%In order to simplify notations, %and following the definition of Section~\ref{section:transducer},
%we shall write respectively
where $\Phii$, $\Phic$, $\Phir$ and~$\Phicx$ 
(where $\mathsf{x}$ is either $\mathsf{i}$, $\mathsf{c}$, or $\mathsf{r}$)
stand respectively
for~$\Phi_\Deltai$, $\Phi_\Deltac$, $\Phi_\Deltar$ and~$\Phi_{\Deltac, \Delta_\mathsf{x}}$.
%
%Moreover, we extend this theory with a set $\Phii$
%of unary functions in $\Deltai \to \Semiring$,
%closed under $\oplus$ and $\otimes$.

\begin{example}\label{ex:nested-word}
In the nested score representation $O \in \Delta^*$ in Ex.~\ref{ex:running},
$\Deltai$ corresponds to timed notes and continuations,
%the set of music events of the form $<\nu, \tau>$
%where $\nu$ is either a note (e.g. A4), the continuation symbol $-$, or a
%rest symbol R.
and $\Deltac$ and $\Deltar$ contain respectively opening and closing parentheses.
%are used to encode the score structure:
%Let $\Deltac = \{\langle, \prec\}$ and  $\Deltar = \{\rangle, \succ\}$ where $\langle$
%(resp. $\rangle$)
%and $\prec$ (resp. $\succ$) correspond to start/end of measures, and start/end of
%tuplets. Then  \includegraphics[scale=0.20]{pictures/score5.png}
%is encoded with the nested word $\langle \prec 0, \frac{3}{4}, \frac{7}{8} \succ \rangle %\langle \prec 1, \frac{4}{3}, \frac{5}{3}  \succ \rangle$
Another example is the other candidate
\includegraphics[scale=0.35,trim=0 5mm 0 0]{pictures/ex2.pdf}
of transcription of~$I$,
linearized into
$O' =$
$\ccall{\mathsf{m}}\tstamp{[0,1]}$,
$\ccall{2}\tstamp{[0,1]}$,
$\mbox{\footnotesize A4}\tstamp{0}$,
$\ccall{2}\tstamp{[\frac{1}{2},1]}$,
$-\tstamp{\frac{1}{2}}$,
$\mbox{\footnotesize B4}\tstamp{\frac{3}{4}}$,
$\creturn{2}\tstamp{1}$,
$\creturn{2}\tstamp{1}$,
$\ccall{\mathsf{m}}\tstamp{[1,2]}$,
$\ccall{3}\tstamp{[1,2]}$,
$\mbox{\footnotesize `C$\sharp$5`}\tstamp{1}$,
$\mbox{\footnotesize D5}\tstamp{1}$,
$\mbox{\footnotesize E5}\tstamp{\frac{4}{3}}$,
$\mbox{\footnotesize F5}\tstamp{\frac{5}{3}}$,
$\creturn{3}\tstamp{2}$,
$\creturn{\mathsf{m}}\tstamp{2}$,
$\creturn{\mathsf{m}}\tstamp{2}$
(see also Fig.~\ref{fig:score-tree}).
The symbol between quotes $\mbox{\footnotesize `C$\sharp$5`}$
represents an \emph{appogiatura}, %(grace-note),
\ie an ornamental note with theoretical duration~0.
\endex
\end{example}


\begin{definition}
A \emph{Symbolic Weighted Visibly Pushdown Automata} (\SWVPA)
over  $\Delta = \Deltai \uplus \Deltac \uplus \Deltar$, $\Semiring$ and $\bar\Phi$
is a tuple $A = \< Q, P, \init, \bar\wei, \final >$,
where $Q$ is a finite set of states,
$P$ is a finite set of stack symbols,
$\mathsf{in} : Q \to \Semiring$
(respectively $\mathsf{out} : Q \to \Semiring$)
are functions defining the weight for entering
(respectively leaving) a state,
and $\bar\wei$ is a sextuplet composed of the transition functions :
$\weii : Q \times P \times Q \to \Phici$,
$\weiei : Q \times Q \to \Phii$,
$\weic : Q \times P \times Q \times P \to \Phicc$,
$\weiec : Q \times P \times Q \to \Phic$,
$\weir : Q \times P \times Q \to \Phicr$,
$\weier : Q \times Q \to \Phir$.
%and
%$\weiex : Q \times Q \to \Phix$
%with $\mathsf{x} \in \{ \mathsf{i}, \mathsf{c}, \mathsf{r}\}$.
\end{definition}
%
As in Section~\ref{section:transducer},
we extend the above transition functions as follows
for every $q, q' \in Q$, $p \in P$,
$a \in \Deltai$,
$\call{c} \in \Deltac$,
$\return{r} \in \Deltar$,
overloading their names: % for simplicity:
\[
\begin{array}{lll}
\weii: Q \times [\Deltac \times P] \times \Deltai \times Q \to \Semiring &
\weii(q, c, p, a, q') = \eta_\mathsf{ci}(c, a) &
\mathrm{where~} \eta_\mathsf{ci} = \weii(q, p, q'),\\
%
\weiei: Q \times \Deltai \times Q \to \Semiring &
\weiei(q, a, q') = \phi_\mathsf{i}(a) &
\mathrm{where~} \phi_\mathsf{i} = \weiei(q, q').\\
%
\weic: Q \times [\Deltac \times P] \times  [\Deltac \times P] \times Q \to \Semiring &
\weic(q, c, p, \call{c'}, p', q') = \eta_\mathsf{cc}(c, \call{c'}) &
\mathrm{where~} \eta_\mathsf{cc} = \weic(q, p, p', q'),\\
%
\weiec: Q \times [\Deltac \times P] \times Q \to \Semiring &
\weiec(q, {\call{c}}, p', q') = \phi_\mathsf{c}({\call{c}}) &
\mathrm{where~} \phi_\mathsf{c} = \weiec(q, p, q').\\
%
\weir: Q \times [\Deltac \times P] \times \Deltar \times Q \to \Semiring &
\weir(q, {\call{c}},  p, {\return{r}}, q') = \eta_\mathsf{cr}({\call{c}},  {\return{r}}) &
\mathrm{where~} \eta_\mathsf{cr} = \weir(q, p, q'),\\
%
\weier: Q \times \Deltar \times Q \to \Semiring &
\weier(q, {\return{r}}, q') = \phi_\mathsf{r}({\return{r}}) &
\mathrm{where~} \phi_\mathsf{r} = \weier(q, q').\\
\end{array}
\]
The tuples in the definition domains of the above functions 
are also called \emph{transitions} of the \SWVPA.
We denote by $\src(\tau)$ (respectively $\snd(\tau)$) the first (respectively second) 
state component of a transition~$\tau$.
%
\noindent
%The intuition is the following for the above transitions.
Intuitively, $\weiei$, $\weiec$, and $\weier$ describe the cases where the stack is empty.
The transitions of $\weii$ and $\weiei$ both read an internal symbol~$a$ 
and change state from $q$ to $q'$, without changing the stack.
Moreover, $\weii$ reads a pair made of
${\call{c}} \in \Deltac$ and $p \in P$ on the top of the stack
($c$ is compared to $a$ by the weight function $\eta_\mathsf{ci} \in \Phici$).
%
\noindent
The transitions of $\weic$ and $\weiec$ read the call symbol $\call{c}'$,
push it to the stack along with $p'$, and change state from $q$ to to $q'$.
Moreover, $\weic$ reads ${\call{c}}$ and $p$ at the top of the stack
($c$ is compared to $c'$).
%and $\weiec$ applies iff the stack is empty.
%
\noindent
Finally, $\weir$ and $\weier$ read the return symbol $\return{r}$, and change state from $q$ to to $q'$.
Moreover, $\weir$ reads and pops from stack a pair made of $\call{c}$ and $p$
($\call{c}$ is compared to $\return{r}$).
%and $\weier$ applies iff the stack is empty.
%In this case, the weight function $\phi_\mathsf{r}$
%computes a value of matching between the call and return symbols $c$ and $r$.
%This value might be set to $\zero$ in order to express that the symbols do not match.

Formally, the computations of the automaton~$A$ are defined
with an intermediate function $\weight_A$, like in Section~\ref{sec:SWT}.
%
A configuration $q[\gamma]$
is composed of a state $q \in Q$
and a stack content $\gamma \in \Gamma^*$,
where $\Gamma = \Deltac \times P$.
Hence, $\weight_A$ is a function from
$[Q \times \Gamma^*] \times \Delta^* \times [Q \times \Gamma^*]$ into~$\Semiring$.
The empty stack is denoted by $\bot$, and the topmost
symbol is the last pushed pair.
%
The recursive definition of $\weight_A$
enumerates each of the six possible cases:
reading $a \in \Deltai$,
%\lydia{intro to func}
or $\call{c} \in \Deltac$, or $\return{r} \in \Deltar$,
for each possible state of the stack (empty or not).
%to add to $u \in {\Delta}^*$.
%\lydia{introduced the 6 cases}
\florent{shorter notation $cp$ for $\< c, p>$ ?}

\begin{align}
%\weight_A\bigl(\config{q}{\bot}, \varepsilon, \config{q}{\bot}) & = \one\label{eq:SWVPA-weight}\\
%\weight_A\bigl(\config{q}{\bot}, \varepsilon, \config{q'}{\gamma}) & = \zero
%\mathrm{~if~} q \neq q'\nonumber\\
%
\weight_A\bigl(\config{q}{\bot}, \varepsilon, \config{q'}{\bot}) & = \one
\mathrm{~if~} q = q' \mathrm{~and~} \zero \mathrm{~otherwise}\label{eq:SWVPA-weight}\\
\weight_A\bigl(\configup{q}{\<{\call{c}}, p>\stackup\gamma}, a\, u,
               \config{q'}{\gamma'}\bigr) & =
 {\displaystyle\bigoplus_{q'' \in Q}} \weii(q, c, p, a, q'')
  \otimes \weight_A\bigl(\configup{q''}{\<{\call{c}}, p> \stackup \gamma}, u,
                         \config{q'}{\gamma'}\bigr)\nonumber\\
%
\weight_A\bigl(\config{q}{\bot}, a\, u,
               \config{q'}{\gamma'}\bigr) & =
  {\displaystyle\bigoplus_{q'' \in Q}} \weiei(q, a, q'')
   \otimes \weight_A\bigl(\config{q''}{\bot}, u, \config{q'}{\gamma'}\bigr)\nonumber\\
%
\weight_A\bigl(\configup{q}{\<{\call{c}}, p>\stackup\gamma}, {\call{c}'}\, u,
               \config{q'}{\gamma'}\bigr) & =
 {\displaystyle\bigoplus_{\begin{array}{c}
                          \scriptstyle q'' \in Q\\[-1ex]
                          \scriptstyle p' \in P
                          \end{array}}}
 \weic\bigl(q, {\call{c}}, p, {\call{c}'}, p', q''\bigr)
 \otimes \weight_A\bigl(\configup{q''}{\<{\call{c}'}, p'>\stackup \<{\call{c}}, p>\stackup \gamma}, u,
                        \config{q'}{\gamma'}\bigr)\nonumber\\[1mm]
%
\weight_A\bigl(\config{q}{\bot}, {\call{c}}\, u,
               \config{q'}{\gamma'}\bigr) & =
 {\displaystyle\bigoplus_{\begin{array}{c}
                          \scriptstyle q'' \in Q\\[-1ex]
                          \scriptstyle p \in P
                          \end{array}}}
  \weiec(q, {\call{c}}, p, q'')
  \otimes \weight_A\bigl(\config{q''}{\<{\call{c}}, p>}, u,
                         \config{q'}{\gamma'}\bigr)\nonumber\\
%
\weight_A\bigl(\configup{q}{\<{\call{c}}, p>\stackup\gamma}, {\return{r}}\, u,
               \config{q'}{\gamma'}\bigr) & =
 {\displaystyle\bigoplus_{q'' \in Q}}
  \weir\bigl(q, {\call{c}}, p, {\return{r}}, q''\bigr)
  \otimes \weight_A\bigl(\config{q''}{\gamma}, u,
                         \config{q'}{\gamma'}\bigr)\nonumber\\
%
\weight_A\bigl(\config{q}{\bot}, {\return{r}}\, u,
               \config{q'}{\gamma'}\bigr) & =
 {\displaystyle\bigoplus_{q'' \in Q}} \weier(q, {\return{r}}, q'')
  \otimes \weight_A\bigl(\config{q''}{\bot}, u,
                         \config{q'}{\gamma'}\bigr)\nonumber
\end{align}
%\lydia{c p to <c, p>}
%
% and ${\call{c}}\, p\stacksep \gamma$
%denotes a stack where the pair made of ${\call{c}} \in \Deltac$ and $p \in P$ is the top symbol
%and $\gamma$ is the rest of stack.

\noindent
The weight associated by $A$ to $t \in \Delta^*$
is defined according to empty stack semantics:
%
\begin{equation}
A(t)  =
{\displaystyle\bigoplus_{q, q' \in Q}} \textstyle
\mathsf{in}(q) \mathop{\otimes}
\weight_A\bigl(\config{q}{\bot}, t, \config{q'}{\bot}\bigr)
\mathop{\otimes} \mathsf{out}(q').
\label{eq:SWVPA-value}
\end{equation}

\noindent
Every $\SWA$ $A = \< Q, \init, {\wei_1}, \final >$,
over $\Sigma$, $\Semiring$ and $\bar\Phi$
is a special case of $\SWVPA$
$\< Q, \emptyset, \init, \bar\wei, \final >$
over $\Delta$, $\Semiring$ and $\bar\Phi$
with $\Deltai = \Sigma$ and $\Deltac = \Deltar = \emptyset$,
and computing with an always empty stack:
$\weiei = \wei_1$ and all the other functions
of~$\bar\wei$ are the constant~$\zero$.

\begin{example} \label{ex:SWVPA}
\reviews{revision ex. needed. see rev. 3) and app. $\weic$, $\weir$, $\weii$ wrong.}
We consider a \SWVPA over the alphabet of Example~\ref{ex:nested-word} and with $P = Q$,
that expresses a weight related to the music notation,
or more precisely to its structural complexity.
Given a set of equivalent representations, we aim at choosing the simpler one, \ie the one with the smallest weight.

\lydia{We should find a better variable name than j... it does not render well in fractions}
Let's say the top of the stack is a tuple of the call~$\ccall{n}\tstamp{[\tau, \tau+\ell]}$ and a state $q$. Let's now consider a new call transition starting in state $q_{\frac{j}{n}}$, that is the $j$-th state of the $n$ sub-intervals of duration~$\frac{\ell}{n}$.
We thus read a new time-division symbol ~$\ccall{d}$ 
and compute the weight of the transition from $q_{\frac{j}{n}}$ to $q_{\frac{1}{d}}$, 
the first state after the new~$\ccall{d}$, reading on the top of the stack the pair
$\<\ccall{n}\tstamp{[\tau, \tau+\ell]}, q>$, 
and pushing $\<\ccall{d}\tstamp{\iota}, q_{\frac{j+1}{c}}>$ on top, or:
\(
\weic\bigl(q_{\frac{j}{n}},
           \ccall{n}\tstamp{[\tau, \tau+\ell]}, q,
           \ccall{d}\tstamp{\iota}, q_{\frac{j+1}{c}},
           q_{\frac{1}{d}} \bigr) = \alpha_d
\).
\lydia{is it ok to explain precisely this computation and not the others ? is it redundant with the explaniation before equation (5) ?}
\noindent
Reading the $k$-th musical event $\mu$ in this current sub-interval is computed with:
\(
\weii\bigl(q_{\frac{k}{d}},
           \ccall{d}\tstamp{[\tau, \tau+\ell]}, q_{\frac{j}{n}},
           \mu\tstamp{\tau + \frac{j\ell}{d}}, q_{\frac{k+1}{d}} \bigr) = \alpha_\mu
\).
Finally, this sub-interval will end after reading a return symbol $\creturn{d}$ and compute:
\(
\weir\bigl(q_{\frac{d}{d}},
           \ccall{d}\tstamp{[\tau, \tau+\ell]}, q_{\frac{i+1}{c}},
           \,\creturn{d}\tstamp{\tau + \ell}, q_{\frac{i+1}{c}} \bigr) = \one
\).
\noindent
We described earlier the special cases where the stack is empty, which applies for example when reading the first measure 
for which we only push $\<\ccall{\mathsf{m}}\tstamp{[0, 1]}, q_{\frac{1}{1}}>$ in the stack:
\(
\weiec\bigl(q_{\frac{1}{1}},
           \ccall{\mathsf{m}}\tstamp{[0, 1]}, q_{1/1},
           q_{1/1} \bigr) = \one
\).
In comparison, any other new measure would compute instead:
\(
\weic\bigl(q_{\frac{1}{1}},
          \ccall{\mathsf{m}}\tstamp{[\tau-1, \tau]}, q_{\frac{1}{1}},
          \ccall{\mathsf{m}}\tstamp{[\tau, \tau+1]}, q_{\frac{1}{1}},
          q_{\frac{1}{1}} \bigr) = \one
\).

Each transition thus has a weight computing an overall weight for one representation of music notation. 
When setting the weights, we decide which notation is preferred if possible. 
For example, let's say we want to prioritize tuplets over triplets, then we set $\alpha_2$ and $\alpha_3$ such as $\alpha_2 > \alpha_3$. In conclusion, a \SWVPA is capable of computing several representations of the same piece of music, allowing to choose the best one.
\endex
\end{example}

%\begin{example} \label{ex:SWVPA}
%\reviews{revision ex. needed. see rev. 3) and app. $\weic$, $\weir$, $\weii$ wrong.}
%We consider a \SWVPA over the alphabet of Example~\ref{ex:nested-word} and with $P = Q$
%that expresses a weight related to the music notation,
%or more precisely to its structural complexity.
%Given a set of equivalent representations, we aim at choosing the simpler one.
%
%Let's say the top of the stack is a tuple of the call~$\ccall{n}\tstamp{[\tau, \tau+\ell] and a state $q$. Let's now consider a new call transition starting in state $q_{\frac{j}{n}}$, that is the $j$-th state of the $n$ sub-intervals of duration~$\frac{\ell}{n}$.
%We thus read a new time-division symbol ~$\ccall{d}$ and compute the weight of the transition from q_{\frac{j}{n}} to q_{\frac{1}{d} (the first state after the new ~$\ccall{d}$), reading the top of the stack <\ccall{n}\tstamp{[\tau, \tau+\ell]}, q>, and pushing <\ccall{d}\tstamp{\iota}, q_{\frac{j+1}{c}}> on top, or:
%\(
%\weic\bigl(q_{\frac{j}{n}},
           %\ccall{n}\tstamp{[\tau, \tau+\ell]}, q,
           %\ccall{d}\tstamp{\iota}, q_{\frac{j+1}{c}},
           %q_{\frac{1}{d}} \bigr) = \alpha_d
%%\).
%
%\noindent
%Reading the $k$-th musical event $\mu$ in this current sub-interval is computed with:
%\(
%\weii\bigl(q_{{k}/{d}},
           %\ccall{d}\tstamp{[\tau, \tau+\ell]}, q_{\frac{j}{n}},
           %\mu\tstamp{\tau + \frac{j\ell}{d}}, q_{\frac{k+1}{d}} \bigr) = \alpha_\mu
%\).
%Finally, this sub-interval will end after reading a return symbol \creturn{d} which will compute the transition:
%\(
%\weir\bigl(q_{\frac{d}{d}},
           %\ccall{d}\tstamp{[\tau, \tau+\ell]}, q_{\frac{i+1}{c}},
           %\,\creturn{d}\tstamp{\tau + \ell}, q_{\frac{i+1}{c}} \bigr) = \one
%\).
%
%\noindent
%We described earlier the special cases where the stack is empty, which applies for example when reading the first measure for which we push <\ccall{\mathsf{m}}\tstamp{[0, 1]}, q_{1/1}>, but don't read anything on the stack:
%\(
%\weiec\bigl(q_{1/1},
 %          \ccall{\mathsf{m}}\tstamp{[0, 1]}, q_{1/1},
%           q_{1/1} \bigr) = \one
%\).
%In comparison, any other new measure would compute instead:
%\(
%\weic\bigl(q_{1/1},
%          \ccall{\mathsf{m}}\tstamp{[\tau-1, \tau]}, q_{1/1},
%          \ccall{\mathsf{m}}\tstamp{[\tau, \tau+1]}, q_{1/1},
%          q_{1/1} \bigr) = \one
%\).
%\endex
%\end{example}


%\subsection{Properties}
\medskip\noindent
Similarly to \VPA~\cite{AlurMadhusudan09nested}
and \SVPA~\cite{dAntonyAlur14SVPDA},
the class of \SWVPA is closed under the binary operators of the underlying semiring.
%
\begin{proposition}\label{prop:SWVPA-product}
Let $A_1$ and $A_2$ be two \SWVPA
over the same $\Delta$, commutative $\Semiring$ and effective $\bar\Phi$.
There exist two effectively constructible $\SWVPA$
$A_1 \oplus A_2$ and $A_1 \otimes A_2$,
such that for every $s \in \Delta^*$,
$(A_1 \oplus A_2)(s) = A_1(s) \oplus A_2(s)$ and
$(A_1 \otimes A_2)(s) = A_1(s) \otimes A_2(s)$.
\end{proposition}
%
\begin{proof}
%We do a classical product construction, see Appendix~\ref{sec:product} for details.
%similar to the case of the Boolean semiring~\cite{dAntonyAlur14SVPDA}.
\input{app-product}
\end{proof}
\noindent
%We present now a procedure for searching, for a~$\SWVPA$ $A$,
%a word %$w \in \Delta^*$
%of minimal weight for~$A$.
We present now a procedure for searching a word of minimal weight for a~$\SWVPA$~$A$.
%as stated in the following proposition. %\wrt~$\leq_\oplus$,
%It requires the following property of label theories.
%
\begin{proposition}\label{th:best-search}
For a \SWVPA $A$
over $\Delta$,
$\Semiring$ commutative, bounded, total and complete, %semiring
and $\bar\Phi$ effective, %and $k$-convex, % label theory,
one can construct in PTIME a word $t \in \Delta^*$
such that $A(t)$ is minimal \wrt the natural ordering $\leq_\oplus$ for $\Semiring$.
\end{proposition}
%\florent{total?}
%
Let $A = \< Q, P, \init, \bar\wei, \final >$.
%
We propose a method for %Dijkstra-like algorithm 
computing,
for every $q, q' \in Q$,
the minimum, \wrt $\leq_\oplus$, of the function
$\beta_{q, q'} : t \mapsto \weight_A(\config{q}{\bot}, t, \config{q'}{\bot})$.
Let us denote by $b_\bot(q, q')$ this minimum.
\florent{it exists by effectiveness of label th. ?}
%
By definition of $\leq_\oplus$, and since $\Semiring$ is total,
\reviews{1) $\Semiring$ total $\to$ $\Semiring$ extremal}
it holds that
(the infinite sum in~\eqref{eq:bbot} is well defined since $\Semiring$ is complete):
%
\begin{equation}\label{eq:bbot}
  b_\bot(q, q') = \bigoplus_{t\in \Delta^*}
  \textstyle
  \weight_A\bigl(\config{q}{\bot}, t, \config{q'}{\bot}\bigr).
\end{equation}
%
Following~\eqref{eq:SWVPA-value}, and the associativity, commutativity
and distributivity for~$\otimes$ and~$\oplus$, the minimum of~$A(t)$ is:
\begin{equation}\label{eq:min}
{\displaystyle\bigoplus_{t\in \Delta^*}} A(t)
=
{\displaystyle\bigoplus_{t\in \Delta^*}}
{\displaystyle\bigoplus_{q, q' \in Q}} \textstyle
\mathsf{in}(q) \mathop{\otimes}
\beta_{q, q'}(t)
\mathop{\otimes} \mathsf{out}(q')
=
{\displaystyle\bigoplus_{q, q' \in Q}} \textstyle
\mathsf{in}(q) \mathop{\otimes}
b_\bot(q, q')
\mathop{\otimes} \mathsf{out}(q')
\end{equation}

\noindent
In order to compute the above function $b_\bot : Q \times Q \to \Semiring$,
we shall consider an auxiliary function $b_\top :  Q \times P \times Q \to \Phic$.
%%%%%% lydaddition %%%%%%
The function $b_\bot$ will allow to compute $b_\top$ recursively in the case where the stack in not empty.
%%%%%% lydaddition %%%%%%
%
Intuitively, $b_\top(q, p, q')$ is a function of $\Phic$,
mapping every $c \in \Deltac$ to
the minimum weight of a computation of~$A$
starting in state $q$, 
with a non-empty stack $\gamma' = \<c, p> \, \gamma \in \Gamma^+$,
and ending in state $q'$ with the same stack $\gamma'$,
such that
the computation does not pop the pair $\<c, p>$ at the top of $\gamma'$
(\ie $\gamma'$ is left untouched during the computation).
However, the computation can read $\<c, p>$ at the top of $\gamma'$,
and can also push another pair $\< c', p'> \in \Gamma$ on top of $\gamma'$,
following the third case 
in the definition \eqref{eq:SWVPA-weight} of $\weight_A$ (call symbol).
The pair $\< c', p'>$ can be popped later, during the computation from $q$ to $q'$,
following the fifth case of \eqref{eq:SWVPA-weight} (return symbol).
%However, it cannot apply one of the two last cases (return symbol and empty stack)
%when the current stack is $\gamma$.
%pop symbols in $\gamma$.
%
% Note that having a stack reduced to such a symbol makes impossible the application of the
% two last cases in the definition of $\weight_A$ (return symbol and empty stack).
% However, it is possible to apply the two first cases
% (internal symbol or call symbol, with a push on the top of $\top$).
%
Formally, in order to define $b_\top$, we consider
a fresh stack symbol $\top \notin \Gamma$,   %which does not belong to $\Gamma$,
representing the above untouched stack, and let:
%
\begin{equation}\label{eq:btop}
  b_\top(q, p, q') : c \mapsto \bigoplus_{s\in \Delta^*}
  \textstyle
  \weight_A\bigl(\configup{q}{\< c, p> \stackup \top }, s, \configup{q'}{\<c, p> \stackup \top}\bigr)
\quad
\mathrm{~for~all~} c \in \Deltac
\end{equation}
%
%By definition of $\weight_A$ in \eqref{eq:SWVPA-weight},
%using the symbol $\top$ for the part of the stack below $\<c, p>$
%(\ie the substack $\gamma$ in the above $\gamma' = \<c, p> \, \gamma$)
%ensures that this part is not touched during the computation.
% there cannot be a pop of $\<c, p>$ followed by a push of $\<c, p>$
% because it is not possible to push over $\top$ (push read the top of stack).
%
This ensures in particular that the subword
read during the computation is well parenthesized
(every symbol in $\Deltac$ has a matching symbol in $\Deltar$).

% Note that having a stack reduced to such a symbol makes impossible the application of the
% two last cases in the definition of $\weight_A$ (return symbol and empty stack).
% However, it is possible to apply the two first cases
% (internal symbol or call symbol, with a push on the top of $\top$).

%The term $\config{q}{\bot}, s, \config{q'}{\bot}$
%of this sum is the central expression in
%the definition \eqref{eq:weightA} of $A(s_0)$, for the minimum $s_0$
%of the function $\weight_A$.


%\input{algo-best}
\input{algo-best-alt}




%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Symbolic Weighted Parsing}
\label{sec:parsing}
%% see parse-tree.tex for a definition with parse tree (instead of nested words)

Let us now apply the models and results of the previous sections %in order to define
to the problem of parsing over an infinite alphabet. %appropriate
%
%\subsection{Definition}
%
Let~$\Sigma$
and~$\Delta = \Deltai \uplus \Deltac \uplus \Deltar$
be countable input and output alphabets,
let $\< \Semiring, \oplus, \zero, \otimes, \one>$ be a
commutative, bounded, total and complete %\florent{total?} 
semiring and let $\bar\Phi$ be an effective label theory over $\Semiring$,
containing $\Phi_\Sigma$, $\Phi_{\Sigma, \Deltai}$, as well as
$\Phii$, $\Phic$, $\Phir$, $\Phicr$
(following the notations of Section~\ref{sec:SWVPA-def}).
%
\noindent
We assume the following input to be given:
\begin{description}
\item[--] a \SWT $T$ over $\Sigma$, $\Deltai$, $\Semiring$, and $\bar\Phi$,
defining a measure %between words
$T: \Sigma^* \times \Deltai^* \to \Semiring$,

\item[--] a \SWVPA $A$ over $\Delta$, $\Semiring$, and $\bar\Phi$,
defining a measure $A: \Delta^* \to \Semiring$,
%a \SWVPA $A$ over $\Delta$, and $\Semiring$, defining a series of nested words
%      $A : \Delta^* \to \Semiring$,
\item[--] an input word $s \in \Sigma^*$.
\end{description}
%
For every $u \in \Sigma^*$ and $t \in \Delta^*$, let
\(d(u, t) = T\bigl(u, t|_\Deltai \bigr)\),
where $t|_\Deltai \in \Deltai^*$ is the projection of $t$ onto~$\Deltai$,
obtained from $t$ by removing all symbols in $\Delta \setminus \Deltai$.
%
\noindent
\emph{Symbolic weighted parsing} is the problem,
given the above input,
to find $t \in \Delta^*$ %nested word $t \in \Delta$
minimizing \( d(s, t) \otimes A(t)\)
\wrt $\leq_\oplus$,
\ie s.t. %such that: %Hence, it is the problem of finding
%
\begin{equation}\label{eq:distance-lang}
d(s, t) \otimes A(t) = \displaystyle\bigoplus_{u \in \Delta^*} d(s, u) \otimes A(u)
\end{equation}
%
Following the terminology of~\cite{Mohri03ijfcs},
$\SW$-parsing is the problem of computing
the distance~\eqref{eq:distance-lang} between the input string ~$s$ and the weighted language over the output alphabet defined by ~$A$,
and returning a witness $t$.

\begin{example}[Symbolic Weighted Parsing and the transcription problem]
Applied to the music transcription problem, the above formalism
is interpreted as follows:
%
\begin{itemize}
\item The input word is $I$ of Example~\ref{ex:running}.
\item The \SWT $T$ evaluates a ``fitness measure''  that expresses
    a correspondence between a performance and a nested representation of a music score.
    See Example~\ref{ex:SWT}.
\item The \SWVPA $A$ expresses a cost related to the music notation.
\end{itemize}
%One possibility is to relate this cost to the structural complexity:
%given a set of equivalent representations,
%we aim at choosing the simpler one.
%
As seen in Example~\ref{ex:SWVPA},
\includegraphics[scale=0.35,trim=0 5mm 0 0]{pictures/ex1.pdf},
%\includegraphics[scale=0.20]{pictures/score5.png}
will be favored on
\includegraphics[scale=0.35,trim=0 5mm 0 0]{pictures/ex2.pdf}
%\includegraphics[scale=0.20]{pictures/score4.png}.
when the weight assigned to an additional second time division with $\ccall{2}$ is less
than the difference of weight between
$\mbox{`\footnotesize C$\sharp$5`}$
and $\mbox{\footnotesize C$\sharp$5}$.

\noindent
The SW-parsing framework, applied to the transcription problem,
allows to find an optimal solution
that considers both the fitness of the result,
and its structural complexity.
\endex
\end{example}
The application to music transcription suggested briefly in the examples
has been implemented in a C++ tool~\cite{qparse}, %\footnote{https://qparse.gitlabpages.inria.fr}.
following the principles of the present SW-parsing framework, 
although it differs in several points.
In particular, the automata constructions are performed on the on-the-fly
during the search of a best AST, for efficiency reasons.


%
%\subsection{Computation}
%
\begin{proposition}
The problem of Symbolic Weighted Parsing
can be solved in PTIME in the size of the input \SWT $T$, \SWVPA $A$
and input word $s$,
and the computation time of the functions and operators of the label theory.
\end{proposition}
%
\begin{proof} (sketch)
We follow a \emph{Bar-Hillel} construction for parsing by intersection.
%
\noindent
We first extend the \SWT $T$ over $\Sigma$, $\Deltai$
into a \SWT $T'$ over $\Sigma$ and $\Delta$
(and the same semiring and label theory $\Semiring$ and $\bar\Phi$),
such that for every $u \in \Sigma^*$, and $t \in {\Delta}^*$,
$T'(u, t) = T(u, t|_{\Deltai})$.
%
$T'$ simply skips every symbol
$b \in {\Delta} \setminus \Deltai$
by the addition 
of new transitions of the form $\wei_{01}(q, \varepsilon, b, q')$ to $T$.
%
\noindent
Then, using Corollary~\ref{cor:epsilon},
we construct from $s \in \Sigma^*$ and $T'$
a \SWA $B_{s, T'}$,
such that for every $t \in \Delta^*$, $B_{s, T'}(t) = d(s, t)$.
%
%This automaton is such that for all $t \in \Delta^*$,
%\[
%   A_{T', s}\bigl(\lin(t)\bigr)
% = T'\bigl(s, \lin(t)\bigr)
% = T'\bigl(s, \lin(t)|_{\Deltai}\bigr)
% = d(s, t).
%\]
%
\noindent
Next, %we convert the input \SWTA $A$ over $\Delta$
%into a \SWVPA $A'$ over $\hat\Delta$, using Proposition~\ref{lem:SWTA}, and
we compute the \SWVPA $B_{s, T'} \otimes A$,
using Proposition~\ref{prop:SWVPA-product}.
%
\noindent
It remains to compute a best nested word $t \in {\Delta}^*$
using the procedure of Proposition~\ref{th:best-search}.
%and convert it into a best tree in $\T_\Delta$ in order to solve SW parsing
%for~$T$, $A$ and~$s$.
%\qed
\end{proof}

The $\SW$-parsing problem generalizes
the problem of searching for the best derivation (AST) of a weighted CF-grammar $G$
that yields a given input word $w$, called~\emph{weighted parsing},
(see~\cite{Goodman99SemiringParsing},
 also the more general framework~\cite{MorbitzVogler19weighted-parsing}),
with an infinite input alphabet instead of a finite one and
transducer-defined distances instead of equality. 
%
See Appendix~\ref{sec:trees} for more details on the correspondence between 
nested words $t \in \Delta^*$, AST, CF grammars and \SWVPA.

%
%Indeed, it corresponds to the case where $T$
%accepts only the pairs $\<s, t>$ such that
%$s$ is the projection of $t$ on $\Deltai$.
%This can be done with a single state $q$ and
%with transition rules of the form:
%\begin{description}
%\item[] $\wei(q, \varepsilon, a, q) = \one$ for all $a \in \Deltac \cup \Deltar$,
%\item[] $\wei(q, a, a, q) = \one$ for all $a \in \Deltai$,
%\item[] $\wei(q, a, b, q) = \zero$ for all $a, b \in \Deltai$, $a \neq b$.
%\end{description}
%
%Weighted parsing
%corresponds to $\SW$-parsing in the case of finite alphabets,
%a transducer $T$ computing the identity and some \SWVPA~$A$
%obtained from $G$. %the weighted CF grammar.
%Indeed, the \emph{depth-first} traversal of an AST $\tau$
%yields a well-parenthesised word $\lin(\tau)$ over an alphabet
%$\Delta = \Deltai \uplus \Deltac \uplus \Deltar$,
%assuming \eg that $\Deltai$ contains the symbols labelling the leaves of $\tau$ 
%(symbols of rank $0$),
%and $\Deltac$ and $\Deltar$ contain respectively one left and right parenthesis
%$\ccall{b}$ and $\creturn{b}$ for each symbol $b$ labelling inner nodes of $\tau$ 
%(symbols of rank $>0$).
%
%With this representation, the projection $\lin(t)|_\Deltai$ is the
%sequence of leaves of $\tau$. %, enumerated in a \emph{dfs}-traversal.
%
%We show in Appendix~\ref{sec:trees} how to construct
%%($\SW$) tree automaton~$A$ %(in particular the TA computing on the AST of a given CF-grammar)
%a $\SWVPA$ $A$ such that $A(\lin(\tau))$ is the weight the AST $\tau$ of $G$.


%That also holds for the set of ASTs of a weighted CF-grammar.
%The purpose of the transducer $T$ is to measure a distance between input and output words,
%\ie between the word $s$ and the sequence leaves of a derivation tree, in $\Deltai^*$.
%
%that generates (weighted) trees by replacement of a state symbol~$q_0$ (non-terminal),
%by a tree $a(q_1,\ldots, q_k)$, where $k = \rank(a)$.
%A replacement rule $q_0 \to a(q_1,\ldots, q_k)$,
%of weight $\wei(q_0, a, q_1 \ldots q_k) \in \Semiring$
%according to Definition~\ref{def:SWTA},
%corresponds to the production rule $q_0 := a(q_1,\ldots, q_k)$ of a weighted CF grammar,
%with set non-terminal symbols $Q$ and set of terminal symbols $\Delta_0$.
%
%This actually is a slight generalization of CFG since
%each such production rule is labelled by  a symbol of $\Delta_{>0}$,
%hence parse trees %derivation trees
%are trees of $\T_\Delta)$.
%
%Another (more original) generalization is that the set of terminal symbols
%$\Delta_0$ may be infinite.
%
%
%The input language can also be expressed as a \SWTA, or,
%as a particular case, as a weighted context-free grammar,
%converted in turn into a \SWVPA following Lemma~\ref{lem:SWTA}.
%
%\florent{In practice,
%the functions in transition might be represented by diagram such as
%Algebraic Decision Diagrams~\cite{Bahar97ADD}.}
%\paragraph{Application to Automated Music Transcription.}
%\input{transcription}
%...

\section*{Conclusion}

We  introduced Symbolic Weighted language models %over infinite alphabets,
and applied them to the problem of parsing
with infinitely many possible input symbols (typically timed events).
Our approach extends conventional parsing and weighted parsing
by computing a derivation tree modulo
a distance between words
defined by a SW transducer given in input.
This allows to consider finer word relationships than strict equality.
%

This work can be extended in several directions. First, 
the best search algorithm could be generalized from $1$-best to $n$-best~\cite{Huang05kbest},
and to $k$-\emph{closed} semirings~\cite{Mohri02semiring}
(instead of \emph{bounded}, which corresponds to $0$-\emph{closed}). Second,
%we believe that
the complexity bounds of the algorithms could be more precisely characterized,
as well as expressiveness of \swM compared to the automata of 
\eg~\cite{Segoufin06csl,KaminskiFrancez94,NevenSchwentickVianu04FSMinfinite,Bojanczyk11FO2}.
Finally, the  best search algorithm presented here works offline, whereas
an on-the-fly automata construction would allow for online parsing,
a suitable feature in the context of applications such as 
\eg automatic music transcription.

\florent{comparison of expressiveness with the automata 
of\cite{Segoufin06csl,KaminskiFrancez94,NevenSchwentickVianu04FSMinfinite,Bojanczyk11FO2}.}

\newpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% BIBLIO                                                                     %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\bibliographystyle{plain}
%\bibliographystyle{abbrv}
\bibliographystyle{plainurl}  % LIPICS
%\bibliographystyle{splncs04} % LLNCS
%\bibliographystyle{eptcs}    % EPTCS
%\bibliography{generic}

\bibliography{references}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% APPENDIX                                                                   %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\appendix

%\section{Properties of Label Theory Operators} \label{sec:closure}
%\input{app-labels}

\section{Proof of Proposition~\ref{prop:epsilon}} \label{sec:closure}
\input{app-closure}

%\section{Proof of Proposition~\ref{prop:SWVPA-product}} \label{sec:product}
%\input{app-product}

%\section{Correctness of the Best-Search Algorithm} \label{sec:bestsearch}
%\input{app-bestsearch}

%\section{Nested Words and Parse Trees} \label{sec:trees}\label{app:trees}
%\input{app-trees}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% TODO                                                                       %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newpage
%\listoftodos


\end{document}
