
% SWT without epsilon-transitions
% SWT do not read the other tape in "skip" transitions 10 or 01
%     (hence this version is simpler  than V2)
% SWA without epsilon-transitions
% SW-VPA read top of stack (when not empty) at every transition 
%        (6 kinds of transitions).

% default style article.cls
\input{main-article}

% Springer llncs style
% https://www.springer.com/gp/computer-science/lncs/conference-proceedings-guidelines
%\input{main-llncs}

% EPTCS style
% http://www.eptcs.org
%\input{main-eptcs}
 

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}

\usepackage{hyperref}
%\usepackage[bookmarks,bookmarksnumbered,naturalnames,plainpages=false]{hyperref}
%usepackage{url}

% for footnote ref
\usepackage{refcount} 

% array and tabular
\usepackage{array}
\newcolumntype{C}[1]{>{\centering\arraybackslash\hspace{0pt}}p{#1}}

% extension of enumerate env. (style for displaying counters)
% \usepackage{enumerate} 

%% pictures
% \usepackage{graphicx} 
% \DeclareGraphicsExtensions{.pdf,.png,.jpg}
% \graphicspath{fig/}

%% PGF, Tikz
\usepackage{tikz-cd}
%% \usepackage{pgfplots}
%% \usepgfplotslibrary{dateplot}
%% \usepackage{pgf,pgfarrows,pgfnodes, pgfautomata}
% \usepackage{tikz}
% \usetikzlibrary{cd}
%% \usetikzlibrary{arrows}
%% \usetikzlibrary{calc}
%% \usetikzlibrary{snakes}
%% \usetikzlibrary{backgrounds}
% \usetikzlibrary{trees}
%% \usetikzlibrary{automata}
%% \usetikzlibrary{positioning}
%% \usetikzlibrary{matrix}
%% \usetikzlibrary{patterns}
%% \usetikzlibrary{shapes}

% symbols
\usepackage{amsmath} 
\allowdisplaybreaks
\usepackage{amssymb} 
\usepackage{amsbsy}
\usepackage{bbold}
\usepackage{latexsym}
%\usepackage{amsfonts}
\usepackage{stmaryrd}
%\usepackage{mathabx}
%\usepackage{MnSymbol}
\usepackage{harmony} % simple music fonts
\usepackage{mathtools} % for arrows
%\usepackage{mathptmx}

%% algorithms
%\usepackage{algorithm} 
%\usepackage{program} 

%% allows for page break within arrays
\usepackage{longtable}

%% arrows etc
%\input{rewriting}

%% music symbols
% see http://tug.ctan.org/info/latex4musicians/latex4musicians.pdf
\usepackage{musicography}

%% for new macros
\usepackage{xspace}

%% Misc macros
\def\ie{\textit{i.e.}\xspace}
\def\eg{\textit{e.g.}\xspace}
\def\wrt{\textit{wrt}\xspace}
%\def\wlog{\textit{wlog}\xspace}
\def\etc{\textit{etc}\xspace}

\def\<#1>{\langle #1 \rangle}
\newcommand{\pair}[2]{\langle{#1}, {#2}\rangle}

%\newcommand{\config}[2]{\ensuremath \genfrac{[}{]}{0pt}{}{#1}{#2}} 
\newcommand{\config}[2]{\ensuremath{#1}[{#2}]} 
\newcommand{\configup}[2]{\ensuremath{#1}\left[\begin{array}{c} #2 \end{array}\right]}
\def\stacksep{\cdot}
\def\stackup{\\} 

\newcommand{\opluseq}{\ensuremath\mathrel{\oplus}=}

% \bigominus
\DeclareFontFamily{U}{mathx}{\hyphenchar\font45}
\DeclareFontShape{U}{mathx}{m}{n}{
<-6> mathx5 <6-7> mathx6 <7-8> matha7
<8-9> mathx8 <9-10> mathx9
<10-12> mathx10 <12-> mathx12
}{}
\DeclareSymbolFont{mathx}{U}{mathx}{m}{n}
\DeclareMathSymbol{\bigominus}{\mathop}{mathx}{"C1}

%\newcommand{\A}{\mathcal{A}}
%\newcommand{\B}{\mathcal{B}}
\newcommand{\D}{\mathbb{D}}
\newcommand{\E}{\mathbb{E}}
%\newcommand{\P}{\mathcal{P}}
\newcommand{\Q}{\mathcal{Q}}
\newcommand{\R}{\mathcal{R}}
\newcommand{\T}{\mathcal{T}}
\newcommand{\W}{\mathbb{W}}
\newcommand{\Semiring}{\mathbb{S}}
\newcommand{\zero}{\mathbb{0}}
\newcommand{\one}{\mathbb{1}}
\newcommand{\dom}{\ensuremath{\mathit{dom}}}

\def\SA{\textsf{sA}\xspace}
\def\WA{\textsf{wA}\xspace}
\def\SWT{\textsf{swT}\xspace}
\def\SWA{\textsf{swA}\xspace}
\def\SWTA{\textsf{swTA}\xspace}
\def\SWVPA{\textsf{sw-VPA}\xspace}
\def\weight{\mathsf{weight}}
\def\wei{\mathsf{w}}
\def\mei{\mathsf{m}}
\def\init{\mathsf{in}}
\def\final{\mathsf{out}}
\newcommand{\call}[1]{\ensuremath #1} %{\ensuremath \langle_{#1}}
\newcommand{\return}[1]{\ensuremath #1} %{\ensuremath {}_{#1}{\rangle}} % $\prescript{}{a}{)}$
\def\Omegai{{\Omega_\mathsf{i}}}
\def\Omegac{{\Omega_\mathsf{c}}}
\def\Omegar{{\Omega_\mathsf{r}}}
\def\Sigmai{{\Sigma_\mathsf{i}}}
\def\Sigmac{{\Sigma_\mathsf{c}}}
\def\Sigmar{{\Sigma_\mathsf{r}}}
\def\Deltai{{\Delta_\mathsf{i}}}
\def\Deltac{{\Delta_\mathsf{c}}}
\def\Deltar{{\Delta_\mathsf{r}}}
\def\Phii{{\Phi_\mathsf{i}}}
\def\Phic{{\Phi_\mathsf{c}}}
\def\Phir{{\Phi_\mathsf{r}}}
\def\Phix{{\Phi_\mathsf{x}}}
\def\Phici{{\Phi_\mathsf{ci}}}
\def\Phicc{{\Phi_\mathsf{cc}}}
\def\Phicr{{\Phi_\mathsf{cr}}}
\def\Phicx{{\Phi_\mathsf{cx}}}
\def\weii{{\wei_\mathsf{i}}}
\def\weic{{\wei_\mathsf{c}}}
\def\weir{{\wei_\mathsf{r}}}
\newcommand{\weie[1]}{\wei_{#1}^\mathsf{e}}
\def\weiei{\weie[\mathsf{i}]}
\def\weiec{\weie[\mathsf{c}]}
\def\weier{\weie[\mathsf{r}]}
\def\weiex{\weie[\mathsf{x}]}
\newcommand{\ioi}[1]{\mathsf{ioi}({#1})}
\newcommand{\rank}{\mathsf{rk}}
\newcommand{\lin}{\mathsf{lin}}


%\sloppy

% Parsing over infinite alphabet as optimal alignment computation 
% as edit-distance between string and language
% 
%\title{Symbolic Weighted Parsing and Automated Music Transcription}
%\title{Symbolic Weighted Language Models and Automated Music Transcription}
\title{Symbolic Weighted Language Models and\\ Parsing over Infinite Alphabets}
%\title{Weighted Visibly Pushdown Automata and Automated Music Transcription}
%\titlerunning{WVPA \& AMT}
%\titlerunning{Symbolic Weighted Parsing} % and Automated Music Transcription
%\authorrunning{Florent Jacquemard}

\date{\today}
 
\begin{document}
\thispagestyle{empty}
\maketitle

\begin{abstract}
\input{abstract}
\end{abstract}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% intro
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Introduction} \label{sec:intro}
\input{introduction}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% prelin
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Preliminary Notions}
\label{section:prelim}\label{sec:prelim}

%notations: for set $S$ : sets of sequences $S^*$ and $S^+$...
%interval $[i..j]$ of natural numbers



\subsection{Semirings} 
\label{section:semiring}\label{sec:semiring}
\input{semiring}


\subsection{Label Theory}
\label{section:symbols}
\input{labels}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% SWT & SWA
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{SW Automata and Transducers}
\label{section:transducer}\label{sec:transducer}
\label{section:SWA}\label{sec:SWA}
\label{section:SWT}\label{sec:SWT}

We follow the approach of~\cite{Mohri03EDWA} for the computation of distances,
between words and languages, using weighted transducers, 
and extend it to infinite alphabets.
% with models of symbolic weighted automata and transducers. 
%
The models introduced in this section generalize 
weighted automata and transducers~\cite{Droste09handbook} 
%over finite alphabets, see  e.g.~\cite{Mohri03EDWA}, 
by labelling each transition with a weight function (instead of a simple weight value), 
that takes the input and output symbols as parameters. 
These functions are similar to the guards of symbolic automata~\cite{dAntoniVeanes17CAV,dAntoni21CACM},
but they can return values in an generic semiring, 
whereas the latter guards are restricted to the Boolean semiring.


%\subsection{Definitions} \label{sec:SWTdef}\label{sec:SWAdef}
%(SWT)
\noindent 
Let $\Semiring$ be a commutative semiring, 
$\Sigma$ and $\Delta$ be alphabets called respectively \emph{input} and \emph{output}, %{alphabets}, 
and $\bar\Phi$ be a label theory over $\Semiring$
containing $\Phi_\Sigma$, $\Phi_\Delta$, $\Phi_{\Sigma, \Delta}$.

\begin{definition}
\label{def:transducer} \label{def:SWT}
A \emph{symbolic-weighted transducer} (\SWT)
over $\Sigma$, $\Delta$, $\Semiring$ and $\bar\Phi$
%the input and output alphabets~$\Sigma$ and $\Delta$ with label theory $\bar\Phi$, and the semiring $\Semiring$ 
is a tuple
$T = \< Q, \init, \bar{\wei}, \final >$,
where $Q$ is a finite set of states, 
$\mathsf{in} : Q \to \Semiring$   %\Phi_{\Sigma, \Delta}
respectively $\mathsf{out} : Q \to \Semiring$  %\Phi_{\Sigma, \Delta}
are functions defining the weight for entering, 
respectively leaving, computation in a state,  
and $\bar{\wei}$ is a triplet of transition functions 
$\wei_{10}: Q \times Q \to \Phi_{\Sigma}$,
$\wei_{01}: Q \times Q \to \Phi_{\Delta}$, and 
$\wei_{11}: Q \times Q \to \Phi_{\Sigma, \Delta}$.
\end{definition}
%
\noindent
For convenience, we shall sometimes present transition functions 
as functions of  
$Q \times (\Sigma \cup \{ \varepsilon \}) \times (\Delta \cup \{ \varepsilon \}) \times Q \to \Semiring$,
overloading the function names,
such that, for all $q, q' \in Q$, $a \in \Sigma$,  $b \in \Delta$, 
\[
\begin{array}{rcll}
\wei_{10}(q, a, \varepsilon, q') & = & \phi(a) & %\wei_\Sigma(q, q')(a)
\quad\mathrm{where~} \phi = \wei_{10}(q, q') \in \Phi_\Sigma,\\
\wei_{01}(q, \varepsilon, b, q') & = & \psi(b) & 
\quad\mathrm{where~} \psi = \wei_{01}(q, q') \in \Phi_\Delta,\\
\wei_{11}(q, a, b, q') & = & \eta(a, b) & 
\quad\mathrm{where~} \eta = \wei_{11}(q, q') \in \Phi_{\Sigma, \Delta}.\\
\end{array}      
\]
%
\noindent 
% The symbolic-weighted transducer
The \SWT $T$ computes on pairs of words $\< s, t> \in \Sigma^* \times \Delta^*$,
$s$ and $t$, being respectively called input and output word.
% \noindent
More precisely, $T$ defines a mapping 
from $\Sigma^* \times \Delta^*$ into~$\Semiring$,
based on an intermediate function $\weight_T$
defined recursively for every states $q, q' \in Q$, 
and every strings $\< s, t> \in \Sigma^* \times \Delta^* \setminus \{ \< \varepsilon, \varepsilon >\}$ by:
%$a \in \Sigma$, $u \in \Sigma^*$, $b\in \Delta$, $v\in \Delta^*$, by:
%
\begin{align}
\weight_T(q, \varepsilon, \varepsilon, q)  & = \one \label{eq:SWT-weight}\\ %\final(q)\\
\weight_T(q, \varepsilon, \varepsilon, q') & = \zero \quad \mathrm{if~} q \neq q'\nonumber\\
%\weight_T(q, au, \varepsilon, q') & = \displaystyle\bigoplus_{q'' \in Q} 
%    \wei_{10}(q, a, \varepsilon, q'') \otimes \weight_T(q'', u, \varepsilon, q')\nonumber\\
%\weight_T(q, \varepsilon, bv, q') & = \displaystyle\bigoplus_{q'' \in Q} 
%    \wei_{01}(q, \varepsilon, b, q'') \otimes \weight_T(q'', \varepsilon, v, q')\nonumber\\
\weight_T(q, s, t, q') & = \displaystyle\bigoplus_{\begin{array}{c}
                                                   \scriptstyle q'' \in Q\\
                                                   \scriptstyle s = au,\, a \in \Sigma
                                                   \end{array}} 
    \wei_{10}(q, a, \varepsilon, q'') \otimes \weight_T(q'', u, t, q')\nonumber\\
                    & \oplus \displaystyle\bigoplus_{\begin{array}{c}
                                                     \scriptstyle q'' \in Q\\ 
                                                     \scriptstyle t = bv,\, b \in \Delta\\
                                                     \end{array}} 
    \wei_{01}(q, \varepsilon, b, q'') \otimes \weight_T(q'', s, v, q')\nonumber\\
                    & \oplus \displaystyle\bigoplus_{\begin{array}{c}
                                                     \scriptstyle q'' \in Q\\
                                                     \scriptstyle s = au,\, t = bv\\
                                                     \end{array}} 
    \wei_{11}(q, a, b, q'') \otimes \weight_T(q'', u, v, q')\nonumber
\end{align}
%
We recall that, by convention (Section~\ref{sec:semiring}), 
an empty sum with $\bigoplus$ is equal to~$\zero$. 
%
Intuitively, using a transition $\wei_{ij}(q, a, b, q')$ means for $T$:
when reading respectively $a$ and $b$ at the current positions in the input and output words, 
increment the current position in the input word if and only if $i = 1$, 
and in the output word iff $j = 1$ (otherwise, do not change it),
and change state from $q$ to $q'$.
When $a = \varepsilon$ (resp. $b = \varepsilon$), the current symbol 
in the input (resp. output) is not read.
%
%In contrast with the models of weighted transducers over finite alphabets~\cite{Mohri03ijfcs},
%the input and output symbols at current positions are always read by transitions, 
%even when they do not change the reading position the head's position.
%This is an important feature in the case of an infinite alphabet in 
%order to compare input and output symbols.
%which cannot be stored in the finite memory of the transducer.
%
Since $\zero$ is absorbing for~$\otimes$ in~$\Semiring$,
one term $\wei_{ij}(q, a, b, q'')$ equal to $\zero$ in the above expression 
will be ignored in the sum, meaning that there is no possible transition
from state $q$ into state $q'$ while reading $a$ and $b$.
This is analogous to the case of a transition's guard not satisfied by $\<a, b>$ for 
symbolic transducers.

%whereas considering the current symbol may be useful to compute a transition weight.
%(even when it does not change the head's position, like with $\varepsilon$-transitions).
%
%The cases $\weight_T(q, au, \varepsilon, q')$ and $\weight_T(q, \varepsilon, bv, q')$
%are missing in the definition of $\weight_T$.
%It means that $T$ must avoid configurations where it reached the end of 
%the output word and not of the input one, or vice-versa.
%This can be done by using $\wei_{10}$ and $\wei_{01}$
%before reaching the end of word, and using a special state for this purpose.

The expression \eqref{eq:SWT-weight} 
can be seen as a stateful definition of 
an edit-distance between a word $s \in \Sigma^*$ and a word $t \in \Delta^*$,
see also~\cite{Mohri03ijfcs}.
Intuitively, 
$\wei_{10}(q, a, \varepsilon, r)$ is the cost of 
the deletion of the symbol~$a \in \Sigma$ in~$s$, 
$\wei{01}(q, \varepsilon, b, r)$ is the cost 
of the insertion of~$b \in \Delta$ in $t$, 
and $\wei_{11}(q, a, b, r)$ is the cost 
of the substitution of  $a \in \Sigma$ by~$b \in \Delta$.
%
The cost of a sequence of such operations transforming $s$ into $t$, 
is the product, with $\otimes$, of the individual costs of the operations involved;
And the distance between $s$ and $t$ is the sum, with $\oplus$,
of all possible products.

\medskip\noindent
%Let $\< s, t> \in \Sigma^* \times \Delta^*$, with $s = s_1\ldots s_n$, and $t = t_1\ldots t_m$. 
Formally, the weight associated by $T$ to $\< s, t> \in \Sigma^* \times \Delta^*$ is: 
%defined as follows:
\begin{equation}
T(s, t)  = 
\displaystyle\bigoplus_{q, q' \in Q} \init(q) 
\mathop{\otimes} \weight_T(q, s, t, q') \mathop{\otimes} \final(q')
\label{eq:SWT-value}
\end{equation}

%\begin{example}
%We can define with a \SWT the computation of a similarity measure 
%between timed sequences
%similar to dynamic time warping (DTW).
%
%Let $\Semiring$  be the tropical (\emph{min-plus}) semiring of Figure~\ref{fig:semirings} and 
%let $\Sigma = \Delta = \mathbb{R}_+$ be sets of timestamps.
%We consider a \SWT with one state $q$ and transitions
%$\wei_{11}(q, d, d', q) = 
% \wei_{01}(q, d, d', q) = 
% \wei_{10}(q, d, d', q) = |d' - d|$,
%for all $d, d' \in \mathbb{R}_+$.
%% needs reading input/output symbols even by epsilon-transitions.
%The recursive definition of $\weight_T$ correspond to the dynamic programming equations of DTW
%for the computation of an optimal match between words, 
%the matching cost for two symbols being the 
%the time distance between them.
%\endex
%\end{example}

\begin{example}
In Common Western Music Notation~\cite{Gould11Notation}, 
several symbols may be used to represent a unique sounding event.
For instance, several notes can be combined with a tie, 
like in $\musQuarter\!\!\!\mathrel{\raisebox{-1.5mm}{$\smile$}}\!\!\!\musEighth$,  
and one note can be augmented by half its duration with a dot like in~\musQuarterDotted{}

\noindent 
We propose a small transducer model that compares an input sequence of sounding 
events (music "performance") 
to an output sequence of written events (music "score").
% simple pointwise distance between two sequences of timestamped events **
%
Let us consider the tropical (\emph{min-plus}) semiring~$\Semiring$ 
of Figure~\ref{fig:semirings} and 
let $\Sigma = \mathbb{R}_+$ be an input alphabet of event dates
and $\Delta = \{ \mathsf{e}, \mathsf{-} \} \times \mathbb{R}_+$ 
be an output alphabet of symbols with timestamps. 
A symbol $\< \mathsf{e}, d > \in \Delta$ represents an event starting at date $d$, 
and $\< \mathsf{-}, d >$ is a continuation of the previous event.
%More precisely, we let 
%$\Sigma = \{ a, - \} \times \R_+$ and 
%This example of $\Delta$ is motivated by the case of music notation, 
%where several notated events (notes) can be tied together, 
%with a \emph{tie} or a \emph{dot}
%meaning that they will be played as a unique sounding event.
%The timestamp of $a \in \Sigma$, denoted by $\mathsf{t}(a)$, is expressed as a rational number.

We consider a \SWT with two states $q_0$ and $q_1$ whose purpose 
is to compare a recorded performance $s \in \Sigma^*$
with notated music sheet $t \in \Delta^*$.
One timestamp $d_i \in \Sigma$ may corresponds 
to one notated event $\<\mathsf{e}, d'_i> \in \Sigma$, in which case 
the weight value computed by the \SWT is the time distance between both
(see transitions $\wei_{11}$ below).
%
If $\<\mathsf{e}, d'_i>$ is followed by continuations 
$\<\mathsf{-}, d'_{i+1}>$..., they are just skip with no cost (transitions $\wei_{01}$ or weight $\one$).
%transitions
\[
\begin{array}{rclcrcl}
\wei_{11}(q_0, d, \< \mathsf{e}, d'>, q_0) & = & |d' - d| & \quad &
\wei_{11}(q_1, d, \< \mathsf{e}, d'>, q_0) & = & |d' - d|\\
\wei_{01}(q_0, \varepsilon, \< \mathsf{-}, d'>, q_0) & = & \one & &
\wei_{01}(q_1, \varepsilon, \< \mathsf{-}, d'>, q_0) & = & \one\\
\wei_{10}(q_0, d, \varepsilon, q_1) & = & \alpha & & %\multicolumn{3}{l}{\mathrm{for~all~} b \in \Delta}
\end{array}
\]
%
Moreover, it may happen that the performers plays an extra note accidentally, but only once in a row. 
This is modelled by the transition $\wei_{10}$ with an arbitrary weight value $\alpha \in \Semiring$, 
switching from state $q_0$ (normal) to $q_1$ (error).
The transitions in the second column below switch back to the normal state $q_0$.
% the metric computed by the \SWT is the smallest sum of point wise distances 
% between dates of input and output events.
At last, we let $q_0$ be the only initial and final state, with
$\init(q_0) = \final(q_0) = \one$, and 
$\init(q_1) = \final(q_1) = \zero$. 
%$\init(q_0, d, b) = \final(q_0, d, b) = \one$, and 
%$\init(q_1, d, b) = \final(q_1, d, b) = \zero$, 
%for all $d \in \Sigma$ and $b \in \Delta$.
\endex
\end{example}

\noindent
The \emph{Symbolic Weighted Automata} %$A = \< Q, \init, \weight, \final >$
%over $\Sigma$,  $\Semiring$ and $\bar\Phi$
are defined similarly as the transducers of Definition~\ref{def:SWT}, 
by simply omitting the output symbols.
%
In this case, the label theory $\bar\Phi$ can be reduced to a singleton $\< \Phi_\Sigma>$.
%over $\Sigma$ is reduced to
%a set $\Phi_\Sigma$ closed under~$\oplus$ and~$\otimes$.
%
\begin{definition} \label{def:SWA}
A \emph{symbolic-weighted automaton} (\SWA)
over $\Sigma$, $\Semiring$ and $\bar\Phi$
%the input alphabet~$\Sigma$ and the commutative semiring $\Semiring$ 
is a tuple
$A = \< Q, \init, {\wei_1}, \final >$,
where $Q$ is a finite set of states, 
$\mathsf{in} : Q \to \Semiring$, %\Phi_\Sigma$, 
respectively $\mathsf{out} : Q \to \Semiring$  %\Phi_\Sigma,$
are functions defining the weight for entering, 
respectively leaving, computation in a state, 
and ${\wei_1}$ is a transition functions 
from $Q \times Q$ into~$\Phi_{\Sigma}$.
\end{definition}
%      
\noindent
As above in the case of \SWT, 
when $\wei_1(q, q') = \phi \in \Phi_\Sigma$, 
%respectively $\mathsf{in}(q) = \phi$, $\mathsf{out}(q') = \phi$,
we may write $\wei_1(q, a, q')$ for~$\phi(a)$. 
%respectively $\mathsf{in}(q, a) = \phi(a)$, $\mathsf{out}(q', a) = \phi(a)$.
%$\wei_1: Q \times \Sigma \times Q \to \Semiring$, 
The computation of $A$ on words $s \in \Sigma^*$
is defined with an intermediate function $\weight_A$, 
defined as follows for $q, q' \in Q$, $a \in \Sigma$, $u \in \Sigma^*$,
%
\begin{align}
\weight_A(q, \varepsilon, q) & = \one\\ %\final(q)\\
\weight_A(q, \varepsilon, q') & = \zero \quad \mathrm{if~} q \neq q'\nonumber\\
\weight_A(q, au, q') & =  \displaystyle\bigoplus_{q'' \in Q} 
    \wei_{1}(q, a, q'') \otimes \weight_A(q'', u, q')\nonumber
\label{eq:SWA-weight}
\end{align}
%
\noindent
and the weight value associated by $A$ to 
$s \in \Sigma^*$ is defined as follows: %$s = s_1\ldots s_n \in \Sigma^+$ 
\begin{equation}
A(s)  = 
\displaystyle\bigoplus_{q, q' \in Q} \init(q) 
\mathop{\otimes} \weight_A(q, s, q') \mathop{\otimes} \final(q') 
\label{eq:SWA-value}
\end{equation}


%
%When $\wei_\varepsilon(q, q') = \zero$ for all $q, q' \in Q$, 
%the automaton~$A$ is called \emph{without $\varepsilon$-transitions}.
      
%The \emph{summary} of a $\SWT$, resp. a $\SWA$, is ***
      
      
      
%\subsection{Properties}
\noindent
The following property will be useful to the approach on 
symbolic weighted parsing presented in Section~\ref{sec:parsing}.

\begin{proposition} \label{prop:epsilon}
Given a \SWT $T$ over $\Sigma$, $\Delta$, 
$\Semiring$ commutative, bounded and complete,
and $\bar\Phi$ effective,
and a $\SWTA$ $A$ over $\Sigma$, $\Semiring$ and $\bar\Phi$,
there exists an effectively constructible \SWA 
$B_{T, A}$ over $\Delta$, $\Semiring$ and $\bar\Phi$,
such that for all $t \in \Delta^*$, 
$B_{T, A}(t) = \displaystyle\bigoplus_{s\in \Sigma^*} A(s) \otimes T(s, t)$.
\end{proposition}
%
\begin{proof}
Let $T = \< Q, \init_T, \bar{\wei}, \final_T >$,
where $\bar{\wei}$ contains $\wei_{10}$, $\wei_{01}$, and $\wei_{11}$,
from $Q \times Q$ into respectively 
$\Phi_{\Sigma}$, $\Phi_{\Delta}$, and $\Phi_{\Sigma, \Delta}$,
and let $A = \< P, \init_A, \wei_1, \final_A >$
with $\wei_1: Q \times Q \to \Phi_{\Sigma}$.
%
\noindent
The state set of $B_{T, A}$ will be $Q' = P \times Q$.
The entering, leaving and transition functions of $B_{T, A}$ will 
simulate synchronized computations of $A$ and $T$, 
while reading an output word of $\Delta^*$.
%
Its state entering functions is defined 
for all $p \in P$, $q \in Q$ 
by $\init'(p, q) = \init_A(p) \otimes \init_T(q)$.
The transition function $\wei'_1$ will roughly perform 
a synchronized product of transitions defined by $\wei_1$, 
$\wei_{01}$ ($T$ reading in output word and not in input word)
and $\wei_{11}$ ($T$ reading in output word and input word).
%
Moreover, $\wei'_1$ also needs to simulate transitions 
defined by $\wei_{10}$: $T$ reading in intput word and not in output word.
Since $B_{T, A}$  will read only in the output word, such a transition corresponds
to an $\varepsilon$-transition of $\SWA$, 
but $\SWA$ have been defined without $\varepsilon$-transitions.
Therefore, in order to take care of this case, we perform an on-the-fly
suppression of $\varepsilon$-transition in the $\SWA$ in construction, 
following the algorithm of~\cite{LombardySakarovitch12ciaa}. 
%
% Initialize state leaving functions i
%and $\final'(p, q) = \final_A(p) \otimes \final_T(q)$. 

%Every transition of $B_{T, A}$ will
%simulate a sequence of transitions of $T$ performing the following steps:
%advance in the input word while staying immobile in the output word, 
%and then make one step in the output word (and advance in the input word or not).

\noindent
Initially, for all $p_1, p_2 \in P$, and $q_1, q_2 \in Q$, let
\[
\wei'_1\bigl( \< p_1, q_1>, \< p_2, q_2>\bigr) = 
\wei_1(p_1, p_2) \otimes
\bigl[
\wei_{01}(q_1, q_2) 
\oplus
\displaystyle\bigoplus_{\Sigma}
\wei_{11}(q_1, q_2) 
\bigr].
\]

\noindent
Iterate the following for all $p_1\in P$ and $q_1, q_2 \in Q$:
for all $p_2\in P$ and $q_3 \in Q$,
\[
\wei'_1\bigl( \< p_1, q_1>, \< p_2, q_3>\bigr) \opluseq 
\displaystyle\bigoplus_{\Sigma} \wei_{10}(q_1, q_2) 
\otimes 
\wei'_1\bigl( \< p_1, q_2>, \< p_2, q_3>\bigr)
\]
and
\[
\final'(p_1, q_1) \opluseq 
\displaystyle\bigoplus_{\Sigma} \wei_{10}(q_1, q_2) 
\otimes \final'(p_1, q_2)
\] 
\marginpar{\tiny proof correctness}
\qed
\end{proof}

%The complexity of construction
\noindent
The construction time and size for $B_{T, A}$ are $O(\| T \|^3 . \| A \|^2)$,
where the sizes $\| T \|$ and $\| A \|$ are their number of states.
%of~$T$ is its number of states $|Q|$.



\begin{corollary} \label{cor:epsilon}
Given a \SWT $T$ over $\Sigma$, $\Delta$, 
$\Semiring$ commutative, bounded and complete,
and $\bar\Phi$ effective,
and $s \in \Sigma^+$, 
there exists an effectively constructible \SWA 
$B_{T, s}$ over $\Delta$, $\Semiring$ and $\bar\Phi$,
such that for all $t \in \Delta^*$, $B_{T, s}(t) = T(s, t)$.
\end{corollary}


%\noindent
%The construction time and size for $B_{T, s}$ are $O(\| T \|^3 . | s |^2)$,
%where the size $\| T \|$ of~$T$ is its number of states $|Q|$.

 





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% SW-VPA
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{SW Visibly Pushdown Automata}
\label{section:SWVPA}\label{sec:SWVPA}
The model presented in this section generalizes Symbolic VPA~\cite{dAntonyAlur14SVPDA}
from Boolean semirings to arbitrary semiring weight domains.
It will compute on nested words over infinite alphabets, 
associating to every such word a weight value. 
Nest words are able to describe structures of labeled trees, 
and in the context of parsing, they will be useful to 
represent parse trees.



\subsection{Definition}\label{se:SWVPA-def}
Let $\Omega$ be a countable alphabet 
%finite (large) or infinite,
that we assume partitioned into three 
subsets~$\Omegai$, $\Omegac$, $\Omegac$,
whose elements are respectively called 
\emph{internal}, \emph{call} and \emph{return} symbols.
% names are  coined by application to functional program verification
% \begin{itemize}
% \item a set $\Omegai$ of \emph{internal symbols} denoted $a$,
% \item a set $\Omegac$ of \emph{call symbols} denoted $\call{a}$,
% \item a set $\Omegar$ of \emph{return symbols} denoted $\return{a}$.
% \end{itemize}
Let~$\< \Semiring, \oplus, \zero, \otimes, \one>$ be a commutative and complete semiring and let  
$\bar\Phi = \< \Phii, \Phic, \Phir, \Phici, \Phicc, \Phicr>$ 
be a label theory over $\Semiring$
%In order to simplify notations, %and following the definition of Section~\ref{section:transducer}, 
%we shall write respectively 
where $\Phii$, $\Phic$, $\Phir$ and~$\Phicx$ (with $\mathsf{x} \in \{ \mathsf{i}, \mathsf{c}, \mathsf{r}\}$) 
stand respectively 
for~$\Phi_\Omegai$, $\Phi_\Omegac$, $\Phi_\Omegar$ and~$\Phi_{\Omegac, \Omega_\mathsf{x}}$.
%
%Moreover, we extend this theory with a set $\Phii$ 
%of unary functions in $\Omegai \to \Semiring$,
%closed under $\oplus$ and $\otimes$.

\begin{definition}
A \emph{Symbolic Weighted Visibly Pushdown Automata} (\SWVPA) 
over  $\Omega = \Omegai \uplus \Omegac \uplus \Omegar$, $\Semiring$ and $\bar\Phi$ 
is a tuple $A = \< Q, P, \init, \bar\wei, \final >$,
where $Q$ is a finite set of states, 
$P$ is a finite set of stack symbols, 
$\mathsf{in} : Q \to \Semiring$, 
respectively $\mathsf{out} : Q \to \Semiring,$
are functions defining the weight for entering, 
respectively leaving, a state, 
and $\bar\wei$ is a sextuplet composed of the transition functions:
$\weii : Q \times P \times Q \to \Phici$,  
$\weiei : Q \times Q \to \Phii$,  
$\weic : Q \times P \times Q \times P \to \Phicc$,  
$\weiec : Q \times P \times Q \to \Phic$,  
$\weir : Q \times P \times Q \to \Phicr$,  
$\weier : Q \times Q \to \Phir$.
%and 
%$\weiex : Q \times Q \to \Phix$ 
%with $\mathsf{x} \in \{ \mathsf{i}, \mathsf{c}, \mathsf{r}\}$.
\end{definition}
%
Similarly as in Section~\ref{section:transducer}, 
we extend the above transition functions as follows
for all $q, q' \in Q$, $p \in P$, 
$a \in \Omegai$, 
$\call{c} \in \Omegac$, 
$\return{r} \in \Omegar$, 
overloading their names: % for simplicity:
\[
\begin{array}{lll}
\weii: Q \times \Omegac \times P \times \Omegai \times Q \to \Semiring & 
\weii(q, c, p, a, q') = \eta_\mathsf{ci}(c, a) & 
\mathrm{where~} \eta_\mathsf{ci} = \weii(q, p, q'),\\
%
\weiei: Q \times \Omegai \times Q \to \Semiring & 
\weiei(q, a, q') = \phi_\mathsf{i}(a) &
\mathrm{where~} \phi_\mathsf{i} = \weiei(q, q').\\[2pt]
%
\weic: Q \times \Omegac \times P \times  \Omegac \times P \times Q \to \Semiring & 
\weic(q, c, p, \call{c'}, p', q') = \eta_\mathsf{cc}(c, \call{c'}) & 
\mathrm{where~} \eta_\mathsf{cc} = \weic(q, p, p', q'),\\
%
\weiec: Q \times \Omegac \times P \times Q \to \Semiring & 
\weiec(q, {\call{c}}, p, q') = \phi_\mathsf{c}({\call{c}}) &
\mathrm{where~} \phi_\mathsf{c} = \weiec(q, p, q').\\[2pt]
%
\weir: Q \times \Omegac \times P \times \Omegar \times Q \to \Semiring & 
\weir(q, {\call{c}},  p, {\return{r}}, q') = \eta_\mathsf{cr}({\call{c}},  {\return{r}}) & 
\mathrm{where~} \eta_\mathsf{cr} = \weir(q, p, q'),\\
%
\weier: Q \times \Omegar \times Q \to \Semiring & 
\weier(q, {\return{r}}, q') = \phi_\mathsf{r}({\return{r}}) &
\mathrm{where~} \phi_\mathsf{r} = \weier(q, q').\\
\end{array}      
\]

\noindent
The intuition is the following for the above transitions.

\noindent
$\weii$ and $\weiei$ both read an input internal symbol $a$ and change state from $q$ to $q'$, 
without changing the stack. 
Moreover, $\weii$ reads a pair made of 
${\call{c}} \in \Omegac$ and $p \in P$ at the top of the stack 
($c$ is compared to $a$ by the weight function $\eta_\mathsf{ci} \in \Phici$)
and $\weiei$ applies if and only if the stack is empty.

\noindent
$\weic$ and $\weiec$ read the input call symbol $\call{c}'$, 
push it to the stack along with $p'$, and change state from $q$ to to $q'$.
Moreover, $\weic$ reads ${\call{c}}$ and $p$ at the top of the stack 
($c$ is compared to $c'$),
and $\weiec$ applies iff the stack is empty.

\noindent
$\weir$ and $\weier$ read the input return symbol $\return{r}$, and change state from $q$ to to $q'$.
Moreover, $\weir$ reads and pop from stack a pair made of $\call{c}$ and $p$, 
($\call{c}$ is compared to $\return{r}$),
and $\weier$ applies iff the stack is empty.
%In this case, the weight function $\phi_\mathsf{r}$ 
%computes a value of matching between the call and return symbols $c$ and $r$.
%This value might be set to $\zero$ in order to express that the symbols do not match.

Formally, the transitions of the automaton~$A$ are defined
in term of %a weight value computed by 
an intermediate function $\weight_A$, like in Section~\ref{sec:SWT}.
In the case of a pushdown automaton, a configuration, denoted by $q[\gamma]$ 
is composed of a state $q \in Q$ 
and a stack content $\gamma \in \Gamma^*$, 
where $\Gamma = \Omegac \times P$.
Hence, $\weight_A$ is a function from 
$[Q \times \Gamma^*] \times \Omega^* \times [Q \times \Gamma^*]$ into~$\Semiring$
(the empty stack is denoted by $\bot$). 
%
\begin{align}
%\begin{array}[t]{rcl}
\weight_A\bigl(\config{q}{\bot}, \varepsilon, \config{q}{\bot}) & = \one\label{eq:SWVPA-weight}\\
\weight_A\bigl(\config{q}{\bot}, \varepsilon, \config{q'}{\gamma}) & = \zero 
\mathrm{~if~} q \neq q'\nonumber\\
\weight_A\bigl(\configup{q}{\<{\call{c}}, p>\stackup\gamma}, a\, u, 
               \config{q'}{\gamma'}\bigr) & =  
 {\displaystyle\bigoplus_{q'' \in Q}} \weii(q, c, p, a, q'') 
  \otimes \weight_A\bigl(\configup{q''}{\<{\call{c}}, p> \stackup \gamma}, u, 
                         \config{q'}{\gamma'}\bigr)\nonumber\\
 %
\weight_A\bigl(\config{q}{\bot}, a\, u, 
               \config{q'}{\gamma'}\bigr) & =  
  {\displaystyle\bigoplus_{q'' \in Q}} \weiei(q, a, q'') 
   \otimes \weight_A\bigl(\config{q''}{\bot}, u, \config{q'}{\gamma'}\bigr)\nonumber\\
%
\weight_A\bigl(\configup{q}{\<{\call{c}}, p>\stackup\gamma}, {\call{c}'}\, u, 
               \config{q'}{\gamma'}\bigr) & =  
 {\displaystyle\bigoplus_{\begin{array}{c}
                          \scriptstyle q'' \in Q\\[-2pt]
                          \scriptstyle p' \in P
                          \end{array}}}
 \weic\bigl(q, {\call{c}}, p, {\call{c}'}, p', q''\bigr) 
 \otimes \weight_A\bigl(\configup{q''}{\<{\call{c}'}, p'>\stackup \<{\call{c}}, p>\stackup \gamma}, u, 
                        \config{q'}{\gamma'}\bigr)\nonumber\\[1mm]
%
\weight_A\bigl(\config{q}{\bot}, {\call{c}}\, u, 
               \config{q'}{\gamma'}\bigr) & =  
 {\displaystyle\bigoplus_{\begin{array}{c}
                          \scriptstyle q'' \in Q\\[-2pt]
                          \scriptstyle p \in P
                          \end{array}}}
  \weiec(q, {\call{c}}, p, q'') 
  \otimes \weight_A\bigl(\config{q''}{{\call{c}}\, p}, u, 
                         \config{q'}{\gamma'}\bigr)\nonumber\\
%
\weight_A\bigl(\configup{q}{\<{\call{c}}, p>\stackup \gamma}, {\return{r}}\, u, 
               \config{q'}{\gamma'}\bigr) & =  
 {\displaystyle\bigoplus_{q'' \in Q}} 
  \weir\bigl(q, {\call{c}}, p, {\return{r}}, q''\bigr) 
  \otimes \weight_A\bigl(\config{q''}{\gamma}, u, 
                         \config{q'}{\gamma'}\bigr)\nonumber\\
%
\weight_A\bigl(\config{q}{\bot}, {\return{r}}\, u, 
               \config{q'}{\gamma'}\bigr) & =  
 {\displaystyle\bigoplus_{q'' \in Q}} \weier(q, {\return{r}}, q'') 
  \otimes \weight_A\bigl(\config{q''}{\bot}, u, 
                         \config{q'}{\gamma'}\bigr)\nonumber
%\end{array}
\end{align}
%
% and ${\call{c}}\, p\stacksep \gamma$ 
%denotes a stack where the pair made of ${\call{c}} \in \Omegac$ and $p \in P$ is the top symbol 
%and $\gamma$ is the rest of stack.

\noindent
The weight associated by $A$ to $s \in \Omega^*$
is defined according to empty stack semantics: 
%
\begin{equation}
A(s)  = 
{\displaystyle\bigoplus_{q, q' \in Q}} \textstyle
\mathsf{in}(q) \mathop{\otimes} 
\weight_A\bigl(\config{q}{\bot}, s, \config{q'}{\bot}\bigr) 
\mathop{\otimes} \mathsf{out}(q').
\label{eq:weightA}
\end{equation}

\begin{example}
structured words with timed symbols...
intro language of music notation? (markup = time division, leaves = events etc)
\end{example}

\noindent 
Every $\SWA$ $A = \< Q, \init, {\wei_1}, \final >$,
over $\Sigma$, $\Semiring$ and $\bar\Phi$
is a particular case of $\SWVPA$ 
$\< Q, \emptyset, \init, \bar\wei, \final >$ 
over $\Omega$, $\Semiring$ and $\bar\Phi$
with $\Omegai = \Sigma$ and $\Omegac = \Omegar = \emptyset$,
and computing with an always empty stack:
$\weiei = \wei_1$ and all the other functions 
of~$\bar\wei$ are the constant~$\zero$.



\subsection{Properties}
Like VPA and symbolic VPA, 
the class of \SWVPA is closed under the binary operators of the underlying semiring.
%
\begin{proposition}\label{prop:SWVPA-product}
Let $A_1$ and $A_2$ be two \SWVPA
over the same $\Omega$, $\Semiring$ and $\bar\Phi$.
There exists two effectively constructible $\SWVPA$ 
$A_1 \oplus A_2$ and $A_1 \otimes A_2$,  
such that for all $s \in \Omega^*$, 
$(A_1 \oplus A_2)(s) = A_1(s) \oplus A_2(s)$ and 
$(A_1 \otimes A_2)(s) = A_1(s) \otimes A_2(s)$.
\end{proposition}
%
\begin{proof}
The construction is essentially the same 
as in the case of the Boolean semiring~\cite{dAntonyAlur14SVPDA}.
\end{proof}


\subsection{Best Search} 
\label{sec:best}\label{sec:search}
%**hypotheses**
Let us assume that the semiring~$\Semiring$ is
commutative, bounded, and complete,  
\marginpar{\tiny total?}
and assume an effective label theory.
%s.t. for all $\phi \in \Phii$, 
%$\psi \in \Phir$, 
%and $\eta \in \Phicr$, 
%$\displaystyle\bigoplus_{a \in \Omegai} \phi(a)$ 
%$\displaystyle\bigoplus_{r \in \Omegar} \phi(r)$ and 
%$\displaystyle\bigoplus_{{\call{c}} \in \Omegac} 
%\displaystyle\bigoplus_{{\return{r}} \in \Omegar} \eta({\call{c}}, {\return{r}})$
%are computable...
% 
% total ? 
% monotonic and superior writ natural ordering
%Regarding the infinite sum operator, note that
%$\bigoplus_{x \in \Phi_\Omega} \phi(x)$, 
%$\bigoplus_{y \in \Phi_\Delta} \psi(y)$, and  
%... exist and in $\Semiring$.
%
We propose a Dijkstra algorithm computing, for a $\SWVPA$ $A$
over~$\Omega$, $\Semiring$ and~$\bar\Phi$, 
the minimal weight %\wrt~$\leq_\oplus$, 
for a word in~$\Omega^*$.

\noindent
More precisely, 
let $b_\bot : Q \times Q \to \Semiring$ be the function:
%
\begin{equation}\label{eq:bbot}
  b_\bot(q, q') = \bigoplus_{s\in \Omega^*} 
  \textstyle
  \weight_A\bigl(\config{q}{\bot}, s, \config{q'}{\bot}\bigr)
\end{equation}
%
Since $\Semiring$ is complete, the infinite sum in \eqref{eq:bbot} is well defined,
and, roviding that $\Semiring$ is total, it is the minimum in $\Omega^*$,
\wrt~$\leq_\oplus$, % this ordering.
of the fonction 
$s \mapsto \weight_A(\config{q}{\sigma}, s, \config{q'}{\sigma})$.
%
The term $\config{q}{\bot}, s, \config{q'}{\bot}$ 
of this sum is the central expression in 
the definition \eqref{eq:weightA} of $A(s_0)$, for the minimum $s_0$
of the function $\weight_A$.

%
\noindent
Let $\top$ be a fresh stack symbol which does not belong to $\Gamma$,
and let $b_\top : Q \times P \times Q \to \Phic$ be such that,
for every two states $q, q' \in Q$ 
and stack symbol $p \in P$: %and $\sigma \in \{ \bot, \top \}$, 
\begin{equation}\label{eq:btop}
  b_\top(q, p, q') : c \mapsto \bigoplus_{s\in \Omega^*} 
  \textstyle
  \weight_A\bigl(\configup{q}{\< c, p> \stackup \top }, s, \configup{q'}{\<c, p> \stackup \top}\bigr). 
\end{equation}
%
Intuitively, the function defined in \eqref{eq:btop}
associateds to $c \in \Omegac$ 
the minimum weight of a computation of $A$
starting in state $q$ with a stack 
$c p \cdot \gamma \in \Gamma^+$ 
and ending in state $q'$ with the same stack,
such that the computation does pop 
the pair made of $c$ and $p$ at the top of this stack,
but may read these symbols.
Moreover, $A$ may push another pair $\< c', p'>$ %call symbols 
on the top of $c p \cdot \gamma$,
following the the third case of 
in the definition \eqref{eq:SWVPA-weight} of $\weight_A$,
and may pop $\< c', p'>$ later, following the fifth case of \eqref{eq:SWVPA-weight} (return symbol). 
%However, it cannot apply one of the two last cases (return symbol and empty stack)
%when the current stack is $\gamma$.
%pop symbols in $\gamma$.
% Note that having a stack reduced to such a symbol makes impossible the application of the 
% two last cases in the definition of $\weight_A$ (return symbol and empty stack). 
% However, it is possible to apply the two first cases 
% (internal symbol or call symbol, with a push on the top of $\top$).

Algorithm~\ref{algo:Dijkstra}
constructs iteratively markings 
$d_\bot : Q \times Q \to \Semiring$ and 
$d_\top : Q \times P \times Q \to \Phic$
%of the triplets $\<q, \sigma, q'>$ 
%of states of $A$ by weight values in $\Semiring$, 
that converges eventually to $b_\top$ and $b_\bot$.
%It uses for that purpose a priority queue $P$ containing triplets of 
%$Q \times \{ \bot, \top \} \times Q$.


\begin{algo}[best search for \SWVPA]\label{algo:Dijkstra}
\textbf{initially} 
let $\Q = (Q \times Q) \cup (Q \times P \times Q)$, %contains all 
and let 
$d_\bot(q_1, q_2) = d_\top(q_1, p, q_2) = \one$ if $q_1 = q_2$ and
$d_\bot(q_1, q_2) = d_\top(q_1, p, q_2) = \zero$ otherwise.

\smallskip\noindent
\textbf{while} $\Q$ is not empty

\noindent\quad
\textbf{extract} $\< q_1, q_2>$ or $\< q_1, p, q_2>$ from $\Q$ 

\noindent\quad
such that $d_\bot(q_1, q_2)$, resp. $\bigoplus_{c\in \Omegac} d_\top(q_1, p, q_2)(c)$,
is minimal in $\Semiring$ wrt $\leq_\oplus$.

\noindent\quad 
%\textbf{for all} $q_0, q_3 \in Q$ 
\textbf{update} $d_\bot$ with $\< q_1, q_2>$ or $d_\top$ with $\< q_1, p, q_2>$
(Figure~\ref{fig:best-update}).
\end{algo}



\begin{figure}
For all $q_0, q_3 \in Q$, %$p \in P$,
\[
\begin{array}{lcl}
%\multicolumn{3}{l}{\mathrm{For~all~} q_0, q_3 \in Q, p \in P,}\\
d_\top(q_1, p, q_3) & \opluseq &
  d_\top(q_1, p, q_2) \otimes 
  \displaystyle\bigoplus_{\Omegai} \weii(q_2, p, q_3)\\
%\multicolumn{3}{l}{\quad
%\mathrm{where~} \weii(q_2, p, q_3)_a \in \Phic
%\mathrm{~is~the~partial~application~}
%x_c \mapsto \weii(q_2, x_c, p, a, q_3)}\\
%
d_\bot(q_1, p, q_3) & \opluseq &
  d_\bot(q_1, q_2) \otimes 
  \displaystyle\bigoplus_{\Omegai} \weiei(q_2, q_3)\\
%     
d_\top(q_0, p, q_3) & \opluseq &
  {\displaystyle\bigoplus_{\Omegac}}^2 
  \bigl[ \bigl( \weic(q_0, p, p', q_1) \otimes_2 
  d_\top(q_1, p', q_2) \bigr) \otimes_2
  {\displaystyle\bigoplus_{\Omegar}} \weir(q_2, p', q_3) \bigr]\\
%\multicolumn{3}{l}{\quad
%\mathrm{where~} \weic(q_0, p, p', q_1)_{c'} \in \Phic
%\mathrm{~is~the~partial~application~}
%x_c \mapsto \weic(q_0, p, x_c, c', p', q_1)}\\[2pt]
%
d_\bot(q_0, q_3) & \opluseq &
  {\displaystyle\bigoplus_{\Omegac}}
  \bigl(
  \weiec(q_0, p, q_1) \otimes 
   d_\top(q_1, p, q_2) \otimes
  \displaystyle\bigoplus_{\Omegar} \weir(q_2, p, q_3)\bigr)\\
%
d_\bot(q_1, q_3) & \opluseq &
  d_\bot(q_1, q_2) \otimes 
  \displaystyle\bigoplus_{\Omegar} \weier(q_2, q_3)\\
%
d_\top(q_1, p, q_3) & \opluseq & 
  d_\top(q_1, p, q_2) \otimes d_\top(q_2, p, q_3), 
  \mathrm{if~} \< q_2, \top, q_3> \notin P \\
%
d_\bot(q_1, q_3) & \opluseq & 
  d_\bot(q_1, q_2) \otimes d_\bot(q_2, q_3), \mathrm{if~} \< q_2, \bot, q_3> \notin P \\
\end{array}
\]
%$\weii(q_2, p, q_3)_a \in \Phic$, for $a \in \Omegai$,
%is the partial application
%$x_c \mapsto \weii(q_2, x_c, p, a, q_3)$.
%
%$\weic(q_0, p, p', q_1)_{c'} \in \Phic$, for $c' \in \Omegac$,
%is the partial application
%$x_c \mapsto \weic(q_0, p, x_c, c', p', q_1)$.
\caption{Update $d_\bot$ with $\<q_1, q_2>$ or $d_\top$ with $\< q_1, p, q_2>$.} 
\label{fig:best-update}
\end{figure}


\noindent
The infinite sums in the updates of $d$ in Algorithm~\ref{algo:Dijkstra}, 
Figure~\ref{fig:best-update}
are well defined
since~$\Semiring$ is complete.
** effectively computable by hypothese that the label theory is effective**
The algorithm performs $2.|Q|^2$ iterations until $P$ is empty, 
and each iteration has a time complexity $O(|Q|^2 . |P|)$.
This gives a time complexity $O(|Q|^4 . |P|)$. 
It can be reduced by implementing $P$ as a priority queue, 
prioritized by the value returned by $d$
***complete***. %$|Q|^3.\log(|Q|^2)$

The correctness of Algorithm~\ref{algo:Dijkstra} 
is ensured by the invariant expressed in the following lemma.
\begin{lemma}\label{lem:bot}
For all $\< q_1, q_2> \notin \Q$,
$d_\bot(q_1, q_2) =  b_\bot(q_1, q_2)$/
\end{lemma}
The proof is by contradiction, 
assuming a counter-example minimal in the length of the witness word.

\begin{lemma}\label{lem:top}
For all $\< q_1, p, q_2> \notin \Q$, 
$d_\top(q_1, p, q_2) =  b_\top(q_1, p, q_2)$,
\end{lemma}

\noindent
For computing the minimal weight of a computation of $A$, we use the fact that,
at the termination of Algorithm~\ref{algo:Dijkstra}, %it holds that,
%There exist $q_1, q_2 \in Q$
\[
  {\displaystyle \bigoplus_{s \in \Omega^*} A(s)} = 
  {\displaystyle\bigoplus_{q, q' \in Q}} \textstyle
  \mathsf{in}(q) \mathop{\otimes} d_\bot(q, q') \mathop{\otimes} \mathsf{out}(q').
\]

%\medskip
\noindent
In order to obtain effectively a witness 
(word of $\Omega^*$ with a computation of $A$ of minimal weight), 
we require the additional property of convexity of weight functions.

\begin{proposition}\label{th:best-search}
For a \SWVPA $A$ 
over $\Omega$, 
$\Semiring$ commutative, bounded, total and complete, %semiring 
and $\bar\Phi$ effective and $k$-convex, % label theory,
one can construct in PTIME a word $s \in \Omega^*$ 
such that $A(s)$ is minimal \wrt the natural ordering for $\Semiring$. 
\end{proposition} 



\subsection{Nested-Words and Parse-Trees}
\label{sec:trees}
The hierarchical structure of nested-words, defined with the \emph{call} and \emph{return} markup symbols  
suggest a correspondence with trees. 
The lifting of this correspondence to languages, of tree automata and VPA,
has been discussed in~\cite{AlurMadhusudan09nested}, 
and~\cite{Caralp12VPAmult} for the weighted case.
In this section, we describe a correspondence between the symbolic-weighted extensions
of tree automata and VPA.

Let $\Omega$ be a countable ranked alphabet, such that 
every symbol $a \in \Omega$ has a rank 
$\rank(a) \in [0..M]$ where $M$ is a fixed natural number.
We denote by $\Omega_k$ the subset of all symbols $a$ of $\Omega$
with $\rank(a) = k$, where $0 \leq k \leq M$, 
and $\Omega_{>0} = \Omega \setminus \Omega_0$.
%
\noindent 
The free $\Omega$-algebra of finite, ordered, 
$\Omega$-labeled trees is denoted by $\T(\Omega)$.
It is the smallest set such that  $\Omega_0 \subset \T(\Omega)$
and for all $1 \leq k \leq M$, all $a \in \Omega_k$, 
and all $t_1, \ldots, t_k \in \T(\Omega)$, $a(t_1, \ldots, t_k) \in \T(\Omega)$.
%
% tree = single node (leave) labeled with a symbol of $a \in \Omegai$
% (such a tree is simply denoted by $a$)
% or the composition, denoted by $b(t_1,\ldots, t_n$) of a node labeled with $b$
% and $n$ subtrees $t_1$,\ldots, $t_n$.
%
Let us assume a commutative semiring~$\Semiring$ 
and a label theory~$\bar{\Phi}$ over~$\Semiring$ 
containing one set~$\Phi_{\Omega_k}$ for each $k \in [0..M]$.
%
\renewcommand{\call}[1]{\ensuremath \langle_{#1}}
\renewcommand{\return}[1]{\ensuremath {}_{#1}{\rangle}} % $\prescript{}{a}{)}$

% A \emph{regular tree grammar} over $\Omega$ 
% is a triplet $G = \< N, q_\mathsf{i}, R>$ where
% $N$ is a finite set of non-terminal symbols denoted $q$..., 
% $q_\mathsf{i} \in N$ is the starting non-terminal, 
% $R$ is a finite set of production rules of the form
% $q_0 \to a(q_1\ldots q_k)$ where 
% $q_0, q_1, \ldots, q_k \in N$
% $a \in \Omega_k$.
% A tree $t \in \T(\Omega)$ is in the language of $G$ 
% if it can be generated from $q_\mathsf{i}$ by 
% non terminal replacement following the rules of $R$.
%
\begin{definition}  \label{def:SWTA}
A \emph{symbolic-weighted tree automaton} (\SWTA)
over $\Omega$, $\Semiring$, and~$\bar\Phi$
is a triplet $A = \< Q, \init, \bar{\wei} >$ where
$Q$ is a finite set of states, 
$\mathsf{in} : Q \to \Phi_\Omega$ is the starting weight function, 
and $\bar{\wei}$ is a tuplet of transition functions containing, 
for each $k \in [0..M]$, 
%$\wei_\varepsilon$ from $Q \times Q$ into $\Semiring$, and, 
the functions $\wei_{k}: Q \times Q^{k} \to \Phi_{\Omega_{>0},\Omega_k}$
and $\weie[k]: Q \times Q^{k} \to \Phi_{\Omega_k}$.
\end{definition}
%
%Like in Section~\ref{sec:SWAdef}, 
We define %from $\bar{\wei}$ 
a transition 
function~$\wei: Q \times (\Omega_{> 0} \cup \{ \varepsilon \}) \times \Omega \times \bigcup_{k=0}^{M} Q^k 
  \to \Semiring$
by: %also called $\wei$ for simplicity, 
%such that, for all $q, q' \in Q$, $a \in \Sigma$, and $b \in \Delta$, 
\[
\begin{array}{rcll}
%\wei(q_0, \varepsilon, q_1) & = &  \wei_\varepsilon(q_0, q_1),\\ %\phi_\varepsilon\\
\wei(q_0, a, b, q_1 \ldots q_k) & = & \eta(a, b) &
\quad\mathrm{where~} \eta = \wei_{k}(q_0, q_1\ldots q_k)\\
\wei(q_0, \varepsilon, b, q_1 \ldots q_k) & = & \phi(b) &
\quad\mathrm{where~} \phi = \weie[k](q_0, q_1\ldots q_k).
\end{array}      
\]
%
\noindent
where $q_1\ldots q_k$ is $\varepsilon$ if $k = 0$.
The first case deals with a strict subtree, with a parent node labeled by $a$, 
and the second case is for a root tree.

\noindent
Every \SWTA %of Definition~\ref{def:SWTA} 
defines a mapping 
from trees of $\T(\Omega)$ into~$\Semiring$, %the weight values in~$\Semiring$,
based on the following intermediate function
$\weight_A: Q \times (\Omega \cup \{ \varepsilon \}) \times \T(\Omega) \to \Semiring$ 
\begin{equation}
%\begin{array}{rccl}
\weight_A(q_0, a, t) =  % & = &
%   \displaystyle\bigoplus_{q_1 \in Q} &
%   \wei(q, \varepsilon, q_1) \otimes \weight_A(q_1, t)\\
 \displaystyle\bigoplus_{q_1 \ldots q_k \in Q^k} % &
              \wei(q_0, a, b, q_1 \ldots q_k ) 
   \otimes \displaystyle\bigotimes_{i=1}^{k}
           \weight_A(q_i, b, t_i)
%\end{array}
\end{equation}
where $q_0 \in Q$, $a \in \Omega_{>0} \cup \{ \varepsilon \}$ and 
$t = b(t_1,\ldots, t_k) \in \T(\Omega)$,
$0 \leq k \leq M$.

\medskip\noindent
Finally, the weight associated by $A$ to  $t \in \T(\Omega)$ is 
\begin{equation}
A(t)  = 
\displaystyle\bigoplus_{q \in Q} \mathsf{in}(q) \mathop{\otimes} \weight_A(q, \varepsilon, t)
\label{eq:weightTA}
\end{equation}

\noindent
Intuitively, $\wei(q_0, a, b, q_1 \ldots q_k)$ can be seen as
the weight of a production rule $q_0 \to b(q_1, \ldots, q_k)$ 
of a regular tree grammar~\cite{tata}, 
that replaces the non-terminal symbol $q_0$ by $b(q_1, \ldots, q_k)$, 
provided that the parent of $q_0$ is labeled by $a$
(or $q_0$ is the root node if $a = \varepsilon$).
%in a step of tree building.
%
%Such a grammar computes the weights of the derivation trees 
%of the Context-Free grammar obtained by forgetting the labeling symbols of $\Omega_{>0}$.
The above production rule can also be seen as 
a rule of a weighted CF grammar, of the form
$[a, b]\, q_0 := q_1 \ldots q_k$ if $k > 0$,
and $[a]\, q_0 := b$ if $k = 0$. 
In the first case, $b$ is a label of the rule, 
and in the second case, it is a terminal symbol.
And in both cases, $a$ is a constraint on the label of rule applied 
on the parent node in the derivation tree.
This features of observing the parent's label  
are useful in the case of infinite alphabet, 
where it is not possible to memorize a label with the states.
%
%One can observe that 
\noindent The weight of a labeled derivation tree $t$
of the weighted CF grammar associated to~$A$ as above, 
is $\weight_A(q, t)$, 
when $q$ is the start non-terminal.
%
We shall now establish a correspondence between such derivation tree $t$
and some word describing a linearization of $t$, 
in a way that $\weight_A(q, t)$ can be computed by a $\SWVPA$.

Let $\hat\Omega$ be the countable (unranked) alphabet obtained
from $\Omega$ by: 
$\hat\Omega = \Omegai \uplus \Omegac \uplus \Omegar$, with
$\Omegai = \Omega_0$, 
$\Omegac = \{ \; \call{a} \mid a \in \Omega_{>0} \}$,
$\Omegar = \{ \; \return{a} \mid a \in \Omega_{>0} \}$.

\noindent
We associate to $\hat\Omega$
a label theory $\hat{\Phi}$ 
like in Section~\ref{se:SWVPA-def}, 
%
\noindent
and we define a linearization of trees of $\T(\Omega)$ into 
words of $\hat{\Omega}^*$ as follows:
\begin{description}
\item $\lin(a) = a$ for all $a \in \Omega_0$, 
\item $\lin\bigl( b(t_1, \ldots, t_k)\bigr) = 
       \call{b} \; \lin(t_1) \ldots \lin(t_k) \; \return{b}$ 
       when $b \in \Omega_k$ for $1 \leq k \leq M$.
\end{description}

\begin{proposition}\label{lem:SWTA}
For all \SWTA $A$ over~$\Omega$, $\Semiring$ commutative, and $\bar\Phi$,
there exists an effectively constructible \SWVPA $A'$ over 
$\hat\Omega$, $\Semiring$ and $\hat\Phi$ 
such that for all $t \in \T(\Omega)$, $A'\bigl(\lin(t)\bigr) = A(t)$.
\end{proposition} 
% 
\begin{proof}
Let $A = \< Q, \init, \bar{\wei} >$ where $\bar{\wei}$ is presented as above by a function
    %
We build 
$A' = \< Q', P', \init', \bar{\wei}', \final' >$,
%computing over $\hat\Omega = \Omegai \uplus \Omegac \uplus \Omegar$,
where $Q' = \bigcup_{k=0}^{M} Q^k$ is the set of sequences of state symbols of $A$, 
of length at most $M$, including the empty sequence denoted by~$\varepsilon$, 
and where $P' = Q'$ and $\bar\wei$ is defined by:

\[
\begin{array}{lcll}
\weii(q_0\, \bar{u}, {\call{c}}, \bar{p}, a, \bar{u}) & = & \wei(q_0, c, a, \varepsilon) & 
\mathrm{for~all~} c \in \Omega_{>0}, a \in \Omega_0\\ %\bar{p}\in P', 
%
\weiei(q_0\,\bar{u}, a, \bar{u}) & = & \wei(q_0, \varepsilon, a, \varepsilon) & 
\mathrm{for~all~} a \in \Omega_0\\
%
\weic(q_0\,\bar{u}, {\call{c}}, \bar{p}, \call{d}, \bar{u}, \bar{q}) & = & \wei(q_0, c, d, \bar{q}) &  
\mathrm{for~all~} c, d \in \Omega_{>0}\\ % \bar{p}\in P'
%
\weiec(q_0\,\bar{u}, \call{c}, \bar{u}, \bar{q}) & = & \wei(q_0, \varepsilon, c, \bar{q}) & 
\mathrm{for~all~} c \in \Omega_{>0}\\
%
%\weir: Q \times \Omegac \times P \times \Sigmar \times Q \to \Semiring & 
\weir(\varepsilon, {\call{c}}, \bar{p}, {\return{c}}, \bar{p}) & = & \one & 
\mathrm{for~all~}  c \in \Omega_{>0}\\ % \bar{p}\in P'
%
%\weie: Q \times \Omegar \times Q \to \Semiring & 
\weier(\bar{u}, {\return{c}}, \bar{q}) & = & \zero &
\mathrm{for~all~}  c \in \Omega_{>0}
\end{array}      
\]
\noindent
All cases not matched by one of the above equations have a weight $\zero$, 
for instance  %This is in particular the case of
$\weir(\bar{u}, {\call{c}}, \bar{p}, {\return{d}}, \bar{q}) = \zero$
if $c \neq d$
or $\bar{u} \neq \varepsilon$
or $\bar{q} \neq \bar{p}$.
%
%\noindent
%It is sufficient to consider in $Q'$ only the prefixes of 
%sequences in transition with a non-null weight.
\qed
\end{proof}


\section{Symbolic Weighted Parsing}
\label{sec:parsing}
Let us now apply the models and results of the previous sections %in order to define 
to the problem of parsing over infinite alphabet. %appropriate
%
%\subsection{Definition}
%
Let~$\Sigma$ be a countable input alphabet 
and~$\Omega$ be a countable output ranked alphabet, 
with maximal rank value~$M$, 
and let $\hat\Omega = \Omegai \uplus \Omegac \uplus \Omegar$
be the alphabet with nesting symbols associated to $\Omega$ like in Section~\ref{sec:trees},
for the linearization of trees of $\T(\Omega)$.
%(remember that $\Omegai = \Omega_0$).
%
Let $\< \Semiring, \oplus, \zero, \otimes, \one>$ be a 
commutative, bounded, and complete \marginpar{\tiny total?} semiring  
and let $\bar\Phi$ be an effective label theory over $\Semiring$,
containing $\Phi_\Sigma$, $\Phi_{\Sigma, \Omegai}$, as well as
$\Phii$, $\Phic$, $\Phir$, $\Phicr$
(following the notations of Section~\ref{se:SWVPA-def}).
%It is moreover assumed computable and $k$-convex for some fixed~$k$.
%
\noindent
We assume given the following input:
\begin{description}
\item[--] a \SWT $T$ over $\Sigma$, $\Omegai$, $\Semiring$, and $\bar\Phi$, 
defining a measure %between words 
$T: \Sigma^* \times \Omegai^* \to \Semiring$,

\item[--] a \SWTA $A$ over $\Omega$, $\Semiring$, and $\bar\Phi$,
defining a measure $A: \T(\Omega) \to \Semiring$,
%a \SWVPA $A$ over $\Omega$, and $\Semiring$, defining a series of nested words
%      $A : \Omega^* \to \Semiring$,
\item[--] an input word $s \in \Sigma^*$.
\end{description}
%
As explained in Section~\ref{sec:trees}, 
$A = \< Q, \init, \bar{\wei} >$ can be seen as a weighted regular tree grammar, 
or a labeled weighted CF grammar whose derivation trees are in $\T(\Omega)$, 
with weight defined by $A$.
The purpose of the transducer $T$ is to measure a distance between input and output words, 
\ie between the word $s$ and the sequence leaves of a derivation tree, in $\Omegai^*$.
%that generates (weighted) trees by replacement of a state symbol~$q_0$ (non-terminal), 
%by a tree $a(q_1,\ldots, q_k)$, where $k = \rank(a)$.
%A replacement rule $q_0 \to a(q_1,\ldots, q_k)$, 
%of weight $\wei(q_0, a, q_1 \ldots q_k) \in \Semiring$ 
%according to Definition~\ref{def:SWTA}, 
%corresponds to the production rule $q_0 := a(q_1,\ldots, q_k)$ of a weighted CF grammar,
%with set non-terminal symbols $Q$ and set of terminal symbols $\Omega_0$.
%
%This actually is a slight generalization of CFG since 
%each such production rule is labelled by  a symbol of $\Omega_{>0}$, 
%hence parse trees %derivation trees
%are trees of $\T(\Omega)$.
%
%Another (more original) generalization is that the set of terminal symbols 
%$\Omega_0$ may be infinite.

\noindent 
We extend the measure defined by $T$ to 
$d : \Sigma^* \times \T(\Omega) \to \Semiring$ as follows.
Given a word $w \in {\hat\Omega}^*$, the projection of $w$ onto $\Omegai$,
denoted $w|_\Omegai$,
is the word of $\Omegai^*$ obtained from $w$ by removing all symbols 
in $\hat\Omega \setminus \Omegai$.
Using this notation
and the tree linearization operator defined in Section~\ref{sec:trees}, 
$d$ is defined by:
\begin{equation}
d(s, t) = T\bigl(s, \lin(t)|_\Omegai \bigr)  \mathrm{~for~} s \in \Sigma^*, t\in \T(\Omega)
\end{equation}

\noindent 
\emph{Symbolic weighted parsing} is the problem, 
given the above input, 
to find a tree $t \in \T(\Omega)$ %nested word $t \in \Omega$ 
minimizing \( d(s, t) \otimes A(t)\)
\wrt $\leq_\oplus$, 
\ie such that: %Hence, it is the problem of finding 
%
\begin{equation}\label{eq:distance-lang}
d(s, t) \otimes A(t) = \displaystyle\bigoplus_{t' \in \T(\Omega)} d(s, t') \otimes A(t') 
\end{equation}
%
The measure expressed in~\eqref{eq:distance-lang} is called
called the edit-distance between~$s$ and~$A$ in~\cite{Mohri03EDWA}.
%
%The input language can also be expressed as a \SWTA, or, 
%as a particular case, as a weighted context-free grammar, 
%converted in turn into a \SWVPA following Lemma~\ref{lem:SWTA}.
%
The problem of searching, in a WTA language, 
the best parse tree matching a given input,  
sometimes referred as~\emph{weighted parsing},
corresponds to SW parsing in the case of finite alphabets
and when the transducer $T$ characterizes identity
see \eg~\cite{Goodman99SemiringParsing} 
and~\cite{MorbitzVogler19weighted-parsing} for a more general 
weighted parsing framework.
%
%Indeed, it corresponds to the case where $T$
%accepts only the pairs $\<s, t>$ such that 
%$s$ is the projection of $t$ on $\Omegai$. 
%This can be done with a single state $q$ and 
%with transition rules of the form:
%\begin{description}
%\item[] $\wei(q, \varepsilon, a, q) = \one$ for all $a \in \Omegac \cup \Omegar$,
%\item[] $\wei(q, a, a, q) = \one$ for all $a \in \Omegai$,
%\item[] $\wei(q, a, b, q) = \zero$ for all $a, b \in \Omegai$, $a \neq b$.
%\end{description}


%\subsection{Computation}
%
\begin{proposition}
The problem of Symbolic Weighted  parsing 
can be solved in PTIME in the size of the input \SWT $T$, \SWTA $A$ %\SWVPA (or ) 
and input word $s$, 
and the computation time of the functions of the label theory.
\end{proposition}
\begin{proof} (sketch)
We follow a \emph{Bar-Hillel} construction, also called parsing by intersection.

\noindent
We first extend the \SWT $T$ over $\Sigma$, $\Omegai$, $\Semiring$, and $\bar\Phi$, 
into a \SWT $T'$ over $\Sigma$ and $\hat\Omega$ (and the same semiring and label theory),
such that for all $s \in \Sigma^*$, and $u \in {\hat\Omega}^*$, 
$T'(s, u) = T(s, u|_{\Omegai})$. The transducer $T'$ simply skips every symbol 
$b \in {\hat\Omega} \setminus \Omegai$, 
by the addition to the transition of $T$,
of new transitions of the form $\wei_{01}(q, \varepsilon, b, q')$.

\noindent
Then, given an input word $s \in \Sigma^*$, 
we compute the \SWA $A_{T', s}$, using Proposition~\ref{prop:epsilon}.
This automaton is such that for all $t \in \T(\Omega)$, 
\[ 
   A_{T', s}\bigl(\lin(t)\bigr) 
 = T'\bigl(s, \lin(t)\bigr) 
 = T'\bigl(s, \lin(t)|_{\Omegai}\bigr) 
 = d(s, t).
\]

\noindent
Next, we convert the input \SWTA $A$ over $\Omega$
into a \SWVPA $A'$ over $\hat\Omega$, using Lemma~\ref{lem:SWTA}, 
and we compute the \SWVPA $A_{T', s} \otimes A'$, 
using Proposition~\ref{prop:SWVPA-product}.

\noindent
It remains to compute a best nested-word $w \in {\hat\Omega}^*$ 
using the best-search procedure of Proposition~\ref{th:best-search},
and convert it into a best tree in $\T(\Omega)$ in order to solve SW parsing
for~$T$, $A$ and~$s$.
\qed  
\end{proof}

\paragraph{Application to Automated Music Transcription.}
%\input{transcription}
...



\section*{Conclusion}
% summary 
We have introduced weighted language models (SW transducers and visibly pushdown automata)
computing over infinite alphabets, 
and applied them to the problem of parsing 
with infinitely many possible input symbols (typically timed events).
%handled with suitable language formalisms, 
%
This approach extends conventional parsing and weighted parsing
by computing a derivation tree modulo 
a generic distance between words,  
defined by a SW transducer given in input.
This enables to consider finer word relationships than strict equality, 
%as in the conventional parsing approach, 
opening possibilities of quantitative analysis via this method.

% discussion
\noindent
Ongoing and future work include 

\noindent
-- The study of other theoretical properties of SW models, 
such as the extension of the best search algorithm from $1$-best to $n$-best~\cite{Huang05kbest}, 
and to $k$-\emph{closed} semirings~\cite{Mohri02semiring}
(instead of \emph{bounded}, which corresponds to $0$-\emph{closed}).

\noindent
-- ...there is room to improve the complexity bounds for the algorithms
... modular approach with oracles ...

\noindent
-- present here an offline algorithm for best search, 
semi-online implementation for AMT (bar-by-bar approach)
with an on-the-fly automata construction.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% BIBLIO                                                                     %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\bibliographystyle{plain}
%\bibliographystyle{plainurl} 
\bibliographystyle{abbrv}
%\bibliographystyle{splncs04}
%\bibliographystyle{eptcs}
%\bibliography{generic}

\bibliography{references}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% APPENDIX                                                                   %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\appendix 




\end{document}



\section{Edit-Distance}

%\subsection{Distance between words or languages}
...algebraic definition of edit-distance of Mohri, in \cite{Mohri03EDWA}
% Mehryar Mohri 
% Edit-distance of weighted automata: General definitions and algorithms
% International Journal of Foundations of Computer Science 14.06 (2003): 957-982.
distance $d$ over $\Sigma^* \times \Sigma^*$ 
into a semiring  $\Semiring = ( \Semiring, \oplus, \zero, \otimes, \one)$.

%\noindent
Let $\Omega = \Sigma \cup \{ \varepsilon \} \times \Sigma \cup \{ \varepsilon \} \setminus \{ (\varepsilon, \varepsilon) \}$,
and let $h$ be the morphism from $\Omega^*$ into $\Sigma^* \times \Sigma^*$  
defined over the concatenation of strings of $\Sigma^*$ (that removes the $\varepsilon$'s).
%
\noindent
An \emph{alignment} between 2 strings  $s, t \in \Sigma^*$ is an element $\omega \in \Omega^*$ 
such that $h(\omega) = (s, t)$.
%
\noindent
We assume a base cost function $\Omega$ : $\delta: \Omega \to S$, extended to $\Omega^*$ as follows  
(for $\omega \in \Omega^*$): 
\(
\displaystyle\delta(\omega) = \bigotimes_{0 \leq i < |\omega|} \delta(\omega_i)
\).

\noindent
\begin{definition}
For  $s, t \in \Sigma^*$, the edit-distance between $s$ and $t$ is  
\( 
d(s, t) = \displaystyle\bigoplus_{\omega \in \Omega^*\, h(\omega) = (s, t)} \delta(\omega)
\).
\end{definition}

e.g. Levenstein edit-distance: $S$ is min-plus and $\delta(a, b) = 1$ for all $(a, b) \in \Omega$.


%\paragraph{Distance between a word and a regular language}
