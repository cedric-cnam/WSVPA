
% SWT without epsilon-transitions
% SWT do not read the other tape in "skip" transitions 10 or 01
%     (hence this version is simpler  than V2)
% SWA without epsilon-transitions
% SW-VPA read top of stack (when not empty) at every transition
%        (6 kinds of transitions).

% default style article.cls
%\input{main-article}

% Springer llncs style
% https://www.springer.com/gp/computer-science/lncs/conference-proceedings-guidelines
%\input{main-llncs}

% EPTCS style
% http://www.eptcs.org
%\input{main-eptcs}

% LIPICS v.2021 style
% https://submission.dagstuhl.de/documentation/authors
\input{main-lipics}


% comments in margin with \todo command
\usepackage[colorinlistoftodos]{todonotes} % option disable to hide todos
% command todo : options
% - noline: no line connecting the note with the place in the text where the note occurs in the latex code
% - fancyline : curved arrow from note to inssertion point
% - inline: place a todonote inside the text instead of in the margin
% - author=name
\newcommand{\florent}[1]{\todo[noline,size=\tiny,color=yellow!40]{#1}}
\newcommand{\lydia}[1]{\todo[noline,size=\tiny,color=red!30]{#1}}
\newcommand{\philippe}[1]{\todo[noline,size=\tiny,color=green!30]{#1}}

\usepackage{hyperref}
%\usepackage[bookmarks,bookmarksnumbered,naturalnames,plainpages=false]{hyperref}
%usepackage{url}

% for footnote ref
\usepackage{refcount}

% array and tabular
\usepackage{array}
\newcolumntype{C}[1]{>{\centering\arraybackslash\hspace{0pt}}p{#1}}

% extension of enumerate env. (style for displaying counters)
% \usepackage{enumerate}

%% pictures
% \usepackage{graphicx}
% \DeclareGraphicsExtensions{.pdf,.png,.jpg}
% \graphicspath{fig/}

%% PGF, Tikz
\usepackage{tikz-cd}
%% \usepackage{pgfplots}
%% \usepgfplotslibrary{dateplot}
%% \usepackage{pgf,pgfarrows,pgfnodes, pgfautomata}
% \usepackage{tikz}
% \usetikzlibrary{cd}
%% \usetikzlibrary{arrows}
%% \usetikzlibrary{calc}
%% \usetikzlibrary{snakes}
%% \usetikzlibrary{backgrounds}
% \usetikzlibrary{trees}
%% \usetikzlibrary{automata}
%% \usetikzlibrary{positioning}
%% \usetikzlibrary{matrix}
%% \usetikzlibrary{patterns}
%% \usetikzlibrary{shapes}

% symbols
\usepackage{amsmath}
\allowdisplaybreaks
\usepackage{amssymb}
\usepackage{amsbsy}
\usepackage{bbold}
\usepackage{latexsym}
%\usepackage{amsfonts}
\usepackage{stmaryrd}
%\usepackage{mathabx}
%\usepackage{MnSymbol}
\usepackage{harmony} % simple music fonts
\usepackage{mathtools} % for arrows
%\usepackage{mathptmx}
\usepackage{comment}

%% algorithms
%\usepackage{algorithm}
%\usepackage{program}
\usepackage[ruled,vlined]{algorithm2e}


%% allows for page break within arrays
\usepackage{longtable}

%% arrows etc
%\input{rewriting}

%% music symbols
% see http://tug.ctan.org/info/latex4musicians/latex4musicians.pdf
\usepackage{musicography}

%% for new macros
\usepackage{xspace}

%% Misc macros
\def\ie{\textit{i.e.}\xspace}
\def\eg{\textit{e.g.}\xspace}
\def\wrt{\textit{wrt}\xspace}
%\def\wlog{\textit{wlog}\xspace}
\def\etc{\textit{etc}\xspace}

\def\<#1>{\langle #1 \rangle}
\newcommand{\pair}[2]{\langle{#1}, {#2}\rangle}

%\newcommand{\config}[2]{\ensuremath \genfrac{[}{]}{0pt}{}{#1}{#2}}
\newcommand{\config}[2]{\ensuremath{#1}[{#2}]}
\newcommand{\configup}[2]{\ensuremath{#1}\left[\begin{array}{c} #2 \end{array}\right]}
\def\stacksep{\cdot}
\def\stackup{\\}

\newcommand{\opluseq}{\ensuremath\mathrel{\oplus}=}

% \bigominus
\DeclareFontFamily{U}{mathx}{\hyphenchar\font45}
\DeclareFontShape{U}{mathx}{m}{n}{
<-6> mathx5 <6-7> mathx6 <7-8> matha7
<8-9> mathx8 <9-10> mathx9
<10-12> mathx10 <12-> mathx12
}{}
\DeclareSymbolFont{mathx}{U}{mathx}{m}{n}
\DeclareMathSymbol{\bigominus}{\mathop}{mathx}{"C1}

\newcommand{\A}{\mathcal{A}} % automata, VPA
\newcommand{\B}{\mathcal{B}} % automata (in constructions)
\newcommand{\C}{\mathcal{C}} % automata (in constructions)
\newcommand{\D}{\mathcal{D}}  % transducer = distance
\newcommand{\E}{\mathbb{E}}
%\newcommand{\P}{\mathcal{P}}
\newcommand{\Q}{\mathcal{Q}}
\newcommand{\R}{\mathcal{R}}
\newcommand{\T}{\mathcal{T}}
\newcommand{\W}{\mathbb{W}}
\newcommand{\Semiring}{\mathbb{S}}
\newcommand{\zero}{\mathbb{0}}
\newcommand{\one}{\mathbb{1}}
\newcommand{\dom}{\ensuremath{\mathit{dom}}}

\def\SA{\textsf{sA}\xspace}
\def\WA{\textsf{wA}\xspace}
\def\SW{\textsf{sw}\xspace}
\def\swM{\textsf{swM}\xspace}
\def\SWT{\textsf{swT}\xspace}
\def\SWA{\textsf{swA}\xspace}
\def\SWTA{\textsf{swTA}\xspace}
\def\SWVPA{\textsf{sw-VPA}\xspace}
\def\VPA{\textsf{VPA}\xspace}
\def\SVPA{\textsf{sVPA}\xspace}
\def\weight{\mathsf{weight}}
\def\wei{\mathsf{w}}
\def\mei{\mathsf{m}}
\def\init{\mathsf{in}}
\def\final{\mathsf{out}}
\def\Omegai{{\Omega_\mathsf{i}}}
\def\Omegac{{\Omega_\mathsf{c}}}
\def\Omegar{{\Omega_\mathsf{r}}}
\def\Sigmai{{\Sigma_\mathsf{i}}}
\def\Sigmac{{\Sigma_\mathsf{c}}}
\def\Sigmar{{\Sigma_\mathsf{r}}}
\def\Deltai{{\Delta_\mathsf{i}}}
\def\Deltac{{\Delta_\mathsf{c}}}
\def\Deltar{{\Delta_\mathsf{r}}}
\def\Phii{{\Phi_\mathsf{i}}}
\def\Phic{{\Phi_\mathsf{c}}}
\def\Phir{{\Phi_\mathsf{r}}}
\def\Phix{{\Phi_\mathsf{x}}}
\def\Phici{{\Phi_\mathsf{ci}}}
\def\Phicc{{\Phi_\mathsf{cc}}}
\def\Phicr{{\Phi_\mathsf{cr}}}
\def\Phicx{{\Phi_\mathsf{cx}}}
\def\weii{{\wei_\mathsf{i}}}
\def\weic{{\wei_\mathsf{c}}}
\def\weir{{\wei_\mathsf{r}}}
\newcommand{\weie[1]}{\wei_{#1}^\mathsf{e}}
\def\weiei{\weie[\mathsf{i}]}
\def\weiec{\weie[\mathsf{c}]}
\def\weier{\weie[\mathsf{r}]}
\def\weiex{\weie[\mathsf{x}]}
\newcommand{\ioi}[1]{\mathsf{ioi}({#1})}
\newcommand{\rank}{\mathsf{rk}}
\newcommand{\lin}{\mathsf{lin}}

\newcommand{\call}[1]{\ensuremath #1} %{\ensuremath \langle_{#1}}
\newcommand{\return}[1]{\ensuremath #1} %{\ensuremath {}_{#1}{\rangle}} % $\prescript{}{a}{)}$
\newcommand{\ccall}[1]{\ensuremath \langle_{#1}}
\newcommand{\creturn}[1]{\ensuremath {}_{#1}{\rangle}} % $\prescript{}{a}{)}$


%\sloppy

% Parsing over infinite alphabet as optimal alignment computation
% as edit-distance between string and language
%
%\title{Symbolic Weighted Parsing and Automated Music Transcription}
%\title{Symbolic Weighted Language Models and Automated Music Transcription}
\title{Symbolic Weighted Language Models and\\ Quantitative Parsing over Infinite Alphabets}
%\title{Weighted Visibly Pushdown Automata and Automated Music Transcription}
%\titlerunning{WVPA \& AMT}
%\titlerunning{Symbolic Weighted Parsing} % and Automated Music Transcription
%\authorrunning{Florent Jacquemard}

\date{\today}

\begin{document}
\thispagestyle{empty}
\maketitle

\begin{abstract}
\input{abstract}
\end{abstract}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% intro
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\florent{indep. counters Def. Prop. Ex...}

\section{Introduction} \label{sec:intro}
\input{introduction}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% prelin
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Preliminary Notions}
\label{section:prelim}\label{sec:prelim}

%notations: for set $S$ : sets of sequences $S^*$ and $S^+$...
%interval $[i..j]$ of natural numbers

\paragraph*{Semirings}
\label{section:semiring}\label{sec:semiring}
\input{semiring}

\paragraph*{Label Theory}
\label{section:symbols}
\input{labels}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% SWT & SWA
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{SW Automata and Transducers}
\label{section:transducer}\label{sec:transducer}
\label{section:SWA}\label{sec:SWA}
\label{section:SWT}\label{sec:SWT}

We follow the approach of~\cite{Mohri03EDWA} for the computation of distances,
between words and languages, using weighted transducers,
and extend it to infinite alphabets.
% with models of symbolic weighted automata and transducers.
%
The models introduced in this section generalize
weighted automata and transducers~\cite{Droste09handbook}
%over finite alphabets, see  e.g.~\cite{Mohri03EDWA},
by labeling each transition with a weight function (instead of a simple weight value),
that takes the input and output symbols as parameters.
These functions are similar to the guards of symbolic automata~\cite{dAntoniVeanes17CAV,dAntoni21CACM},
but the latter guards are restricted to the Boolean semiring.
%

%\subsection{Definitions} \label{sec:SWTdef}\label{sec:SWAdef}
%(SWT)
\noindent
Let $\Semiring$ be a commutative semiring,
$\Sigma$ and $\Delta$ be alphabets called respectively \emph{input} and \emph{output}, %{alphabets},
and $\bar\Phi$ be a label theory over $\Semiring$
containing $\Phi_\Sigma$, $\Phi_\Delta$, $\Phi_{\Sigma, \Delta}$.

\begin{definition}
\label{def:transducer} \label{def:SWT}
A \emph{symbolic-weighted transducer} (\SWT)
over $\Sigma$, $\Delta$, $\Semiring$ and $\bar\Phi$
%the input and output alphabets~$\Sigma$ and $\Delta$ with label theory $\bar\Phi$, and the semiring $\Semiring$
is a tuple
$T = \< Q, \init, \bar{\wei}, \final >$,
where $Q$ is a finite set of states,
$\mathsf{in} : Q \to \Semiring$   %\Phi_{\Sigma, \Delta}
(respectively $\mathsf{out} : Q \to \Semiring$)  %\Phi_{\Sigma, \Delta}
are functions defining the weight for entering
(respectively leaving) computation in a state,
and $\bar{\wei}$ is a triplet of transition functions
$\wei_{10}: Q \times Q \to \Phi_{\Sigma}$,
$\wei_{01}: Q \times Q \to \Phi_{\Delta}$, and
$\wei_{11}: Q \times Q \to \Phi_{\Sigma, \Delta}$.
\end{definition}
%
\noindent
We call \emph{number of transitions} of $T$ the number of pairs of states
$q, q' \in Q$ such that $\wei_{10}$ or $\wei_{01}$ or $\wei_{11}$
is not the constant $\zero$.
%
\noindent
For convenience, we shall sometimes present transitions
as functions of
$Q \times (\Sigma \cup \{ \varepsilon \}) \times (\Delta \cup \{ \varepsilon \}) \times Q \to \Semiring$,
overloading the function names,
such that, for all $q, q' \in Q$, $a \in \Sigma$,  $b \in \Delta$:
\[
\begin{array}{rcll}
\wei_{10}(q, a, \varepsilon, q') & = & \phi(a) & %\wei_\Sigma(q, q')(a)
\quad\mathrm{where~} \phi = \wei_{10}(q, q') \in \Phi_\Sigma,\\
\wei_{01}(q, \varepsilon, b, q') & = & \psi(b) &
\quad\mathrm{where~} \psi = \wei_{01}(q, q') \in \Phi_\Delta,\\
\wei_{11}(q, a, b, q') & = & \eta(a, b) &
\quad\mathrm{where~} \eta = \wei_{11}(q, q') \in \Phi_{\Sigma, \Delta}.\\
\end{array}
\]
%
\noindent
% The symbolic-weighted transducer
The \SWT $T$ computes on pairs of words $\< s, t> \in \Sigma^* \times \Delta^*$,
$s$ and $t$, being respectively called \emph{input} and \emph{output} word.
\florent{It compute asynchronously: advance in $s$ and not in $t$ ($\wei_{10}$),
or the opposite ($\wei_{01}$),
or advance in both $s$ and $t$ ($\wei_{11}$).}
% \noindent
More precisely, $T$ defines a mapping
from $\Sigma^* \times \Delta^*$ into~$\Semiring$,
based on an intermediate function $\weight_T$
defined recursively, for every states $q, q' \in Q$,
and every pairs of strings $\< s, t> \in \Sigma^* \times \Delta^*$,
% \setminus \{ \< \varepsilon, \varepsilon >\}$,
where $au$, and $bv$, denote the concatenation
of the symbol $a \in \Sigma$ (resp. $b \in \Delta$)
with a word $u \in \Sigma^*$ (resp. $v \in \Delta^*$).
\lydia{added $u$ and $v$ def}
%
%$a \in \Sigma$, $u \in \Sigma^*$, $b\in \Delta$, $v\in \Delta^*$, by:
%
\begin{align}
%\weight_T(q, \varepsilon, \varepsilon, q)  & = \one \label{eq:SWT-weight}\\ %\final(q)\\
%\weight_T(q, \varepsilon, \varepsilon, q') & = \zero \quad \mathrm{if~} q \neq q'\nonumber\\
\weight_T(q, \varepsilon, \varepsilon, q')  & = \one
 \quad \mathrm{if~} q = q' \mathrm{~and~} \zero \mathrm{~otherwise} \label{eq:SWT-weight}\\
\weight_T(q, s, t, q') & = \displaystyle\bigoplus_{\begin{array}{c}
                                                   \scriptstyle q'' \in Q\\[-1ex]
                                                   \scriptstyle s = au,\, a \in \Sigma
                                                   \end{array}}
    \wei_{10}(q, a, \varepsilon, q'') \otimes \weight_T(q'', u, t, q')\nonumber\\
                    & \oplus \displaystyle\bigoplus_{\begin{array}{c}
                                                     \scriptstyle q'' \in Q\\[-1ex]
                                                     \scriptstyle t = bv,\, b \in \Delta\\
                                                     \end{array}}
    \wei_{01}(q, \varepsilon, b, q'') \otimes \weight_T(q'', s, v, q')\nonumber\\
                    & \oplus \displaystyle\bigoplus_{\begin{array}{c}
                                                     \scriptstyle q'' \in Q\\[-1ex]
                                                     \scriptstyle s = au,\, t = bv\\
                                                     \end{array}}
    \wei_{11}(q, a, b, q'') \otimes \weight_T(q'', u, v, q')\nonumber
\end{align}


%
We recall that, by convention (Section~\ref{sec:semiring}),
an empty sum with $\bigoplus$ is equal to~$\zero$.
%
Intuitively, using a transition $\wei_{ij}(q, a, b, q')$ means for $T$:
when reading respectively $a$ and $b$ at the current positions in the input and output words,
increment the current position in the input word if and only if $i = 1$,
and in the output word iff $j = 1$, %(otherwise, do not change it),
and change state from $q$ to $q'$.
When $a = \varepsilon$ (resp. $b = \varepsilon$), the current symbol
in the input (resp. output) is not read.
%
%In contrast with the models of weighted transducers over finite alphabets~\cite{Mohri03ijfcs},
%the input and output symbols at current positions are always read by transitions,
%even when they do not change the reading position the head's position.
%This is an important feature in the case of an infinite alphabet in
%order to compare input and output symbols.
%which cannot be stored in the finite memory of the transducer.
%
Since~$\zero$ is absorbing for~$\otimes$ in~$\Semiring$,
one term $\wei_{ij}(q, a, b, q'')$ equal to $\zero$ in the above expression
will be ignored in the sum, meaning that there is no possible transition
from state $q$ into state $q'$ while reading $a$ and $b$.
This is analogous to the case of a transition's guard not satisfied by $\<a, b>$ for
symbolic transducers.

%whereas considering the current symbol may be useful to compute a transition weight.
%(even when it does not change the head's position, like with $\varepsilon$-transitions).
%
%The cases $\weight_T(q, au, \varepsilon, q')$ and $\weight_T(q, \varepsilon, bv, q')$
%are missing in the definition of $\weight_T$.
%It means that $T$ must avoid configurations where it reached the end of
%the output word and not of the input one, or vice-versa.
%This can be done by using $\wei_{10}$ and $\wei_{01}$
%before reaching the end of word, and using a special state for this purpose.

The expression \eqref{eq:SWT-weight}
can be seen as a stateful definition of
an edit-distance between a word $s \in \Sigma^*$ and a word $t \in \Delta^*$,
see also~\cite{Mohri03ijfcs}.
Intuitively,
$\wei_{10}(q, a, \varepsilon, r)$ is the cost of
the deletion of the symbol~$a \in \Sigma$ in~$s$,
$\wei_{01}(q, \varepsilon, b, r)$ is the cost
of the insertion of~$b \in \Delta$ in $t$,
and $\wei_{11}(q, a, b, r)$ is the cost
of the substitution of  $a \in \Sigma$ by~$b \in \Delta$.
%
The cost of a sequence of such operations transforming $s$ into $t$,
is the product, with $\otimes$, of the individual costs of the operations involved;
and the distance between $s$ and $t$ is the sum, with $\oplus$,
of all possible products.
%
\medskip\noindent
%Let $\< s, t> \in \Sigma^* \times \Delta^*$, with $s = s_1\ldots s_n$, and $t = t_1\ldots t_m$.
Formally, the weight associated by $T$ to $\< s, t> \in \Sigma^* \times \Delta^*$ is:
%defined as follows:
\begin{equation}
T(s, t)  =
\displaystyle\bigoplus_{q, q' \in Q} \init(q)
\mathop{\otimes} \weight_T(q, s, t, q') \mathop{\otimes} \final(q')
\label{eq:SWT-value}
\end{equation}

%\begin{example}
%We can define with a \SWT the computation of a similarity measure
%between timed sequences
%similar to dynamic time warping (DTW).
%
%Let $\Semiring$  be the tropical (\emph{min-plus}) semiring of Figure~\ref{fig:semirings} and
%let $\Sigma = \Delta = \mathbb{R}_+$ be sets of timestamps.
%We consider a \SWT with one state $q$ and transitions
%$\wei_{11}(q, d, d', q) =
% \wei_{01}(q, d, d', q) =
% \wei_{10}(q, d, d', q) = |d' - d|$,
%for all $d, d' \in \mathbb{R}_+$.
%% needs reading input/output symbols even by epsilon-transitions.
%The recursive definition of $\weight_T$ correspond to the dynamic programming equations of DTW
%for the computation of an optimal match between words,
%the matching cost for two symbols being the
%the time distance between them.
%\endex
%\end{example}


\begin{example}\label{ex:SWT}
We build a small weighted transducer model
with two states $q_0$ and $q_1$ that
calculates the distance between the performance $I$ and
the score $O$ of Example~\ref{ex:running}.

If one performed event $\mu_i$  corresponds
to one notated event $\nu_j$ (for instance MIDI code 61 and pitch A4),
the weight value computed by the \SWT is the time distance between both,
(see Example~\ref{distance-time}), and is modeled by
transitions $\wei_{11}$ below.
%
If we meet the music notation symbol '-' that
represents continuation (this occurs for instance in \emph{ties}
$\musQuarter\!\!\!\mathrel{\raisebox{-1.5mm}{$\smile$}}\!\!\!\musEighth$,
or \emph{dots} \musQuarterDotted{}), it is  skipped with no cost (transitions $\wei_{01}$ or weight $\one$).
%transitions
\[
\begin{array}{rclcrcl}
\wei_{11}(q_0, \<\mu, \tau>, \<\nu, \tau'>, q_0) & = & |\tau' - \tau| & \quad &
\wei_{11}(q_1, \<\mu, \tau>, \<\nu, \tau'>, q_0) & = & |\tau' - \tau|\\
\wei_{01}(q_0, \varepsilon, \< \mathsf{-}, \tau'>, q_0) & = & \one & &
\wei_{01}(q_1, \varepsilon, \< \mathsf{-}, \tau'>, q_0) & = & \one\\
\wei_{10}(q_0, \<\mu, \tau>, \varepsilon, q_1) & = & \alpha & & %\multicolumn{3}{l}{\mathrm{for~all~} b \in \Delta}
\end{array}
\]
%
We also want to take performing errors into account, while still being able to compare with the score,
since a performer could, for example, play an unwritten extra note.
\lydia{reformulated this sentence}
%
This is modelled by the transition $\wei_{10}$ with an arbitrary weight value $\alpha \in \Semiring$,
switching from state $q_0$ (normal) to $q_1$ (error).
\philippe{Comprends pas cette phrase}
The transitions in the second column below switch back to the normal state $q_0$.
% the metric computed by the \SWT is the smallest sum of point wise distances
% between dates of input and output events.
At last, we let $q_0$ be the only initial and final state, with
$\init(q_0) = \final(q_0) = \one$, and
$\init(q_1) = \final(q_1) = \zero$.
This \SWT is capable of evaluating the differences between a score and a performance,
all the while ensuring that performance errors are plausible.
%$\init(q_0, d, b) = \final(q_0, d, b) = \one$, and
%$\init(q_1, d, b) = \final(q_1, d, b) = \zero$,
%for all $d \in \Sigma$ and $b \in \Delta$.
\endex
\end{example}

\begin{comment}
\begin{example}
In Common Western Music Notation~\cite{Gould11Notation},
several symbols may be used to represent one single sounding event.
\lydia{unique $\to$ similar}
\florent{similar $\to$ single}
For instance, several notes can be combined with a tie,
like in $\musQuarter\!\!\!\mathrel{\raisebox{-1.5mm}{$\smile$}}\!\!\!\musEighth$,
and one note can be augmented by half its duration with a dot like in~\musQuarterDotted{}.
\lydia{modif.}
These notations are perceived equivalent when played, as their duration is equal, yet the notation is different.
We thus want to be able to compare a music score with music played by a performer.
\lydia{changed end}
%
\noindent
We propose a small weighted transducer model with two states $q_0$ and $q_1$
that calculates the distance bewteen an input sequence of sounding
events (music "performance")
to an output sequence of written events (music "score").
% simple pointwise distance between two sequences of timestamped events **
%
Let us consider the tropical (\emph{min-plus}) semiring~$\Semiring$
of Figure~\ref{fig:semirings} and
let $\Sigma = \mathbb{R}_+$ be an input alphabet of event dates
and $\Delta = \{ \mathsf{e}, \mathsf{-} \} \times \mathbb{R}_+$
be an output alphabet of symbols with timestamps.
A symbol $\< \mathsf{e}, d > \in \Delta$ represents an event starting at date $d$,
and $\< \mathsf{-}, d >$ is a continuation of the previous event.
%More precisely, we let
%$\Sigma = \{ a, - \} \times \R_+$ and
%This example of $\Delta$ is motivated by the case of music notation,
%where several notated events (notes) can be tied together,
%with a \emph{tie} or a \emph{dot}
%meaning that they will be played as a unique sounding event.
%The timestamp of $a \in \Sigma$, denoted by $\mathsf{t}(a)$, is expressed as a rational number.

We consider a \SWT with two states $q_0$ and $q_1$ whose purpose
is to compare a recorded performance $s \in \Sigma^*$
with a notated music sheet $t \in \Delta^*$.
One timestamp $d_i \in \Sigma$ may correspond
to one notated event $\<\mathsf{e}, d'_i> \in \Delta$, in which case
the weight value computed by the \SWT is the time distance between both
(see transitions $\wei_{11}$ below).
%
If $\<\mathsf{e}, d'_i>$ is followed by continuations
$\<\mathsf{-}, d'_{i+1}>$..., they are just skipped with no cost (transitions $\wei_{01}$ or weight $\one$).
%transitions
\[
\begin{array}{rclcrcl}
\wei_{11}(q_0, d, \< \mathsf{e}, d'>, q_0) & = & |d' - d| & \quad &
\wei_{11}(q_1, d, \< \mathsf{e}, d'>, q_0) & = & |d' - d|\\
\wei_{01}(q_0, \varepsilon, \< \mathsf{-}, d'>, q_0) & = & \one & &
\wei_{01}(q_1, \varepsilon, \< \mathsf{-}, d'>, q_0) & = & \one\\
\wei_{10}(q_0, d, \varepsilon, q_1) & = & \alpha & & %\multicolumn{3}{l}{\mathrm{for~all~} b \in \Delta}
\end{array}
\]
%
We also must be able to take performing errors into account, while still being able to compare with the score,
since a performer could, for example, play an unwritten extra note.
\lydia{reformulated this sentence}
%
This is modelled by the transition $\wei_{10}$ with an arbitrary weight value $\alpha \in \Semiring$,
switching from state $q_0$ (normal) to $q_1$ (error).
The transitions in the second column below switch back to the normal state $q_0$.
% the metric computed by the \SWT is the smallest sum of point wise distances
% between dates of input and output events.
At last, we let $q_0$ be the only initial and final state, with
$\init(q_0) = \final(q_0) = \one$, and
$\init(q_1) = \final(q_1) = \zero$.

\lydia{ccl to the ex}
That way, an \SWT is capable of evaluating the differences between a score and a performance,
all the while ensuring that performance errors are plausible.

%$\init(q_0, d, b) = \final(q_0, d, b) = \one$, and
%$\init(q_1, d, b) = \final(q_1, d, b) = \zero$,
%for all $d \in \Sigma$ and $b \in \Delta$.
\endex
\end{example}
\end{comment}


\noindent
The \emph{Symbolic Weighted Automata} %$A = \< Q, \init, \weight, \final >$
%over $\Sigma$,  $\Semiring$ and $\bar\Phi$
are defined similarly as the transducers of Definition~\ref{def:SWT},
by simply omitting the output symbols.
%
%In this case, the label theory $\bar\Phi$ can be reduced to a singleton $\< \Phi_\Sigma>$.
%
\begin{definition} \label{def:SWA}
A \emph{symbolic-weighted automaton} (\SWA)
over $\Sigma$, $\Semiring$ and $\bar\Phi$
%the input alphabet~$\Sigma$ and the commutative semiring $\Semiring$
is a tuple
$A = \< Q, \init, {\wei_1}, \final >$,
where $Q$ is a finite set of states,
$\mathsf{in} : Q \to \Semiring$ %\Phi_\Sigma$,
(respectively $\mathsf{out} : Q \to \Semiring$)  %\Phi_\Sigma,$
are functions defining the weight for entering
(respectively leaving) computation in a state,
and ${\wei_1}$ is a transition function
from $Q \times Q$ into~$\Phi_{\Sigma}$.
\end{definition}
%
\noindent
\florent{mv formal def. weight for \SWA to app.?}
As above in the case of \SWT,
when $\wei_1(q, q') = \phi \in \Phi_\Sigma$,
%respectively $\mathsf{in}(q) = \phi$, $\mathsf{out}(q') = \phi$,
we may write $\wei_1(q, a, q')$ for~$\phi(a)$.
%respectively $\mathsf{in}(q, a) = \phi(a)$, $\mathsf{out}(q', a) = \phi(a)$.
%$\wei_1: Q \times \Sigma \times Q \to \Semiring$,
The computation of $A$ on words $s \in \Sigma^*$
is defined with an intermediate function $\weight_A$,
defined as follows for $q, q' \in Q$, $a \in \Sigma$, $u \in \Sigma^*$,
%
\begin{align}
\weight_A(q, \varepsilon, q) & = \one\\ %\final(q)\\
\weight_A(q, \varepsilon, q') & = \zero \quad \mathrm{if~} q \neq q'\nonumber\\
\weight_A(q, au, q') & =  \displaystyle\bigoplus_{q'' \in Q}
    \wei_{1}(q, a, q'') \otimes \weight_A(q'', u, q')\nonumber
\label{eq:SWA-weight}
\end{align}
%
\noindent
and the weight value associated by $A$ to
$s \in \Sigma^*$ is defined as follows: %$s = s_1\ldots s_n \in \Sigma^+$
\begin{equation}
A(s)  =
\displaystyle\bigoplus_{q, q' \in Q} \init(q)
\mathop{\otimes} \weight_A(q, s, q') \mathop{\otimes} \final(q')
\label{eq:SWA-value}
\end{equation}


%
%When $\wei_\varepsilon(q, q') = \zero$ for all $q, q' \in Q$,
%the automaton~$A$ is called \emph{without $\varepsilon$-transitions}.

%The \emph{summary} of a $\SWT$, resp. a $\SWA$, is ***



%\subsection{Properties}
\noindent
The following property will be useful to the approach on
symbolic weighted parsing presented in Section~\ref{sec:parsing}.

\begin{proposition} \label{prop:epsilon}
Given a \SWT $T$ over $\Sigma$, $\Delta$,
$\Semiring$ commutative, bounded and complete,
and $\bar\Phi$ effective,
and a $\SWA$ $A$ over $\Sigma$, $\Semiring$ and $\bar\Phi$,
there exists an effectively constructible \SWA
$B_{A, T}$ over $\Delta$, $\Semiring$ and $\bar\Phi$,
such that for all $t \in \Delta^*$,
$B_{A, T}(t) = \displaystyle\bigoplus_{s\in \Sigma^*} A(s) \otimes T(s, t)$.
\end{proposition}
%
\begin{proof}
(sketch, see Appendix~\ref{sec:closure} for details).
The state set of $B_{A, T}$ is the Cartesian product of 
the state sets of $A$ and $T$ and its transitions simulate,
while reading an output word $t \in \Delta^*$, the
synchronized behaviour of $A$ and $T$ on $t$ 
and some input word $s \in \Sigma^*$. 
The weight for reading of the input is summarized using the operator
$\bigoplus^1_\Sigma$.
%
The main difficulty comes from the transitions of $T$
of the form $\wei_{10}$, who read in input and ignore the output.
Such transition shall be simulated by $\varepsilon$-transitions in $B_{A, T}$,
but $\varepsilon$-transitions are not defined for $\SWA$.
Therefore, the $\varepsilon$-transitions
are eliminated on-the-fly during the construction of~$B_{A, T}$,
following a procedure of~\cite{LombardySakarovitch12ciaa}.
%\qed
\end{proof}

%The complexity of construction
\noindent
The construction time and size for $B_{A, T}$ are $O(\| T \|^3 . \| A \|^2)$,
where the sizes $\| T \|$ and $\| A \|$ are their number of states.
%of~$T$ is its number of states $|Q|$.
\florent{revise complexity with nb. of tr. and states}
%
The particular case of Proposition~\ref{prop:epsilon} with a singleton $A$,
\ie such that $A(s) = \one$ for a given $s \in \Sigma^*$
and $A(s') = \zero$ for all $s' \neq s$,
corresponds to a construction of a \SWA for the partial application of the \SWT $T$,
fixing the first argument $s$.
\begin{corollary} \label{cor:epsilon}
Given a \SWT $T$ over $\Sigma$, $\Delta$,
$\Semiring$ commutative, bounded and complete,
and $\bar\Phi$ effective,
and $s \in \Sigma^+$,
there exists an effectively constructible \SWA
$B_{s, T}$ over $\Delta$, $\Semiring$ and $\bar\Phi$,
such that for all $t \in \Delta^*$, $B_{s, T}(t) = T(s, t)$.
\end{corollary}


%\noindent
%The construction time and size for $B_{T, s}$ are $O(\| T \|^3 . | s |^2)$,
%where the size $\| T \|$ of~$T$ is its number of states $|Q|$.







%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% SW-VPA
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{SW Visibly Pushdown Automata}
\label{section:SWVPA}\label{sec:SWVPA}
The model presented in this section generalizes symbolic \VPA
(\SVPA~\cite{dAntonyAlur14SVPDA},
 generalizing themselves \VPA~\cite{AlurMadhusudan09nested} to infinite alphabets)
from Boolean semirings to arbitrary semiring weight domains.
It will compute on nested words over infinite alphabets,
associating to every such word a weight value.
Nested words are able to describe structures of labeled trees,
and in the context of parsing, they will be useful to
represent AST. % parse trees.
\florent{see \S 5 and App.A}

%\subsection{Definition}
\noindent
\label{sec:SWVPA-def}
Let $\Delta$ be a countable alphabet
%finite (large) or infinite,
that we assume partitioned into three
subsets~$\Deltai$, $\Deltac$, $\Deltar$,
whose elements are respectively called
\emph{internal}, \emph{call} and \emph{return} symbols,
following~\cite{AlurMadhusudan09nested}.
% names are  coined by application to functional program verification
% \begin{itemize}
% \item a set $\Deltai$ of \emph{internal symbols} denoted $a$,
% \item a set $\Deltac$ of \emph{call symbols} denoted $\call{a}$,
% \item a set $\Deltar$ of \emph{return symbols} denoted $\return{a}$.
% \end{itemize}
Let~$\< \Semiring, \oplus, \zero, \otimes, \one>$ be a commutative and complete semiring and let
$\bar\Phi = \< \Phii, \Phic, \Phir, \Phici, \Phicc, \Phicr>$
be a label theory over $\Semiring$
%In order to simplify notations, %and following the definition of Section~\ref{section:transducer},
%we shall write respectively
where $\Phii$, $\Phic$, $\Phir$ and~$\Phicx$ (with $\mathsf{x} \in \{ \mathsf{i}, \mathsf{c}, \mathsf{r}\}$)
stand respectively
for~$\Phi_\Deltai$, $\Phi_\Deltac$, $\Phi_\Deltar$ and~$\Phi_{\Deltac, \Delta_\mathsf{x}}$.
%
%Moreover, we extend this theory with a set $\Phii$
%of unary functions in $\Deltai \to \Semiring$,
%closed under $\oplus$ and $\otimes$.

\begin{example}\label{ex:nested-word}
Consider once more the scores of Example~\ref{ex:running}.
$\Deltai$ represents the set of music events of the form $<\nu, \tau>$
where $\nu$ is either a note (e.g. A4), the continuation symbol $-$, or a
rest symbol R. $\Deltac$ and  $\Deltar$ are used to encode the score structure:
Let $\Deltac = \{\langle, \prec\}$ and  $\Deltar = \{\rangle, \succ\}$ where $\langle$
(resp. $\rangle$)
and $\prec$ (resp. $\succ$) correspond to start/end of measures, and start/end of
tuplets. Then  \includegraphics[scale=0.20]{pictures/score5.png}
is encoded with the nested word $\langle \prec 0, \frac{3}{4}, \frac{7}{8} \succ \rangle \langle \prec 1, \frac{4}{3}, \frac{5}{3}  \succ \rangle$
\endex
\end{example}


\begin{definition}
A \emph{Symbolic Weighted Visibly Pushdown Automata} (\SWVPA)
over  $\Delta = \Deltai \uplus \Deltac \uplus \Deltar$, $\Semiring$ and $\bar\Phi$
is a tuple $A = \< Q, P, \init, \bar\wei, \final >$,
where $Q$ is a finite set of states,
$P$ is a finite set of stack symbols,
$\mathsf{in} : Q \to \Semiring$
(respectively $\mathsf{out} : Q \to \Semiring$)
are functions defining the weight for entering
(respectively leaving) a state,
and $\bar\wei$ is a sextuplet composed of the transition functions :
$\weii : Q \times P \times Q \to \Phici$,
$\weiei : Q \times Q \to \Phii$,
$\weic : Q \times P \times Q \times P \to \Phicc$,
$\weiec : Q \times P \times Q \to \Phic$,
$\weir : Q \times P \times Q \to \Phicr$,
$\weier : Q \times Q \to \Phir$.
%and
%$\weiex : Q \times Q \to \Phix$
%with $\mathsf{x} \in \{ \mathsf{i}, \mathsf{c}, \mathsf{r}\}$.
\end{definition}
%
Similarly as in Section~\ref{section:transducer},
we extend the above transition functions as follows
for all $q, q' \in Q$, $p \in P$,
$a \in \Deltai$,
$\call{c} \in \Deltac$,
$\return{r} \in \Deltar$,
overloading their names: % for simplicity:
\[
\begin{array}{lll}
\weii: Q \times [\Deltac \times P] \times \Deltai \times Q \to \Semiring &
\weii(q, c, p, a, q') = \eta_\mathsf{ci}(c, a) &
\mathrm{where~} \eta_\mathsf{ci} = \weii(q, p, q'),\\
%
\weiei: Q \times \Deltai \times Q \to \Semiring &
\weiei(q, a, q') = \phi_\mathsf{i}(a) &
\mathrm{where~} \phi_\mathsf{i} = \weiei(q, q').\\
%
\weic: Q \times [\Deltac \times P] \times  [\Deltac \times P] \times Q \to \Semiring &
\weic(q, c, p, \call{c'}, p', q') = \eta_\mathsf{cc}(c, \call{c'}) &
\mathrm{where~} \eta_\mathsf{cc} = \weic(q, p, p', q'),\\
%
\weiec: Q \times [\Deltac \times P] \times Q \to \Semiring &
\weiec(q, {\call{c}}, p, q') = \phi_\mathsf{c}({\call{c}}) &
\mathrm{where~} \phi_\mathsf{c} = \weiec(q, p, q').\\
%
\weir: Q \times [\Deltac \times P] \times \Deltar \times Q \to \Semiring &
\weir(q, {\call{c}},  p, {\return{r}}, q') = \eta_\mathsf{cr}({\call{c}},  {\return{r}}) &
\mathrm{where~} \eta_\mathsf{cr} = \weir(q, p, q'),\\
%
\weier: Q \times \Deltar \times Q \to \Semiring &
\weier(q, {\return{r}}, q') = \phi_\mathsf{r}({\return{r}}) &
\mathrm{where~} \phi_\mathsf{r} = \weier(q, q').\\
\end{array}
\]

\noindent
The intuition is the following for the above transitions.
$\weiei$, $\weiec$, and $\weier$ describe the cases where the stack is empty.
\lydia{moved this to the beginning}
%
\noindent
$\weii$ and $\weiei$ both read an input internal symbol $a$ and change state from $q$ to $q'$,
without changing the stack.
Moreover, $\weii$ reads a pair made of
${\call{c}} \in \Deltac$ and $p \in P$ on the top of the stack
($c$ is compared to $a$ by the weight function $\eta_\mathsf{ci} \in \Phici$).
%
\noindent
$\weic$ and $\weiec$ read the input call symbol $\call{c}'$,
push it to the stack along with $p'$, and change state from $q$ to to $q'$.
Moreover, $\weic$ reads ${\call{c}}$ and $p$ at the top of the stack
($c$ is compared to $c'$).
%and $\weiec$ applies iff the stack is empty.
%
\noindent
$\weir$ and $\weier$ read the input return symbol $\return{r}$, and change state from $q$ to to $q'$.
Moreover, $\weir$ reads and pop from stack a pair made of $\call{c}$ and $p$,
($\call{c}$ is compared to $\return{r}$).
%and $\weier$ applies iff the stack is empty.
%In this case, the weight function $\phi_\mathsf{r}$
%computes a value of matching between the call and return symbols $c$ and $r$.
%This value might be set to $\zero$ in order to express that the symbols do not match.

Formally, the transitions of the automaton~$A$ are defined
with an intermediate function $\weight_A$, like in Section~\ref{sec:SWT}.
%
A configuration $q[\gamma]$
is composed of a state $q \in Q$
and a stack content $\gamma \in \Gamma^*$,
where $\Gamma = \Deltac \times P$.
Hence, $\weight_A$ is a function from
$[Q \times \Gamma^*] \times \Delta^* \times [Q \times \Gamma^*]$ into~$\Semiring$.
The empty stack is denoted by $\bot$, and the first %upmost
symbol is the last pushed content.
%
The recursive definition of $\weight_A$
enumerates each of the six possible cases:
reading $a \in \Deltai$,
%\lydia{intro to func}
or $\call{c} \in \Deltac$, or $\return{r} \in \Deltar$,
and for each possible state of the stack (empty or not).
%to add to $u \in {\Delta}^*$.
%\lydia{introduced the 6 cases}
\florent{shorter notation $cp$ for $\< c, p>$ ?}

\begin{align}
%\weight_A\bigl(\config{q}{\bot}, \varepsilon, \config{q}{\bot}) & = \one\label{eq:SWVPA-weight}\\
%\weight_A\bigl(\config{q}{\bot}, \varepsilon, \config{q'}{\gamma}) & = \zero
%\mathrm{~if~} q \neq q'\nonumber\\
%
\weight_A\bigl(\config{q}{\bot}, \varepsilon, \config{q'}{\bot}) & = \one
\mathrm{~if~} q = q' \mathrm{~and~} \zero \mathrm{~otherwise}\label{eq:SWVPA-weight}\\
\weight_A\bigl(\configup{q}{\<{\call{c}}, p>\stackup\gamma}, a\, u,
               \config{q'}{\gamma'}\bigr) & =
 {\displaystyle\bigoplus_{q'' \in Q}} \weii(q, c, p, a, q'')
  \otimes \weight_A\bigl(\configup{q''}{\<{\call{c}}, p> \stackup \gamma}, u,
                         \config{q'}{\gamma'}\bigr)\nonumber\\
%
\weight_A\bigl(\config{q}{\bot}, a\, u,
               \config{q'}{\gamma'}\bigr) & =
  {\displaystyle\bigoplus_{q'' \in Q}} \weiei(q, a, q'')
   \otimes \weight_A\bigl(\config{q''}{\bot}, u, \config{q'}{\gamma'}\bigr)\nonumber\\
%
\weight_A\bigl(\configup{q}{\<{\call{c}}, p>\stackup\gamma}, {\call{c}'}\, u,
               \config{q'}{\gamma'}\bigr) & =
 {\displaystyle\bigoplus_{\begin{array}{c}
                          \scriptstyle q'' \in Q\\[-1ex]
                          \scriptstyle p' \in P
                          \end{array}}}
 \weic\bigl(q, {\call{c}}, p, {\call{c}'}, p', q''\bigr)
 \otimes \weight_A\bigl(\configup{q''}{\<{\call{c}'}, p'>\stackup \<{\call{c}}, p>\stackup \gamma}, u,
                        \config{q'}{\gamma'}\bigr)\nonumber\\[1mm]
%
\weight_A\bigl(\config{q}{\bot}, {\call{c}}\, u,
               \config{q'}{\gamma'}\bigr) & =
 {\displaystyle\bigoplus_{\begin{array}{c}
                          \scriptstyle q'' \in Q\\[-1ex]
                          \scriptstyle p \in P
                          \end{array}}}
  \weiec(q, {\call{c}}, p, q'')
  \otimes \weight_A\bigl(\config{q''}{\<{\call{c}}, p>}, u,
                         \config{q'}{\gamma'}\bigr)\nonumber\\
%
\weight_A\bigl(\configup{q}{\<{\call{c}}, p>\stackup\gamma}, {\return{r}}\, u,
               \config{q'}{\gamma'}\bigr) & =
 {\displaystyle\bigoplus_{q'' \in Q}}
  \weir\bigl(q, {\call{c}}, p, {\return{r}}, q''\bigr)
  \otimes \weight_A\bigl(\config{q''}{\gamma}, u,
                         \config{q'}{\gamma'}\bigr)\nonumber\\
%
\weight_A\bigl(\config{q}{\bot}, {\return{r}}\, u,
               \config{q'}{\gamma'}\bigr) & =
 {\displaystyle\bigoplus_{q'' \in Q}} \weier(q, {\return{r}}, q'')
  \otimes \weight_A\bigl(\config{q''}{\bot}, u,
                         \config{q'}{\gamma'}\bigr)\nonumber
\end{align}
%\lydia{c p to <c, p>}
%
% and ${\call{c}}\, p\stacksep \gamma$
%denotes a stack where the pair made of ${\call{c}} \in \Deltac$ and $p \in P$ is the top symbol
%and $\gamma$ is the rest of stack.

\noindent
The weight associated by $A$ to $t \in \Delta^*$
is defined according to empty stack semantics:
%
\begin{equation}
A(t)  =
{\displaystyle\bigoplus_{q, q' \in Q}} \textstyle
\mathsf{in}(q) \mathop{\otimes}
\weight_A\bigl(\config{q}{\bot}, t, \config{q'}{\bot}\bigr)
\mathop{\otimes} \mathsf{out}(q').
\label{eq:SWVPA-value}
\end{equation}

\noindent
Every $\SWA$ $A = \< Q, \init, {\wei_1}, \final >$,
over $\Sigma$, $\Semiring$ and $\bar\Phi$
is a particular case of $\SWVPA$
$\< Q, \emptyset, \init, \bar\wei, \final >$
over $\Delta$, $\Semiring$ and $\bar\Phi$
with $\Deltai = \Sigma$ and $\Deltac = \Deltar = \emptyset$,
and computing with an always empty stack:
$\weiei = \wei_1$ and all the other functions
of~$\bar\wei$ are the constant~$\zero$.


%\subsection{Properties}
\medskip\noindent
Similarly to \VPA~\cite{AlurMadhusudan09nested}
and \SVPA~\cite{dAntonyAlur14SVPDA},
the class of \SWVPA is closed under the binary operators of the underlying semiring.
%
\begin{proposition}\label{prop:SWVPA-product}
Let $A_1$ and $A_2$ be two \SWVPA
over the same $\Delta$, $\Semiring$ and $\bar\Phi$.
There exists two effectively constructible $\SWVPA$
$A_1 \oplus A_2$ and $A_1 \otimes A_2$,
such that for all $s \in \Delta^*$,
$(A_1 \oplus A_2)(s) = A_1(s) \oplus A_2(s)$ and
$(A_1 \otimes A_2)(s) = A_1(s) \otimes A_2(s)$.
\end{proposition}
%
\begin{proof}
The construction is similar
to the case of the Boolean semiring~\cite{dAntonyAlur14SVPDA}.
\florent{complete proof (app)}
\end{proof}
\noindent
We shall now present a procedure for searching, for a~$\SWVPA$ $A$,
a word %$w \in \Delta^*$
of minimal weight for~$A$.
%as stated in the following proposition. %\wrt~$\leq_\oplus$,
%It requires the following property of label theories.
%
\begin{proposition}\label{th:best-search}
For a \SWVPA $A$
over $\Delta$,
$\Semiring$ commutative, bounded, total and complete, %semiring
and $\bar\Phi$ effective, %and $k$-convex, % label theory,
one can construct in PTIME a word $t \in \Delta^*$
such that $A(t)$ is minimal \wrt the natural ordering for $\Semiring$.
\end{proposition}
%\florent{total?}
%
Let $A = \< Q, P, \init, \bar\wei, \final >$.
%
We propose a Dijkstra algorithm computing,
for every $q, q' \in Q$,
the minimum, \wrt $\leq_\oplus$, of the function
$\beta_{q, q'} : t \mapsto \weight_A(\config{q}{\bot}, t, \config{q'}{\bot})$.
Let us denote by $b_\bot(q, q')$ this minimum.
By definition of $\leq_\oplus$, and since $\Semiring$ is total,
it holds that:
%
\begin{equation}\label{eq:bbot}
  b_\bot(q, q') = \bigoplus_{t\in \Delta^*}
  \textstyle
  \weight_A\bigl(\config{q}{\bot}, t, \config{q'}{\bot}\bigr).
\end{equation}
The infinite sum in~\eqref{eq:bbot} is well defined since $\Semiring$ is complete.
%
Following~\eqref{eq:SWVPA-value}, and the associativity and commutativity
and distributivity for~$\otimes$ and~$\oplus$, the minimum of~$A(t)$ is:
\begin{equation}\label{eq:min}
{\displaystyle\bigoplus_{t\in \Delta^*}} A(t)
=
{\displaystyle\bigoplus_{t\in \Delta^*}}
{\displaystyle\bigoplus_{q, q' \in Q}} \textstyle
\mathsf{in}(q) \mathop{\otimes}
\beta_{q, q'}(t)
\mathop{\otimes} \mathsf{out}(q')
=
{\displaystyle\bigoplus_{q, q' \in Q}} \textstyle
\mathsf{in}(q) \mathop{\otimes}
b_\bot(q, q')
\mathop{\otimes} \mathsf{out}(q')
\end{equation}

\noindent
In order to compute the above function $b_\bot : Q \times Q \to \Semiring$,
we shall consider an auxiliary function $b_\top :  Q \times P \times Q \to \Phic$.
%
Intuitively, $b_\top(q, p, q')$ is a function of $\Phic$,
mapping every $c \in \Deltac$ to
the minimum weight of a computation of~$A$
starting in state $q$ with a non-empty stack
$\gamma' = \<c, p> \, \gamma \in \Gamma^+$,
and ending in state $q'$ with the same stack $\gamma'$,
such that moreover,
the computation does not pop the pair $\<c, p>$ at the top of $\gamma'$
(\ie $\gamma'$ is left untouched during the computation).
However, the computation can read $\<c, p>$ at the top of $\gamma'$,
and can also push another pair $\< c', p'> \in \Gamma$ on $\gamma'$,
following the third case of
in the definition \eqref{eq:SWVPA-weight} of $\weight_A$ (call symbol).
The pair $\< c', p'>$ can be pop later, during the computation from $q$ to $q'$,
following the fifth case of \eqref{eq:SWVPA-weight} (return symbol).
%However, it cannot apply one of the two last cases (return symbol and empty stack)
%when the current stack is $\gamma$.
%pop symbols in $\gamma$.
%
% Note that having a stack reduced to such a symbol makes impossible the application of the
% two last cases in the definition of $\weight_A$ (return symbol and empty stack).
% However, it is possible to apply the two first cases
% (internal symbol or call symbol, with a push on the top of $\top$).
%
Formally, in order to define $b_\top$, we consider
a fresh stack symbol $\top \notin \Gamma$,   %which does not belong to $\Gamma$,
representing the above untouched stack, and let:
%
\begin{equation}\label{eq:btop}
  b_\top(q, p, q') : c \mapsto \bigoplus_{s\in \Delta^*}
  \textstyle
  \weight_A\bigl(\configup{q}{\< c, p> \stackup \top }, s, \configup{q'}{\<c, p> \stackup \top}\bigr)
\quad
\mathrm{~for~all~} c \in \Deltac
\end{equation}
%
By definition of $\weight_A$ in \eqref{eq:SWVPA-weight},
using the symbol $\top$ for the part of the stack below $\<c, p>$
(\ie the substack $\gamma$ in the above $\gamma' = \<c, p> \, \gamma$)
ensures that this part $\gamma'$ is not touched during the computation.
% there cannot be a pop of $\<c, p>$ followed by a push of $\<c, p>$
% because it is not possible to push over $\top$ (push read the top of stack).
%
This ensures in particular that the subword
read during the computation is well parenthesized
(every symbol in $\Deltac$ has a matching symbol in $\Deltar$).

% Note that having a stack reduced to such a symbol makes impossible the application of the
% two last cases in the definition of $\weight_A$ (return symbol and empty stack).
% However, it is possible to apply the two first cases
% (internal symbol or call symbol, with a push on the top of $\top$).

%The term $\config{q}{\bot}, s, \config{q'}{\bot}$
%of this sum is the central expression in
%the definition \eqref{eq:weightA} of $A(s_0)$, for the minimum $s_0$
%of the function $\weight_A$.

\begin{algorithm}
\SetKw{Extract}{extract}
\SetKw{Update}{update}

\textbf{initially} let $\Q = (Q \times Q) \cup (Q \times P \times Q)$,
and let $d_\bot(q_1, q_2) = d_\top(q_1, p, q_2) = \one$
if $q_1 = q_2$ and $d_\bot(q_1, q_2) = d_\top(q_1, p, q_2) = \zero$ otherwise$\;$

\smallskip\noindent
\While{$\Q \neq \emptyset$}{

%\noindent\quad
\Extract $\< q_1, q_2>$ or $\< q_1, p, q_2>$ from $\Q$
%
%\noindent\quad
such that $d_\bot(q_1, q_2)$, resp. $\bigoplus_{c\in \Deltac} d_\top(q_1, p, q_2)(c)$, is minimal in $\Semiring$ \wrt $\leq_\oplus$$\;$

%\noindent\quad
%\textbf{for all} $q_0, q_3 \in Q$
\Update $d_\bot$ with $\< q_1, q_2>$ or $d_\top$ with $\< q_1, p, q_2>$ (Figure~\ref{fig:best-update}).$\;$
}
\caption{Best search for \SWVPA}
\label{algo:Dijkstra}
\end{algorithm}

Algorithm~\ref{algo:Dijkstra}
constructs iteratively two markings
$d_\bot : Q \times Q \to \Semiring$ and
$d_\top : Q \times P \times Q \to \Phic$,
%of the triplets $\<q, \sigma, q'>$
%of states of $A$ by weight values in $\Semiring$,
that converges eventually to $b_\top$ and $b_\bot$.
%It uses for that purpose a priority queue $P$ containing triplets of
%$Q \times \{ \bot, \top \} \times Q$.
\florent{explication Fig.~\ref{fig:best-update} (update) suivant cas de \eqref{eq:SWVPA-weight}?}

The infinite sums in the updates of $d$ in Algorithm~\ref{algo:Dijkstra},
Figure~\ref{fig:best-update}
are well defined
since~$\Semiring$ is complete.


Termination: the algorithm performs $2.|Q|^2$ iterations until $P$ is empty,
and each iteration has a time complexity $O(|Q|^2 . |P|)$.
\florent{complexity: detail with nb tr. and states?}
That gives a time complexity $O(|Q|^4 . |P|)$.
It can be reduced by implementing $P$ as a priority queue,
prioritized by the value returned by $d$.
** where  $T$ is the worst time complexity for an oracle computing the values
of Definition~\ref{def:effective}.
%$|Q|^3.\log(|Q|^2)$
%
At termination, $d_\bot = b_\bot$ and $d_\top = b_\top$
(see Appendix~\ref{sec:bestsearch}).
With~\eqref{eq:min}, this ensures
the correctness of Algorithm~\ref{algo:Dijkstra}.

\begin{figure}[ht]
For all $q_0, q_3 \in Q$, %$p \in P$,
\[
\begin{array}{lcl}
%\multicolumn{3}{l}{\mathrm{For~all~} q_0, q_3 \in Q, p \in P,}\\
d_\top(q_1, p, q_3) & \opluseq &
  d_\top(q_1, p, q_2) \otimes
  \displaystyle\bigoplus_{\Deltai} \weii(q_2, p, q_3)\\
%\multicolumn{3}{l}{\quad
%\mathrm{where~} \weii(q_2, p, q_3)_a \in \Phic
%\mathrm{~is~the~partial~application~}
%x_c \mapsto \weii(q_2, x_c, p, a, q_3)}\\
%
d_\bot(q_1, p, q_3) & \opluseq &
  d_\bot(q_1, q_2) \otimes
  \displaystyle\bigoplus_{\Deltai} \weiei(q_2, q_3)\\
%
d_\top(q_0, p, q_3) & \opluseq &
  {\displaystyle\bigoplus_{\Deltac}}^2
  \bigl[ \bigl( \weic(q_0, p, p', q_1) \otimes_2
  d_\top(q_1, p', q_2) \bigr) \otimes_2
  {\displaystyle\bigoplus_{\Deltar}} \weir(q_2, p', q_3) \bigr]\\
%\multicolumn{3}{l}{\quad
%\mathrm{where~} \weic(q_0, p, p', q_1)_{c'} \in \Phic
%\mathrm{~is~the~partial~application~}
%x_c \mapsto \weic(q_0, p, x_c, c', p', q_1)}\\[2pt]
%
d_\bot(q_0, q_3) & \opluseq &
  {\displaystyle\bigoplus_{\Deltac}}
  \bigl(
  \weiec(q_0, p, q_1) \otimes
   d_\top(q_1, p, q_2) \otimes
  \displaystyle\bigoplus_{\Deltar} \weir(q_2, p, q_3)\bigr)\\
%
d_\bot(q_1, q_3) & \opluseq &
  d_\bot(q_1, q_2) \otimes
  \displaystyle\bigoplus_{\Deltar} \weier(q_2, q_3)\\
%
d_\top(q_1, p, q_3) & \opluseq &
  d_\top(q_1, p, q_2) \otimes d_\top(q_2, p, q_3),
  \mathrm{if~} \< q_2, \top, q_3> \notin P \\
%
d_\bot(q_1, q_3) & \opluseq &
  d_\bot(q_1, q_2) \otimes d_\bot(q_2, q_3), \mathrm{if~} \< q_2, \bot, q_3> \notin P \\
\end{array}
\]
%$\weii(q_2, p, q_3)_a \in \Phic$, for $a \in \Deltai$,
%is the partial application
%$x_c \mapsto \weii(q_2, x_c, p, a, q_3)$.
%
%$\weic(q_0, p, p', q_1)_{c'} \in \Phic$, for $c' \in \Deltac$,
%is the partial application
%$x_c \mapsto \weic(q_0, p, x_c, c', p', q_1)$.
\caption{Update $d_\bot$ with $\<q_1, q_2>$ or $d_\top$ with $\< q_1, p, q_2>$.}
\label{fig:best-update}
\end{figure}


\noindent
** effectively computable by hypothesis that the label theory is effective**
\florent{REVOIR}
In order to obtain effectively a witness
(word of $\Delta^*$ with a computation of $A$ of minimal weight),...
%we require the additional property of convexity of weight functions.***
using the second requirement in Definition~\ref{def:effective}.




%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Symbolic Weighted Parsing}
\label{sec:parsing}
%% see parse-tree.tex for a definition with parse tree (instead of nested words)

Let us now apply the models and results of the previous sections %in order to define
to the problem of parsing over an infinite alphabet. %appropriate
%
%\subsection{Definition}
%
Let~$\Sigma$
and~$\Delta = \Deltai \uplus \Deltac \uplus \Deltar$
be countable input and output alphabets,
let $\< \Semiring, \oplus, \zero, \otimes, \one>$ be a
commutative, bounded, and complete \florent{total?} semiring
and let $\bar\Phi$ be an effective label theory over $\Semiring$,
containing $\Phi_\Sigma$, $\Phi_{\Sigma, \Deltai}$, as well as
$\Phii$, $\Phic$, $\Phir$, $\Phicr$
(following the notations of Section~\ref{sec:SWVPA-def}).
%
\noindent
We assume given the following input:
\begin{description}
\item[--] a \SWT $T$ over $\Sigma$, $\Deltai$, $\Semiring$, and $\bar\Phi$,
defining a measure %between words
$T: \Sigma^* \times \Deltai^* \to \Semiring$,

\item[--] a \SWVPA $A$ over $\Delta$, $\Semiring$, and $\bar\Phi$,
defining a measure $A: \Delta^* \to \Semiring$,
%a \SWVPA $A$ over $\Delta$, and $\Semiring$, defining a series of nested words
%      $A : \Delta^* \to \Semiring$,
\item[--] an input word $s \in \Sigma^*$.
\end{description}
%
For all $u \in \Sigma^*$ and $t \in \Delta^*$, let
\(d(u, t) = T\bigl(u, t|_\Deltai \bigr)\),
where $t|_\Deltai \in \Deltai^*$ is the projection of $t$ onto~$\Deltai$,
obtained from $t$ by removing all symbols in $\Delta \setminus \Deltai$.
%\end{equation}
%
\noindent
\emph{Symbolic weighted parsing} is the problem,
given the above input,
to find $t \in \Delta^*$ %nested word $t \in \Delta$
minimizing \( d(s, t) \otimes A(t)\)
\wrt $\leq_\oplus$,
\ie s.t. %such that: %Hence, it is the problem of finding
%
\begin{equation}\label{eq:distance-lang}
d(s, t) \otimes A(t) = \displaystyle\bigoplus_{t' \in \Delta^*} d(s, t') \otimes A(t')
\end{equation}
%
Following the terminology of~\cite{Mohri03EDWA},
$\SW$-parsing is the problem of computing
the distance~\eqref{eq:distance-lang} between the input~$s$ and the output weighted language of~$A$,
and returning a witness $t$.

\begin{example}[Symbolic Weighted Parsing and the transcription problem]
Applied to the music transcription problem, the above formalism
is interpreted as follows:
\begin{enumerate}

  \item The \SWT $T$ evaluates a ``fitness measure''  that expresses
    a correspondance between a performance and its notation. See Example~\ref{ex:SWT}.
\item The \SWVPA $A$ expresses a cost related to the music notation. One possibility
 is to relate this cost to the structural complexity: given a set of equivalent
 representations, we aim at choosing the simpler one. For instance
 \includegraphics[scale=0.20]{pictures/score5.png} should be favored
 on \includegraphics[scale=0.20]{pictures/score4.png}. Costs  can be expressed
 in the grammar as weights associated to each production rule.
 For instance, the following production rules define two possible divisions
 of a time interval into respectively a duplet and a triplet. Each comes with
 a specific cost.
 \[
 \rho_1: q_0 \xrightarrow{0.06} \< q_{1}, q_{2}>,\
 \rho_2: q_0 \xrightarrow{0.12} \< q_{1}, q_{2}, q_{2}>.
 \]
 Further binary divisions of time sub-intervals %represented respectively by~$q_2$ and~$q_3$
 are possible with:
 \[
 \rho_3:\,q_2 \xrightarrow{0.1} \< q_{3}, q_{3}>, \
 \rho_4:\,q_3 \xrightarrow{0.11} \< q_{4}, q_{4}>. \
 \]

Score \includegraphics[scale=0.20]{pictures/score5.png} is obtained as follows:
the first measure
 results from the successive applications of  rules $\rho_1$ (division in two)
 and rules $\rho_3$ (division of the second half) in two. The second measure
 is a division in three obtained by rule $\rho_3$. One obtains a parse tree
 that can be linearized in the nested word of Example~\ref{ex:nested-word}.
 \end{enumerate}
Therefore, the framework, applied to the transcription problem, allows to find an optimal
solution that considers both the fitness of the result, and its structural complexity.
\end{example}



%
%\subsection{Computation}
%
\begin{proposition}
The problem of Symbolic Weighted  parsing
can be solved in PTIME in the size of the input \SWT $T$, \SWVPA $A$
and input word $s$,
and the computation time of the functions and operators of the label theory.
\end{proposition}
%
\begin{proof} (sketch)
We follow a \emph{Bar-Hillel} construction, for parsing by intersection.
%
\noindent
Let us first extend the \SWT $T$ over $\Sigma$, $\Deltai$
into a \SWT $T'$ over $\Sigma$ and $\Delta$
(and the same semiring and label theory $\Semiring$ and $\bar\Phi$),
such that for all $u \in \Sigma^*$, and $t \in {\Delta}^*$,
$T'(u, t) = T(u, t|_{\Deltai})$.
%
The transducer $T'$ simply skips every symbol
$b \in {\Delta} \setminus \Deltai$,
by the addition to $T$,
of new transitions of the form $\wei_{01}(q, \varepsilon, b, q')$.
%
\noindent
Then, using Corolary~\ref{cor:epsilon},
we construct from the input word $s \in \Sigma^*$ and $T'$
a \SWA $B_{s, T'}$,
such that for all $t \in \Delta^*$, $B_{s, T'}(t) = d(s, t)$.
%
%This automaton is such that for all $t \in \Delta^*$,
%\[
%   A_{T', s}\bigl(\lin(t)\bigr)
% = T'\bigl(s, \lin(t)\bigr)
% = T'\bigl(s, \lin(t)|_{\Deltai}\bigr)
% = d(s, t).
%\]
%
\noindent
Next, %we convert the input \SWTA $A$ over $\Delta$
%into a \SWVPA $A'$ over $\hat\Delta$, using Proposition~\ref{lem:SWTA}, and
we compute the \SWVPA $B_{s, T'} \otimes A$,
using Proposition~\ref{prop:SWVPA-product}.
%
\noindent
It remains to compute a best nested-word $t \in {\Delta}^*$
using the best-search procedure of Proposition~\ref{th:best-search}.
%and convert it into a best tree in $\T_\Delta$ in order to solve SW parsing
%for~$T$, $A$ and~$s$.
%\qed
\end{proof}
The $\SW$-parsing generalizes
the problem of searching the best derivation (AST) of a weighted CF-grammar $G$
that yields a given input word $w$.
The latter problem, sometimes called~\emph{weighted parsing},
(see \eg~\cite{Goodman99SemiringParsing}
 and~\cite{MorbitzVogler19weighted-parsing} for general weighted parsing frameworks)
corresponds to $\SW$-parsing in the case of finite alphabets,
a transducer $T$ computing the identity and some \SWVPA~$A$
obtained from $G$. %the weighted CF grammar.
%
%Indeed, it corresponds to the case where $T$
%accepts only the pairs $\<s, t>$ such that
%$s$ is the projection of $t$ on $\Deltai$.
%This can be done with a single state $q$ and
%with transition rules of the form:
%\begin{description}
%\item[] $\wei(q, \varepsilon, a, q) = \one$ for all $a \in \Deltac \cup \Deltar$,
%\item[] $\wei(q, a, a, q) = \one$ for all $a \in \Deltai$,
%\item[] $\wei(q, a, b, q) = \zero$ for all $a, b \in \Deltai$, $a \neq b$.
%\end{description}
%
Indeed, the \emph{depth-first} traversal of an AST $\tau$
yields a well-parenthesised word $\lin(\tau)$ over an alphabet
$\Delta = \Deltai \uplus \Deltac \uplus \Deltar$,
assuming \eg that $\Deltai$ contains the symbols labelling the leaves of $\tau$ (symbols of rank $0$),
and $\Deltac$ and $\Deltar$ contain respectively one left and right parenthesis
$\ccall{b}$ and $\creturn{b}$ for each symbol $b$ labelling inner nodes of $\tau$ (symbols of rank $>0$).
%
%With this representation, the projection $\lin(t)|_\Deltai$ is the
%sequence of leaves of $\tau$. %, enumerated in a \emph{dfs}-traversal.
%
We show in Appendix~\ref{sec:trees} how to construct
%($\SW$) tree automaton~$A$ %(in particular the TA computing on the AST of a given CF-grammar)
a $\SWVPA$ $A$ such that $A(\lin(\tau))$ is the weight the AST $\tau$ of $G$.

%That also holds for the set of ASTs of a weighted CF-grammar.
%The purpose of the transducer $T$ is to measure a distance between input and output words,
%\ie between the word $s$ and the sequence leaves of a derivation tree, in $\Deltai^*$.
%
%that generates (weighted) trees by replacement of a state symbol~$q_0$ (non-terminal),
%by a tree $a(q_1,\ldots, q_k)$, where $k = \rank(a)$.
%A replacement rule $q_0 \to a(q_1,\ldots, q_k)$,
%of weight $\wei(q_0, a, q_1 \ldots q_k) \in \Semiring$
%according to Definition~\ref{def:SWTA},
%corresponds to the production rule $q_0 := a(q_1,\ldots, q_k)$ of a weighted CF grammar,
%with set non-terminal symbols $Q$ and set of terminal symbols $\Delta_0$.
%
%This actually is a slight generalization of CFG since
%each such production rule is labelled by  a symbol of $\Delta_{>0}$,
%hence parse trees %derivation trees
%are trees of $\T_\Delta)$.
%
%Another (more original) generalization is that the set of terminal symbols
%$\Delta_0$ may be infinite.
%
%
%The input language can also be expressed as a \SWTA, or,
%as a particular case, as a weighted context-free grammar,
%converted in turn into a \SWVPA following Lemma~\ref{lem:SWTA}.
%

\florent{In practice,
the functions in transition might be represented by diagram such as
Algebraic Decision Diagrams~\cite{Bahar97ADD}.}

%\paragraph{Application to Automated Music Transcription.}
%\input{transcription}
%...


\florent{2 lines Application to Automated Music Transcription:
implementation $\neq$ but same principle, on-the-fly automata construction
during best search, for efficiency.}


\section*{Conclusion}
% summary
We have introduced weighted language models (SW transducers and visibly pushdown automata)
computing over infinite alphabets,
and applied them to the problem of parsing
with infinitely many possible input symbols (typically timed events).
%handled with suitable language formalisms,
%
This approach extends conventional parsing and weighted parsing
by computing a derivation tree modulo
a generic distance between words,
defined by a SW transducer given in input.
This enables to consider finer word relationships than strict equality,
%as in the conventional parsing approach,
opening possibilities of quantitative analysis via this method.

% discussion
\noindent
Ongoing and future work include
\florent{TODO future work}

\noindent
-- The study of other theoretical properties of SW models,
such as the extension of the best search algorithm from $1$-best to $n$-best~\cite{Huang05kbest},
and to $k$-\emph{closed} semirings~\cite{Mohri02semiring}
(instead of \emph{bounded}, which corresponds to $0$-\emph{closed}).

\noindent
-- ...there is room to improve the complexity bounds for the algorithms
... modular approach with oracles ...

\noindent
-- present here an offline algorithm for best search,
semi-online implementation for AMT (bar-by-bar approach)
with an on-the-fly automata construction.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% BIBLIO                                                                     %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\bibliographystyle{plain}
%\bibliographystyle{abbrv}
\bibliographystyle{plainurl}  % LIPICS
%\bibliographystyle{splncs04} % LLNCS
%\bibliographystyle{eptcs}    % EPTCS
%\bibliography{generic}

\bibliography{references}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% APPENDIX                                                                   %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\appendix

\section{Properties of Label Theory Operators} \label{sec:closure}
\input{app-labels}

\section{Proof of Proposition~\ref{prop:epsilon}} \label{sec:closure}
\input{app-closure}

\section{Correctness of the Best-Search Algorithm} \label{sec:bestsearch}
\input{app-bestsearch}


\section{Nested-Words and Parse-Trees} \label{sec:trees}
\input{app-trees}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% TODO                                                                       %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\listoftodos


\end{document}
