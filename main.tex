\documentclass[a4paper,11pt]{article}
%\setcounter{page}{1}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}

\usepackage{hyperref}
%\usepackage[bookmarks,bookmarksnumbered,naturalnames,plainpages=false]{hyperref}
%usepackage{url}

% for footnote ref
\usepackage{refcount} 

% extension of enumerate env. (style for displaying counters)
% \usepackage{enumerate} 

%% pictures
% \usepackage{graphicx} 
% \DeclareGraphicsExtensions{.pdf,.png,.jpg}
% \graphicspath{fig/}

%% PGF, Tikz
%% \usepackage{pgfplots}
%% \usepgfplotslibrary{dateplot}
%% \usepackage{pgf,pgfarrows,pgfnodes, pgfautomata}
% \usepackage{tikz}
%% \usetikzlibrary{arrows}
%% \usetikzlibrary{calc}
%% \usetikzlibrary{snakes}
%% \usetikzlibrary{backgrounds}
% \usetikzlibrary{trees}
%% \usetikzlibrary{automata}
%% \usetikzlibrary{positioning}
%% \usetikzlibrary{matrix}
%% \usetikzlibrary{patterns}
%% \usetikzlibrary{shapes}

% symbols
\usepackage{amsmath} 
\usepackage{amssymb} 
\usepackage{amsbsy}
\usepackage{bbold}
\usepackage{latexsym}
%\usepackage{amsfonts}
\usepackage{stmaryrd}
%\usepackage{mathabx}
%\usepackage{MnSymbol}
\usepackage{harmony} % simple music fonts
\usepackage{mathtools} % for arrows
%\usepackage{mathptmx}

%% theorem envs
\usepackage{theorem}
\newtheorem{theorem}{Theorem} %[section]
\newtheorem{definition}[theorem]{Definition}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{proposition}[theorem]{Proposition}
\newenvironment{proof}{\vspace{-2ex}{\it Proof. }}{\hspace*{\fill} $\Box$\smallskip }
\theorembodyfont{\slshape}
\newtheorem{example}[theorem]{Example}
\newtheorem{remark}[theorem]{Remark}
{\theorembodyfont{\rmfamily} \theoremstyle{break} \newtheorem{algo}{Algorithm}}

%% algorithms
%\usepackage{algorithm} 
%\usepackage{program} 

%% for new macros
\usepackage{xspace}

%% arrows etc
%\input{rewriting}

%% Misc macros

\def\ie{\textit{i.e.}\xspace}
\def\eg{\textit{e.g.}\xspace}
\def\wrt{\textit{wrt}\xspace}
%\def\wlog{\textit{wlog}\xspace}
\def\etc{\textit{etc}\xspace}

\def\<#1>{\langle #1 \rangle}
\newcommand{\pair}[2]{\langle{#1}, {#2}\rangle}
%\newcommand{\A}{\mathcal{A}}
%\newcommand{\B}{\mathcal{B}}
\newcommand{\D}{\mathbb{D}}
\newcommand{\E}{\mathbb{E}}
\newcommand{\W}{\mathbb{W}}

\newcommand{\Semiring}{\mathbb{S}}
\newcommand{\zero}{\mathbb{0}}
\newcommand{\one}{\mathbb{1}}
\newcommand{\dom}{\ensuremath{\mathit{dom}}}

\def\SWT{\textsf{SWT}\xspace}
\def\SWA{\textsf{SWA}\xspace}
\def\SWVPA{\textsf{SWVPA}\xspace}
\def\weight{\mathsf{weight}}
\def\wei{\mathsf{w}}
\def\init{\mathsf{in}}
\def\final{\mathsf{out}}
\newcommand{\call}[1]{\ensuremath #1} %{\ensuremath \langle_{#1}}
\newcommand{\return}[1]{\ensuremath #1} %{\ensuremath {}_{#1}{\rangle}} % $\prescript{}{a}{)}$
\def\Sigmai{{\Sigma_\mathsf{i}}}
\def\Sigmac{{\Sigma_\mathsf{c}}}
\def\Sigmar{{\Sigma_\mathsf{r}}}
\def\Deltai{{\Delta_\mathsf{i}}}
\def\Deltac{{\Delta_\mathsf{c}}}
\def\Deltar{{\Delta_\mathsf{r}}}
\def\Phii{{\Phi_\mathsf{i}}}
\def\Phic{{\Phi_\mathsf{c}}}
\def\Phir{{\Phi_\mathsf{r}}}
\def\Phicr{{\Phi_\mathsf{cr}}}
\def\weii{{\wei_\mathsf{i}}}
\def\weic{{\wei_\mathsf{c}}}
\def\weir{{\wei_\mathsf{r}}}
\def\weie{{\wei_\mathsf{e}}}
\newcommand{\config}[2]{\ensuremath \genfrac{[}{]}{0pt}{}{#1}{#2}} 
\newcommand{\opluseq}{\ensuremath\mathrel{\oplus}=}
\newcommand{\ioi}[1]{\mathsf{ioi}({#1})}

%\sloppy

% Parsing over infinite alphabet as optimal alignment computation 
% as edit-distance between string and language
% Symbolic Parsing
\title{Weighted Visibly Pushdown Automata\\ Application to Automated Music Transcription}
\author{Florent Jacquemard}
%\institute{INRIA \& CNAM, Paris, France\\
%\email{florent.jacquemard@inria.fr}}

%\titlerunning{WVPA \& AMT}
%\authorrunning{Florent Jacquemard}

\date{\today}
 
\begin{document}
\thispagestyle{empty}
\maketitle

%\begin{abstract}
%Symbolic Weighted (SW) extension of symbolic automata...
%\end{abstract}

problem
quantitative parsing 
or symbolic parsing
parsing of words over infinite input alphabet.

generalizes weighted parsing: 
finding the best derivation for a weighted grammar.

model of weighted CFG over infinite set of terminal symbol
(but finite set non-terminals and production rules).
in production rules, terminal symbols appear as variables (parameters)
and the weight associated to the production rule is a function of these variables.
It is the approach of Symbolic Automata, except that the domain of weight values 
is not restricted to be Boolean, like  for the guards in the rules of SA, 
but can be an arbitrary commutative semiring (assuming some restrictions).

wrt an edit distance

we consider a strictly restricted model of weighted grammars : VPA 
and general edit-distances that can be defined by a weighted word transducer





\section{SW Automata and Transducers}
\label{section:transducer}

We follow the approach of~\cite{Mohri03EDWA} for the computation of distances
between words with weighted transducers, and propose models of weighted automata 
and weighted transducers over infinite alphabets. 

These models generalize weighted automata and transducers over finite alphabets, see  e.g.~\cite{Mohri03EDWA}, 
by labeling each transition with a weight functions that takes the 
input and output symbols as parameters, instead of a simple weight value.
These functions are similar to the guards of symbolic automata~\cite{Veanes13ciaa}, 
but they can return values in an arbitrary semiring, 
where the latter guards are restricted to the Boolean semiring.


\subsection{Semirings}
\label{section:semiring}
We shall consider semiring domains for weight values.
%
A \emph{semiring} $\< \Semiring, \oplus, \zero, \otimes, \one>$ 
is a structure with a domain~$\Semiring$,
equipped with two associative
binary operators~$\oplus$ and $\otimes$
with respective neutral elements $\zero$ and $\one$ and such that:
%$\< \mathbb{S}, \oplus, \zero>$ is a commutative monoid
%$\< \mathbb{S}, \otimes, \one>$ is a monoid
$\oplus$ is commutative, 
$\otimes$ distributes over~$\oplus$:  $\forall x, y, z \in \mathbb{S}$,
$x \otimes (y \oplus z) = (x \otimes y) \oplus (x \otimes z)$, 
%  and $(x \oplus y) \otimes z = (x \otimes z) \oplus (y \otimes z)$;
and $\zero$ is absorbing for~$\otimes$: 
$\forall x\in \mathbb{S}$, $\zero \otimes x = x \otimes \zero = \zero$.
%Components of a semiring~$\Semiring$ may be subscripted by~$\Semiring$ when needed.
%We simply write $x \in \Semiring$ to mean $x \in \mathbb{S}$.
%
% In the application presented in this paper, intuitively,
% $\oplus$ selects an optimal value amongst two values and 
% $\otimes$ combines two values into a single value.
%and let $\< \Semiring, \oplus, \zero, \otimes, \one>$ be a {semiring}, 

% \noindent
A semiring $\Semiring$ 
is \emph{monotonic} \wrt a partial ordering~$\leq$ 
iff for all $x, y, z  \in \Semiring$,  $x \leq y$ implies
$x \oplus z \leq y \oplus z$,
$x \otimes z \leq y \otimes z$
and $z \otimes x \leq z \otimes y$,
%
and it is \emph{superior} %\wrt a partial ordering~$\leq$
\wrt~$\leq$ iff for all $x, y \in \Semiring$,  
$x \leq x \otimes y$ and 
$y \leq x \otimes y$~\cite{Huang08advanceddynamic}.
The latter property corresponds to the 
\emph{non-negative weights} condition in shortest-path algorithms~\cite{Dijkstra59anote}.
Intuitively, it means that combining elements always increase their weight. 
% always get worse in term of weight
Note that when $\Semiring$ is superior \wrt~$\leq$, then $\one \leq \zero$
and moreover, for all $x \in \Semiring$, $\one \leq x \leq \zero$.

%\noindent
A semiring $\Semiring$ is \emph{commutative} if $\otimes$ is commutative.
It is \emph{idempotent} if for each $x \in \dom(\Semiring)$, $x \oplus x = x$.
%
%Following the terminology of~\cite{Mohri02semiring},
%when $\forall x \in \dom(\Semiring), \one \oplus x = \one$,
%the semiring $\Semiring$ is is called \emph{bounded}.
%Note that every bounded semiring is idempotent:
%by boundedness, 
%$\one \oplus \one = \one$, and idempotency follows by multiplying
%both sides by $x$ and distributing. 
%
Every idempotent semiring~$\Semiring$ induces 
a partial ordering~$\leq_\oplus$ 
called the \emph{natural ordering} of~$\Semiring$
and defined by: 
%implicitly defined by the semiring $\Semiring$ 
for all $x$ and $y$,
$x \leq_\oplus y \;\mbox{iff}\; x \oplus y = x$.
This ordering is sometimes defined in the opposite direction~\cite{DrosteKuich09semirings};
The above definition follows \cite{Mohri02semiring}, 
and coincides than the usual ordering on the Tropical semiring (\emph{min-plus}).
%
It holds that $\Semiring$ is {monotonic} \wrt~$\leq_\oplus$.
An idempotent semiring $\Semiring$~is called \emph{total} if
it~$\leq_\oplus$ is total
\ie when for all $x, y \in \Semiring$, either $x \oplus y = x$ or $x \oplus y = y$.

\medskip
We shall consider below infinite sums with~$\oplus$.
A semiring~$\Semiring$ is called \emph{complete} 
if for every family
$(x_i)_{i \in I}$ %$\{ x_i \mid i \in I \}$
of elements of $\dom(\Semiring)$ over an index set $I \subset \mathbb{N}$,
the infinite sum $\bigoplus_{i \in I} x_i$
is well-defined and in $\dom(\Semiring)$,
and the following properties hold:
\begin{description}
\item[$i.$]
\emph{infinite sums extend finite sums:}
$\displaystyle\bigoplus_{i \in \emptyset} x_i = \zero$,\quad 
      $\forall j\in \mathbb{N}, \displaystyle\bigoplus_{i \in \{ j \}} x_i = x_j$,\quad
      $\forall j, k\in \mathbb{N}, j\neq k, 
      \displaystyle\bigoplus_{i \in \{ j, k \}} x_i = x_j \oplus x_k$,
%
\item[$ii.$]
\emph{associativity and commutativity:}
for all $I \subseteq \mathbb{N}$
and all partition $(I_{j})_{j \in J}$ of $I$, %\subseteq \mathbb{N}$, 
\(
\displaystyle
\bigoplus_{j \in J}\bigoplus_{i \in I_j} x_i = 
\bigoplus_{i \in I} x_i
\),
%
\item[$iii.$] 
\emph{distributivity of product over infinite sum:}\\
for all $I \subseteq \mathbb{N}$,
\(
\displaystyle
\bigoplus_{i \in I} (x \otimes y_i) = x \otimes \bigoplus_{i\in I} y_i\), and
\(
\displaystyle
\bigoplus_{i \in I} (x_i \otimes y) = (\bigoplus_{i \in I} x_i ) \otimes y\).
\end{description}



\begin{example}
semirings      
\end{example}
      

\subsection{Label Theory}
\label{section:symbols}

Let $\Sigma$ and $\Delta$ be respectively an input and output \emph{alphabets}, 
which are countable (finite or infinite) sets of symbols, 
and let $\Semiring$ be a commutative semiring.

\noindent 
A \emph{label theory} over $\Sigma$ and $\Delta$
is made of 4 recursively enumerable sets:
%$\Phi_0$, \Phi_\Sigma \uplus \Phi_\Delta \uplus \Phi_{\Sigma, \Delta}$ 
$\Phi_\epsilon \subseteq \Semiring$, % containing constant functions valued in $\Semiring$, 
$\Phi_\Sigma$ and $\Phi_\Delta$, 
containing unary functions in $\Sigma \to \Semiring$, resp. $\Delta \to \Semiring$, 
and $\Phi_{\Sigma, \Delta}$  containing binary functions in $\Sigma \times \Delta \to \Semiring$.
Moreover, we assume that these sets are closed under the operators 
$\oplus$ and $\otimes$ of~$\Semiring$.
More precisely, for all $\phi, \phi' \in \Phi_\Sigma$ all 
$\psi, \psi' \in \Phi_\Delta$, 
and $\eta, \eta' \in \Phi_{\Sigma, \Delta}$, the function
\begin{description}
\item $\phi \otimes \phi' : x \mapsto \phi(x) \otimes \phi'(x)$ belongs to $\Phi_\Sigma$, 
\item $\psi \otimes \psi' : y \mapsto \psi(y) \otimes \psi'(y)$ belongs to $\Phi_\Delta$,
\item $\phi \otimes \eta : x, y \mapsto \phi(x) \otimes \eta(x, y)$ belongs to $\Phi_{\Sigma, \Delta}$,
\item $\eta \otimes \psi : x, y \mapsto \eta(x, y) \otimes \psi(y)$ belongs to $\Phi_{\Sigma, \Delta}$,
\item $\eta \otimes \eta' : x, y \mapsto \eta(x, y) \otimes \eta'(x, y)$ belongs to $\Phi_{\Sigma, \Delta}$.
\end{description}
The same also holds for the binary sum operator $\oplus$.

\noindent
\marginpar{necessary?}
Finally, it is assumed that the codomain of every function of $\Phi_\Sigma$ and $\Phi_\Delta$
is a subset of $\Phi_\epsilon$.
and all partial applications of functions $\Phi_{\Sigma, \Delta}$, 
resp.  $f_a: y \mapsto f(a, y)$ for $a \in \Sigma$ and $y \in \Delta$
and  $f_b: x \mapsto f(x, b)$ for $b \in \Delta$ and $x \in \Sigma$, 
belong resp. to $\Phi_\Sigma$ and $\Phi_\Delta$.


\subsection{Definitions}
%(SWT)
\begin{definition}
A \emph{symbolic-weighted transducer} $T$ over the input and output alphabet $\Sigma$ and $\Delta$ 
and the semiring $\Semiring$ is a tuple
$T = \< Q, \init, \wei, \final >$,
where $Q$ is a finite set of states, 
$\mathsf{in} : Q \to \Semiring$, 
respectively $\mathsf{out} : Q \to \Semiring,$
are functions defining the weight for entering, 
respectively leaving, a state, 
and $\wei$ is a transition %weight 
function from $Q \times Q$ into %$\Phi$.
$\< \Phi_\epsilon, \Phi_\Sigma, \Phi_\Delta, \Phi_{\Sigma, \Delta}>$.
\end{definition}
%
We extend the above transition function into a function from
$Q \times (\Sigma \cup \{ \epsilon \}) \times (\Delta \cup \{ \epsilon \}) \times Q$
into $\Semiring$, also called $\wei$ for simplicity, such that 
for all $q, q' \in Q$, $a \in \Sigma$, $b \in \Delta$, 
and with 
$\< \phi_\epsilon, \phi_\Sigma, \phi_\Delta, \phi_{\Sigma, \Delta}> = \wei(q, q')$, 
\[
\begin{array}{rcl}
\wei(q, \epsilon, \epsilon, q') & = & \phi_\epsilon\\
\wei(q, a, \epsilon, q') & = & \phi_\Sigma(a)\\
\wei(q, \epsilon, b, q') & = & \phi_\Delta(b)\\
\wei(q, a, b, q') & = & \phi_{\Sigma, \Delta}(a, b)
\end{array}      
\]
%More precisely, $Q \times Q$, 
%resp. $Q \times \Sigma \times Q$,
%$Q \times \Delta \times Q$,
%$Q \times \Sigma \times \Delta \times Q$,
%into resp. $\Phi_0$, $\Phi_\Sigma$, $\Phi_\Delta$ $\Phi_{\Sigma, \Delta}$.

These functions $\phi$ act as guards for the transducer's transitions, 
preventing a transition when they return the absorbing $\zero$ of $\Semiring$.

The symbolic-weighted transducer $T$ defines a mapping 
from the pairs of strings of $\Sigma^* \times \Delta^*$ 
into the weights of~$\Semiring$,
based on the following intermediate function $\weight_T$
defined recursively for every $q, q' \in Q$, 
%$a \in \Sigma$, $b \in \Delta$ 
for every strings of $s \in \Sigma^*$, $t \in \Delta^*$:
\[
\begin{array}{rccl}
\weight_T(q, s, t, q') & = & & \wei(q, \epsilon, \epsilon, q')\\
 & & \oplus \displaystyle\bigoplus_{\begin{array}{c}
                                      \scriptstyle q'' \in Q\\[-2pt]
                                      \scriptstyle s = au, a \in \Sigma
                                      \end{array}} &
     \wei(q, a, \epsilon, q'') \otimes \weight_T(q'', u, t, q')\\
 & & \oplus \displaystyle\bigoplus_{\begin{array}{c}
                                    \scriptstyle q'' \in Q\\[-2pt]
                                    \scriptstyle t = bv, b \in \Delta
                                    \end{array}} &
      \wei(q, \epsilon, b, q'') \otimes \weight_T(q'', s, v, q')\\ 
      & & \oplus \displaystyle\bigoplus_{\begin{array}{c}
                                         \scriptstyle q'' \in Q\\[-2pt]
                                         \scriptstyle s = au, a \in \Sigma\\[-2pt]
                                         \scriptstyle t = bv, b \in \Delta
                                         \end{array}} &
      \wei(q, a, b, q'') \otimes \weight_T(q'', u, v, q')\\ 
\end{array}
\]
Recall that by convention, an empty sum with $\oplus$ is $\zero$. 
%
\noindent
The weight associated by $T$ to  $\< s, t> \in \Sigma^* \times \Delta^*$
is then defined as follows: 
\[
T(s, t)  = 
\displaystyle\bigoplus_{q, q' \in Q} \mathsf{in}(q) 
\mathop{\otimes} \weight_T(q, s, t, q') \mathop{\otimes} \mathsf{out}(q').
\]

\begin{example}
comparison of two sequences of timestamped events      
\end{example}

\noindent
A \emph{symbolic weighted automata} (\SWA) $A = \< Q, \init, \weight, \final >$
over $\Sigma$ and $\Semiring$ 
is defined in a similar way by simply omitting the output symbols,
\ie $\wei$ is a function from~$Q \times Q$ into %$\Phi$.
$\< \Phi_\epsilon, \Phi_\Sigma >$, 
or equivalently from~$Q \times (\Sigma \cup \{ \epsilon \}) \times Q$ into~$\Semiring$.

      


\subsection{Properties}

\begin{proposition}
Given a \SWT $T$ 
over $\Sigma$, $\Delta$ and $\Semiring$, 
and a word $s \in \Sigma^*$, 
one can construct a \SWA 
$A_{s, T}$ such that for all $t \in \Delta^*$, 
$A_{s, T}(t) = T(s, t)$.
\end{proposition}
The construction time and size for $A_{s, T}$ are $O(| s | . \| T \|)$.



\begin{proposition}
      ...removal of $\epsilon$ transitions for \SWA...
      \end{proposition}
      
      


\section{SW Visibly Pushdown Automata}
\label{section:SWVPA}
The following model generalizes Symbolic VPA~\cite{DAntonyAlur14SVPDA}
from Boolean semirings to arbitrary semiring weight domains.

\subsection{Definition}
Let $\Sigma$ be a countable alphabet 
%finite (large) or infinite,
that we assume partitioned into three subsets 
$\Sigmai \uplus \Sigmac \uplus \Sigmac$ 
respectively called of \emph{internal}, \emph{call} and \emph{return}
symbols.
% \begin{itemize}
% \item a set $\Sigmai$ of \emph{internal symbols} denoted $a$,
% \item a set $\Sigmac$ of \emph{call symbols} denoted $\call{a}$,
% \item a set $\Sigmar$ of \emph{return symbols} denoted $\return{a}$.
% \end{itemize}
Let $\Semiring$ be a commutative semiring and  
let  $(\Phi_\epsilon, \Phic, \Phir, \Phicr)$ be a label theory over $\Semiring$
%In order to simplify notations, %and following the definition of Section~\ref{section:transducer}, 
%we shall write respectively 
where $\Phic$, $\Phir$ and~$\Phicr$ stand respectively 
for~$\Phi_\Sigmac$, $\Phi_\Sigmar$ and~$\Phi_{\Sigmac, \Sigmar}$.
%
Moreover, we extend this theory with a set $\Phii$ 
of unary functions in $\Sigmai \to \Semiring$,
closed under $\oplus$ and $\otimes$.

\begin{definition}
A \emph{Symbolic Weighted Visibly Pushdown Automata} (\SWVPA)~$A$ 
over  $\Sigma = \Sigmai \uplus \Sigmac \uplus \Sigmar$ and $\Semiring$ is a tuple
$T = \< Q, P, \init, \weii, \weic, \weir, \weie, \final >$,
where $Q$ is a finite set of states, 
$P$ is a finite set of stack symbols, 
$\mathsf{in} : Q \to \Semiring$, 
respectively $\mathsf{out} : Q \to \Semiring,$
are functions defining the weight for entering, 
respectively leaving, a state, 
and 
$\weii : Q \times Q \to \Phii$,  
$\weic : Q \times Q \times P \to \Phic$,  
$\weir : Q \times P \times Q \to \Phicr$,  
$\weie : Q \times Q \to \Phir$,  
are transition functions.
\end{definition}
%
Similarly as in Section~\ref{section:transducer}, 
we extend the above transition functions as follows
for all $q, q' \in Q$, $p \in P$, 
$a \in \Sigmai$, 
$\call{c} \in \Sigmac$, 
$\return{r} \in \Sigmar$, 
overloading their names: % for simplicity:
\[
\begin{array}{lll}
\weii: Q \times \Sigmai \times Q \to \Semiring & 
\weii(q, a, q') = \phi_\mathsf{i}(a) & 
\mathrm{where~} \phi_\mathsf{i} = \weii(q, q'),\\
%
\weic: Q \times \Sigmac \times Q \times P \to \Semiring & 
\weic(q, \call{c}, q', p) = \phi_\mathsf{c}(\call{c}) & 
\mathrm{where~} \phi_\mathsf{c} = \weic(q, q', p),\\
%
\weir: Q \times \Sigmac \times P \times \Sigmar \times Q \to \Semiring & 
\weir(q, {\call{c}},  p, {\return{r}}, q') = \phi_\mathsf{r}({\call{c}},  {\return{r}}) & 
\mathrm{where~} \phi_\mathsf{r} = \weir(q, p, q'),\\
%
\weie: Q \times \Sigmar \times Q \to \Semiring & 
\weie(q, {\return{r}}, q') = \phi_\mathsf{e}({\return{r}}) &
\mathrm{where~} \phi_\mathsf{e} = \weie(q, q').\\
\end{array}      
\]

\noindent
The intuition is the following for the above transitions.
\begin{description}
\item $\weii$ : read the input internal symbol $a$, change state to $q'$.
\item $\weic$ : read the input call symbol $\call{c}$, push it to the stack along with $p$, change state to $q'$.
\item $\weir$ : when the stack is not empty, 
      read and pop from stack a pair made of $\call{c}$ and $p$, 
      read the input return symbol $\return{r}$, change state to $q'$.
      In this case, the weight function $\phi_\mathsf{r}$ 
      computes a value of matching between the call and return symbols.
      This value might be $\zero$ in order to express that the symbols do not match.
\item $\weie$ : when the stack is empty, 
      read the input symbol $\call{r}$, change state to $q'$.
\end{description}

We give now a formal definition of these transitions of the automaton $A$
in term of a weight value
computed by an intermediate function $\weight_A$.
In the case of a pushdown automaton, a configuration is composed 
of a state $q \in Q$ and a stack content $\theta \in \Theta^*$, where $\Theta = \Sigmac \times P$.
Therefore, $\weight_A$ is a function from 
$Q \times \Theta^* \times \Sigma^* \times Q \times \Theta^*$ into $\Semiring$.
\[
\begin{array}{rcl}
\weight_A\bigl(\config{q}{\theta}, a\, u, \config{q'}{\theta'}\bigr) & = & 
 {\displaystyle\bigoplus_{q'' \in Q}} \weii(q, a, q'') 
 \otimes \weight_A\bigl(\config{q''}{\theta}, u, \config{q'}{\theta'}\bigr)\\
%
\weight_A\bigl(\config{q}{\theta}, {\call{c}}\, u, \config{q'}{\theta'}\bigr) & = & 
 {\displaystyle\bigoplus_{\begin{array}{c}
                          \scriptstyle q'' \in Q\\[-2pt]
                          \scriptstyle p \in P
                          \end{array}}}
 \weic\bigl(q, {\call{c}}, q'', p\bigr) 
 \otimes \weight_A\bigl(\config{q''}{{\call{c}}\, p\cdot \theta}, u, \config{q'}{\theta'}\bigr)\\[1mm]
%
\weight_A\bigl(\config{q}{{\call{c}}\, p\cdot \theta}, {\return{r}}\, u, \config{q'}{\theta'}\bigr) & = & 
 {\displaystyle\bigoplus_{q'' \in Q}} 
 \weir\bigl(q, {\call{c}}, p, {\return{r}}, q''\bigr) 
 \otimes \weight_A\bigl(\config{q''}{\theta}, u, \config{q'}{\theta'}\bigr)\\
%
\weight_A\bigl(\config{q}{\bot}, {\return{r}}\, u, \config{q'}{\theta'}\bigr) & = & 
 {\displaystyle\bigoplus_{q'' \in Q}} \weie(q, {\return{r}}, q'') 
 \otimes \weight_A\bigl(\config{q''}{\bot}, u, \config{q'}{\theta'}\bigr)\\
\end{array}
\]
where $\bot$ denotes the empty stack and ${\call{c}}\, p\cdot \theta$ 
denotes a stack with the pair made of ${\call{c}}$ and $p$ on its top and $\theta$
as the rest of stack.

\noindent
The weight associated by $A$ to $s \in \Sigma^*$
is then defined as follows,
following empty stack semantics: 
\[
A(s)  = 
{\displaystyle\bigoplus_{q, q' \in Q}} \textstyle
\mathsf{in}(q) \mathop{\otimes} 
\weight_A\bigl(\config{q}{\bot}, s, \config{q'}{\bot}\bigr) 
\mathop{\otimes} \mathsf{out}(q').
\]


\begin{example}
structured words...
intro language of music notation ?
\end{example}


\subsection{Properties}
SWVPA are closed under the binary operators of the underlying semiring.
%
\begin{proposition}
Let $A_1$ and $A_2$ be two (\SWVPA)
over the same $\Sigma$ and $\Semiring$.
There exists two $\SWVPA$ $A_1 \oplus A_2$ and $A_1 \otimes A_2$, 
effectively constructible, 
such that for all $s \in \Sigma^*$, 
$(A_1 \oplus A_2)(s) = A_1(s) \oplus A_2(s)$ and 
$(A_1 \otimes A_2)(s) = A_1(s) \otimes A_2(s)$.
\end{proposition}
The construction is essentially the same 
as the one of~\cite{DAntonyAlur14SVPDA}, in the case of the Boolean semiring.


\subsection{1-best Computation}
Assume that the semiring $\Semiring$ is commutative, idempotent, and complete.
% total ? 
% monotonic and superior writ natural ordering
...
%Regarding the infinite sum operator, note that
%$\bigoplus_{x \in \Phi_\Sigma} \phi(x)$, 
%$\bigoplus_{y \in \Phi_\Delta} \psi(y)$, and  
%... exist and in $\Semiring$.

We propose a Dijkstra algorithm computing the minimal weight, 
by $A$ for a word in $\Semiring^*$.
It runs by labeling iteratively all pair $\<q, q'>$ of states of $A$ 
by weight values in $\Semiring$, 
in order to converge to 
$\bigoplus_{s \in \Sigma^*} \weight_A\bigl(\config{q}{\bot}, s, \config{q'}{\bot}\bigr)$.
%
More precisely, we compute a marking $d : Q \times \{ \bot, \top \} \times Q$
such that eventually:
$d(q, \sigma ,q') = \bigoplus_{s \in \Sigma^*} \weight_A\bigl(\config{q}{\sigma}, s, \config{q'}{\sigma}\bigr)$
where $\sigma \in \{ \bot, \top \}$, and $\top$ is a fresh stack symbol which does not belong to $\Theta$.
Note that having a stack reduced to such a symbol makes impossible the application of the 
two last cases in the definition of $\weight_A$ (return symbol and empty stack). 
However, it is possible to apply the two first cases 
(internal symbol or call symbol, with a push on the top of $\top$).
Algorithm~\ref{algo:Dijkstra} uses a priority queue $P$. 

\begin{algo}[1-best for SWVPA] \label{algo:Dijkstra}
\textbf{initially} $P$ contains all %triplets 
$\< q_1, \bot, q_2>$ and $\<q_1, \top, q_2>$
for $q_1, q_2 \in Q$, with 
$d(q_1, \bot, q_2) = d(q_1, \top, q_2) = \one$ if $q_1 = q_2$ and
$d(q_1, \bot, q_2) = d(q_1, \top, q_2) = \zero$ otherwise.

\smallskip\noindent
\textbf{while} $P$ is not empty

\noindent
\quad\textbf{extract} $\< q_1, \sigma, q_2>$ from $P$ 
 such that $d(q_1, \sigma, q_2)$ is minimal wrt $\leq_\oplus$.

\noindent\quad \textbf{for all} $q_0, q_3 \in Q$ and $p \in P$ do

\noindent
\qquad
\(\begin{array}{rrcl}
 & d(q_1, \sigma, q_3) & \opluseq &
   d(q_1, \sigma, q_2) \otimes \displaystyle\bigoplus_{a \in \Sigmai} \weii(q_2, a, q_3)\\
%
%  & d(q_0, \sigma, q_2) & \opluseq & 
%    \displaystyle\bigoplus_{a \in \Sigmai} \weii(q_0, a, q_1) \otimes d(q_1, \sigma, q_2)\\
%
\mathrm{if~} \sigma = \top & d(q_0, \top, q_3) & \opluseq &
d(q_1, \sigma, q_2) \otimes
%\displaystyle\bigoplus_{p \in P} 
\displaystyle\bigoplus_{{\call{c}} \in \Sigmac} 
\displaystyle\bigoplus_{{\return{r}} \in \Sigmar} \eta({\call{c}}, {\return{r}})\\
\mathrm{and} &  d(q_0, \bot, q_3) & \opluseq &
d(q_1, \sigma, q_2) \otimes
%\displaystyle\bigoplus_{p \in P} 
\displaystyle\bigoplus_{{\call{c}} \in \Sigmac} 
\displaystyle\bigoplus_{{\return{r}} \in \Sigmar} \eta({\call{c}}, {\return{r}})\\
& & & \mathrm{where~} \eta = \weic(q_0, q_1, p) \otimes \weir(q_2, p, q_3)\\
%
\mathrm{if~} \sigma = \bot & d(q_1, \bot, q_3) & \opluseq &
 d(q_1, \sigma, q_2) \otimes \displaystyle\bigoplus_{\return{r} \in \Sigmar} \weie(q_2, {\return{r}}, q_3)\\
%
& d(q_0, \bot, q_2) & \opluseq & 
d(q_0, \bot, q_1) \otimes d(q_1, \sigma, q_2), \mathrm{if~} \< q_0, \bot, q_1> \notin P \\
%
\mathrm{if~} \sigma = \top & d(q_0, \top, q_2) & \opluseq & 
d(q_0, \top, q_1) \otimes d(q_1, \sigma, q_2), \mathrm{if~} \< q_0, \top, q_1> \notin P \\
%
& d(q_1, \bot, q_3) & \opluseq & 
   d(q_1, \sigma, q_2) \otimes d(q_2, \bot, q_3), \mathrm{if~} \< q_2, \bot, q_3> \notin P \\
%
\mathrm{if~} \sigma = \top & d(q_1, \top, q_3) & \opluseq & 
    d(q_1, \sigma, q_2) \otimes d(q_2, \top, q_3), \mathrm{if~} \< q_2, \top, q_3> \notin P \\
\end{array}
\) 
\end{algo}

\noindent
The infinite sums in the updates of $d$ in Algorithm~\ref{algo:Dijkstra} are well defined
since~$\Semiring$ is complete.


% \begin{algorithm}
% \caption{<your caption for this algorithm>}
% \label{<your label for references later in your document>}
% \begin{program}
% \seq{|line| := `` '', i := 1};
% \WHILE i \neq n+1 \DO
%       |line| := |item|[i] \concat `` '' \concat |number|[i]; 
%       i := i+1; 
%       \WHILE i \neq n+1 \AND |item|[i] = |item|[i-1] \DO 
%       |line| := |line| \concat ``, '' \concat |number|[i]);
%       i := i+1 \OD ; 
%       |write|(|line|) \OD 
% \end{program}
% \end{algorithm}


% The weight of a transition acts as a guard: 
% a transition is activated for a symbol $`a`$ iff its weight $`\phi(a) \neq 0`$ (or $`\psi(a, b) \neq 0`$), 
% the absorbing element.

\medskip
In order to obtain effectively a word of $\Semiring^*$ of minimal weight, 
we require an additional 
property of bounded convexity of weight functions:





\section{Application}
Symbolic Automated Music Transcription
and analysis of music performances

\subsection{Time Scales}
Real-Time Unit (RTU) = seconds

\noindent 
Musical-Time Unit (MTU) = number of measures

\noindent 
conversion via tempo value

\subsection{Representation of Music Performances}
We consider symbolic representation of musical performances, as finite sequences of events.
It corresponds to the concrete case of a MIDI file~\cite{SMF} 
recorded  from an electronic keyboard, 
or the output of a transcription from audio files~\cite{Benetos18AMTsurvey}.
%
For the sake of simplicity, we shall only consider here the case of monophonic performances, 
where at most one note is sounding at a time -- the approach however extends to the polyphonic case.

A music performance is a finite sequence of events in a set $\Sigma$.
Every event $e \in \Sigma$ has attributes such from a finite domain, 
like a number of key for a note 
or a flag indicating that it is a rest 
(\textsf{ON} and \textsf{OFF} messages in~\cite{SMF})
and a velocity value (0..127 in~\cite{SMF})).
%This representation is similar to the piano roll ~\cite{Muller15fundamentals} chap.1. 
Moreover, it contains a RTU value $\ioi{e}$ (real number) 
representing the time distance to the next event, or the to the end of performance 
(also called \emph{inter-onset interval}).


\subsection{Representation of Music Scores}
Music score are represented as structured words
made of quantified events and parenthesized markups,
akin of nested words~\cite{AlurMadhusudan09nested}.

We consider an alphabet $\Delta$, every symbol of which is 
composed of a tag, in a finite set $\Xi$, 
and an MTU (rational) IOI duration value.
The alphabet $\Delta$ is partitioned into 
$\Delta = \Deltai \uplus \Deltac \uplus \Deltar$, 
like in Section~\ref{section:SWVPA}.
%
\noindent
The symbols of $\Deltai$ represent events:
% (infinite alphabet of internal symbols) made of:
with tags indicate a new note or grace-note (with null IOI), 
a rest or the continuation of the previous note (tie or dot).
The elements of $\Deltac \uplus \Deltar$ are matched
and are the markups for describing the structure of the score.


\noindent
The elements of $\Deltac$ and $\Deltar$ are 
markups for the representation of groups of events
(linearization of rhythm trees \cite{jacquemard:hal-01138642}...)
- parentheses for time divisions : tuplets, bars...
tag %labels: 
contain info such as tuple number, beaming policy...

\noindent
The date or duration of events, in MTU (rational), 
can be computed with the markups and tags (e.g. grace note has duration 0).

\noindent
There are simultaneous events, since grace notes has duration 0. They are ordered.

\noindent
Finite bound on the number of duration ratio. ?


\subsection{Performance/Score Distance Computation}
with a transducer


tempo value in a finite domain (e.g. 30..300 bpm)
can be fixed 
or recomputed by the transducer when reading each event, 
according to a perceptive/cognitive model of tempo 
such as~\cite{LargeJones99tempo}
(also used in the context of score following~\cite{Cont10TPAMI}).
% we wont detail here.






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% BIBLIO                                                                     %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\bibliographystyle{plain}
%\bibliographystyle{plainurl} 
\bibliographystyle{abbrv}
%\bibliographystyle{splncs04}
\bibliography{references}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% APPENDIX                                                                   %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\appendix 

\section{Edit-Distance}

%\subsection{Distance between words or languages}
...algebraic definition of edit-distance of Mohri, in \cite{Mohri03EDWA}
% Mehryar Mohri 
% Edit-distance of weighted automata: General definitions and algorithms
% International Journal of Foundations of Computer Science 14.06 (2003): 957-982.
distance $d$ over $\Sigma^* \times \Sigma^*$ 
into a semiring  $\Semiring = ( \Semiring, \oplus, \zero, \otimes, \one)$.

%\noindent
Let $\Omega = \Sigma \cup \{ \epsilon \} \times \Sigma \cup \{ \epsilon \} \setminus \{ (\epsilon, \epsilon) \}$,
and let $h$ be the morphism from $\Omega^*$ into $\Sigma^* \times \Sigma^*$  
defined over the concatenation of strings of $\Sigma^*$ (that removes the $\epsilon$'s).
%
\noindent
An \emph{alignment} between 2 strings  $s, t \in \Sigma^*$ is an element $\omega \in \Omega^*$ 
such that $h(\omega) = (s, t)$.
%
\noindent
We assume a base cost function $\Omega$ : $\delta: \Omega \to S$, extended to $\Omega^*$ as follows  
(for $\omega \in \Omega^*$): 
\(
\displaystyle\delta(\omega) = \bigotimes_{0 \leq i < |\omega|} \delta(\omega_i)
\).

\noindent
\begin{definition}
For  $s, t \in \Sigma^*$, the edit-distance between $s$ and $t$ is  
\( 
d(s, t) = \displaystyle\bigoplus_{\omega \in \Omega^*\, h(\omega) = (s, t)} \delta(\omega)
\).
\end{definition}

e.g. Levenstein edit-distance: $S$ is min-plus and $\delta(a, b) = 1$ for all $(a, b) \in \Omega$.


%\paragraph{Distance between a word and a regular language}


\end{document}

