\documentclass[runningheads]{llncs}
%\documentclass[a4paper,11pt]{article}
%\setcounter{page}{1}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}

\usepackage{hyperref}
%\usepackage[bookmarks,bookmarksnumbered,naturalnames,plainpages=false]{hyperref}
%usepackage{url}

% for footnote ref
\usepackage{refcount} 

% extension of enumerate env. (style for displaying counters)
% \usepackage{enumerate} 

%% pictures
% \usepackage{graphicx} 
% \DeclareGraphicsExtensions{.pdf,.png,.jpg}
% \graphicspath{fig/}

%% PGF, Tikz
%% \usepackage{pgfplots}
%% \usepgfplotslibrary{dateplot}
%% \usepackage{pgf,pgfarrows,pgfnodes, pgfautomata}
% \usepackage{tikz}
%% \usetikzlibrary{arrows}
%% \usetikzlibrary{calc}
%% \usetikzlibrary{snakes}
%% \usetikzlibrary{backgrounds}
% \usetikzlibrary{trees}
%% \usetikzlibrary{automata}
%% \usetikzlibrary{positioning}
%% \usetikzlibrary{matrix}
%% \usetikzlibrary{patterns}
%% \usetikzlibrary{shapes}

% symbols
\usepackage{amsmath} 
\usepackage{amssymb} 
\usepackage{amsbsy}
\usepackage{bbold}
\usepackage{latexsym}
%\usepackage{amsfonts}
\usepackage{stmaryrd}
%\usepackage{mathabx}
%\usepackage{MnSymbol}
\usepackage{harmony} % simple music fonts
\usepackage{mathtools} % for arrows
%\usepackage{mathptmx}

%% theorem envs
\usepackage{theorem}
% \newtheorem{theorem}{Theorem} %[section]
% \newtheorem{definition}[theorem]{Definition}
% \newtheorem{lemma}[theorem]{Lemma}
% \newtheorem{corollary}[theorem]{Corollary}
% \newtheorem{proposition}[theorem]{Proposition}
% \newenvironment{proof}{\vspace{-2ex}{\it Proof. }}{\hspace*{\fill} $\Box$\smallskip }
% \theorembodyfont{\slshape}
% \newtheorem{example}[theorem]{Example}
% \newtheorem{remark}[theorem]{Remark}
{\theorembodyfont{\rmfamily} \theoremstyle{break} \newtheorem{algo}{Algorithm}}

%% algorithms
%\usepackage{algorithm} 
%\usepackage{program} 

%% for new macros
\usepackage{xspace}

%% arrows etc
%\input{rewriting}

%% Misc macros

\def\ie{\textit{i.e.}\xspace}
\def\eg{\textit{e.g.}\xspace}
\def\wrt{\textit{wrt}\xspace}
%\def\wlog{\textit{wlog}\xspace}
\def\etc{\textit{etc}\xspace}

\def\<#1>{\langle #1 \rangle}
\newcommand{\pair}[2]{\langle{#1}, {#2}\rangle}
%\newcommand{\A}{\mathcal{A}}
%\newcommand{\B}{\mathcal{B}}
\newcommand{\D}{\mathbb{D}}
\newcommand{\E}{\mathbb{E}}
\newcommand{\W}{\mathbb{W}}

\newcommand{\Semiring}{\mathbb{S}}
\newcommand{\zero}{\mathbb{0}}
\newcommand{\one}{\mathbb{1}}
\newcommand{\dom}{\ensuremath{\mathit{dom}}}

\def\SWT{\textsf{swT}\xspace}
\def\SWA{\textsf{swA}\xspace}
\def\SWVPA{\textsf{sw-VPA}\xspace}
\def\weight{\mathsf{weight}}
\def\wei{\mathsf{w}}
\def\init{\mathsf{in}}
\def\final{\mathsf{out}}
\newcommand{\call}[1]{\ensuremath #1} %{\ensuremath \langle_{#1}}
\newcommand{\return}[1]{\ensuremath #1} %{\ensuremath {}_{#1}{\rangle}} % $\prescript{}{a}{)}$
\def\Sigmai{{\Sigma_\mathsf{i}}}
\def\Sigmac{{\Sigma_\mathsf{c}}}
\def\Sigmar{{\Sigma_\mathsf{r}}}
\def\Deltai{{\Delta_\mathsf{i}}}
\def\Deltac{{\Delta_\mathsf{c}}}
\def\Deltar{{\Delta_\mathsf{r}}}
\def\Phii{{\Phi_\mathsf{i}}}
\def\Phic{{\Phi_\mathsf{c}}}
\def\Phir{{\Phi_\mathsf{r}}}
\def\Phicr{{\Phi_\mathsf{cr}}}
\def\weii{{\wei_\mathsf{i}}}
\def\weic{{\wei_\mathsf{c}}}
\def\weir{{\wei_\mathsf{r}}}
\def\weie{{\wei_\mathsf{e}}}
\newcommand{\config}[2]{\ensuremath \genfrac{[}{]}{0pt}{}{#1}{#2}} 
\newcommand{\opluseq}{\ensuremath\mathrel{\oplus}=}
\newcommand{\ioi}[1]{\mathsf{ioi}({#1})}

%\sloppy

% Parsing over infinite alphabet as optimal alignment computation 
% as edit-distance between string and language
% 
%\title{Symbolic Weighted Parsing and Automated Music Transcription}
%\title{Symbolic Weighted Language Models and Automated Music Transcription}
\title{Symbolic Weighted Language Models and Parsing over Infinite Alphabets}
%\title{Weighted Visibly Pushdown Automata and Automated Music Transcription}
\author{Florent Jacquemard}
\institute{INRIA \& CNAM, Paris, France\\
\email{florent.jacquemard@inria.fr}}

%\titlerunning{WVPA \& AMT}
\titlerunning{Symbolic Weighted Parsing and Automated Music Transcription}
%\authorrunning{Florent Jacquemard}

\date{\today}
 
\begin{document}
\thispagestyle{empty}
\maketitle

\begin{abstract}
%Symbolic Weighted (SW) extension of symbolic automata...

We propose language models called Symbolic Weighted Automata (SWA) 
at the joint %intersection 
between Symbolic Automata (SA) and Weighted Automata (WA), 
as well as Transducers (SWT) and Visibly Pushdown (SWPDA) variants.
%
Like SA, SWA deal with large or infinite input alphabets, 
and like WA, they output a weight value in a semiring domain.
The transitions of WA are labeled by functions from an infinite alphabet into the weight domain. 
This is unlike WA whose transitions are guarded by boolean predicates 
overs symbols in an infinite alphabet 
and also unlike WA whose transitions are labeled by constant weight values, 
and who deal only with finite automata.
%
We present some properties of WA, WT and SWPDA models, 
%and show how they can be used 
that we use to define and solve a variant of parsing 
over infinite alphabets.
%
We also briefly describe the application that motivated the introduction of these models: 
an parse-based approach to automated music transcription.
\end{abstract}




%the problem: quantitative parsing or symbolic parsing
%of parsing of words over infinite input alphabet.
Weighted parsing~\cite{Goodman99SemiringParsing,Nederhof03weightedParsing,MorbitzVogler19weighted-parsing} 
consists in analyzing a word in input \wrt a weighted language model, \eg a probabilistic context-free grammar (CFG).
In such models, a weight value is associated to each transition rule, % production rule
and the rule's weights can be combined with a associative product operator $\otimes$ into 
the weight of a derivation (or \emph{abstract syntax tree}, \ie the result of an analyze).
A second operator $\oplus$, associative and commutative, 
is moreover used to handle ambiguity of the model, 
by summing the weights of the possibly several (in general exponentially many) 
syntax trees associated to a given input word.
Intuitively, $\oplus$ aims at selecting, or ranking, the syntax trees.
The weight domain, equipped with these two operators is assumed, at minima, 
to form a \emph{semiring} $\Semiring$, %\cite{Eilenberg74automata}
such as a min-plus algebra of domain $\mathbb{R} \cup \{ +\infty\}$, 
where $\oplus$ is min and $\otimes$ is plus.
%by ranking 
%making the weight domain a semiring.
Some efficient specialized parsing algorithms~\cite{Huang05kbest} have been proposed in this context 
in order to compute the $n$ best syntax trees of a given input word without having to enumerate them all.
Generally based on dynamic programming, these algorithms rely on 
additional algebraic properties of~$\Semiring$.
-- see \eg~\cite{Huang05kbest} for some NLP applications.
%The extraction of $n$ best list is useful 

The approaches to weighted parsing usually assume a finite input alphabet. %models and algorithms 
Considering infinite or large alphabets can however be of practical interest, 
for instance in the context of processing strings in UTF16 encodings, 
for vulnerability detection in Web-applications 
(see \eg~\cite{dAntoni21CACM}), 
for the representation of execution traces in model checking, 
or when dealing with sequences of timestamped events
-- we describe briefly at the end of the paper a parsing based approach to 
of automated music transcription, that is the conversion of a symbolic 
representation of a music performance into a structured music score.
%\cite{MCM19} 
%generalizes weighted parsing: 
%finding the best derivation for a weighted grammar. 

We present here some weighted language models
%model of weighted CFG 
computing on words over infinite input alphabets %sets of terminal symbol
- but with finite sets of states and transitions rules. 
% non-terminals and production rules).
In their transition rules, input symbols appear as variables %(parameters)
and the weight associated to a transition rule is a function of these variables.
% 
This approach is close to the case of 
Symbolic Automata (SA)~\cite{dAntoniVeanes17CAV,dAntoni21CACM}, 
except that the domain for weight values is not restricted to be Boolean, 
like for the guards in the rules of SA, 
but can be an arbitrary commutative semiring (assuming some restrictions).
%
The models defined here are finite automata (\SWA),
transducers (\SWT) and pushdown automata
with a visibly restriction~\cite{AlurMadhusudan09nested} (\SWVPA).
%wrt an edit distance
The latter model of automata computes on \emph{nested words}~\cite{AlurMadhusudan09nested}, 
a structured form of words parenthesized with markup symbols, 
corresponding to a linearization of trees.
In expressiveness, they correspond to a strict restriction
of weighted CFG. 
%and can be used in a general approach for parsing over infinite input alphabets.
Let $A$ be a \SWVPA, associating $A(w) \in \Semiring$ 
to a given a nested word $w$ (representing a parse tree),
and let a \SWT compute a distance $d$, in $\Semiring$, 
between 2 strings over respectively an infinite input alphabet and the 
same (infinite) alphabet of $A$.
Then, the problem of Symbolic Weighted Parsing is, 
given an input string $s$, to find a nested word $w$ minimizing 
(according to the ranking defined by $\oplus$)
the distance $d(s, w) \otimes A(w)$ between $s$ and $A$, 
as defined in~\cite{Mohri03EDWA}.
%following 

% First one general edit-distance is defined by a weighted word 
% transducer~\cite{Mohri}
% %Symbolic automata transducers are extended models~\cite{VeanesdAntoniJACM}
% %dealing with infinite set of input symbols...
% value in a semiring...

In Section~\ref{section:SWA} we introduce \SWA and \SWT, 
then \SWVPA are defined in Section~\ref{sec:SWVPA}, 
where a polynomial 1-best algorithm is described that can be use to solve
Symbolic Weighted Parsing.
Finally, \label{sec:transcription}, we present an application 
of this approach to automated music transcription that has been implemented.




\section{SW Automata and Transducers}
\label{section:transducer}
\label{section:SWA}
\label{section:SWT}

We follow the approach of~\cite{Mohri03EDWA} for the computation of distances
between words and languages, with weighted transducers, 
and extending it to infinite alphabets.
% with models of symbolic weighted automata and transducers. 
%
The models introduced in this section generalize 
weighted automata and transducers~\cite{Droste09handbook} 
%over finite alphabets, see  e.g.~\cite{Mohri03EDWA}, 
by labeling each transition with a weight function that takes the 
input and output symbols as parameters, instead of a simple weight value.
These functions are similar to the guards of symbolic automata~\cite{dAntoniVeanes17CAV,dAntoni21CACM},
but they can return values in an arbitrary semiring, 
where the latter guards are restricted to the Boolean semiring.


\subsection{Semirings}
\label{section:semiring}
We shall consider semiring domains for the weight values of our language models.
%
A \emph{semiring} $\< \Semiring, \oplus, \zero, \otimes, \one>$ 
is a structure with a domain~$\Semiring$,
equipped with two associative
binary operators~$\oplus$ and $\otimes$
with respective neutral elements $\zero$ and $\one$ and such that:
%$\< \mathbb{S}, \oplus, \zero>$ is a commutative monoid
%$\< \mathbb{S}, \otimes, \one>$ is a monoid
\begin{itemize}
\item $\oplus$ is commutative 
-- therefore $\< \Semiring, \oplus, \zero>$ is a commutative monoid 
   and $\< \Semiring, \otimes, \one>$ is a monoid,
\item $\otimes$ distributes over~$\oplus$:  $\forall x, y, z \in \mathbb{S}$,
$x \otimes (y \oplus z) = (x \otimes y) \oplus (x \otimes z)$, 
%  and $(x \oplus y) \otimes z = (x \otimes z) \oplus (y \otimes z)$;
\item $\zero$ is absorbing for~$\otimes$: 
$\forall x\in \mathbb{S}$, $\zero \otimes x = x \otimes \zero = \zero$.
\end{itemize}
%Components of a semiring~$\Semiring$ may be subscripted by~$\Semiring$ when needed.
%We simply write $x \in \Semiring$ to mean $x \in \mathbb{S}$.
%
% In the application presented in this paper, intuitively,
% $\oplus$ selects an optimal value amongst two values and 
% $\otimes$ combines two values into a single value.
%and let $\< \Semiring, \oplus, \zero, \otimes, \one>$ be a {semiring}, 

% \noindent
A semiring $\Semiring$ 
is \emph{monotonic} \wrt a partial ordering~$\leq$ 
iff for all $x, y, z  \in \Semiring$,  $x \leq y$ implies
$x \oplus z \leq y \oplus z$,
$x \otimes z \leq y \otimes z$
and $z \otimes x \leq z \otimes y$,
%
and it is \emph{superior} %\wrt a partial ordering~$\leq$
\wrt~$\leq$ iff for all $x, y \in \Semiring$,  
$x \leq x \otimes y$ and 
$y \leq x \otimes y$~\cite{Huang08advanceddynamic}.
The latter property corresponds to the 
\emph{non-negative weights} condition in shortest-path algorithms~\cite{Dijkstra59anote}.
Intuitively, it means that combining elements always increase their weight. 
% always get worse in term of weight
Note that when $\Semiring$ is superior \wrt~$\leq$, then $\one \leq \zero$
and moreover, for all $x \in \Semiring$, $\one \leq x \leq \zero$.

%\noindent
A semiring $\Semiring$ is \emph{commutative} if $\otimes$ is commutative.
It is \emph{idempotent} if for each $x \in \dom(\Semiring)$, $x \oplus x = x$.
%
%Following the terminology of~\cite{Mohri02semiring},
%when $\forall x \in \dom(\Semiring), \one \oplus x = \one$,
%the semiring $\Semiring$ is is called \emph{bounded}.
%Note that every bounded semiring is idempotent:
%by boundedness, 
%$\one \oplus \one = \one$, and idempotency follows by multiplying
%both sides by $x$ and distributing. 
%
Every idempotent semiring~$\Semiring$ induces 
a partial ordering~$\leq_\oplus$ 
called the \emph{natural ordering} of~$\Semiring$
and defined by: 
%implicitly defined by the semiring $\Semiring$ 
for all $x$ and $y$,
$x \leq_\oplus y \;\mbox{iff}\; x \oplus y = x$.
This ordering is sometimes defined in the opposite direction~\cite{DrosteKuich09semirings};
The above definition follows \cite{Mohri02semiring}, 
and coincides than the usual ordering on the Tropical semiring (\emph{min-plus}).
%
It holds that $\Semiring$ is {monotonic} \wrt~$\leq_\oplus$.
An idempotent semiring $\Semiring$~is called \emph{total} if
it~$\leq_\oplus$ is total
\ie when for all $x, y \in \Semiring$, either $x \oplus y = x$ or $x \oplus y = y$.

\medskip
We shall consider below infinite sums with~$\oplus$.
A semiring~$\Semiring$ is called \emph{complete} 
if for every family
$(x_i)_{i \in I}$ %$\{ x_i \mid i \in I \}$
of elements of $\dom(\Semiring)$ over an index set $I \subset \mathbb{N}$,
the infinite sum $\bigoplus_{i \in I} x_i$
is well-defined and in $\dom(\Semiring)$,
and the following properties hold:
\begin{description}
\item[$i.$]
\emph{infinite sums extend finite sums:}
$\displaystyle\bigoplus_{i \in \emptyset} x_i = \zero$,\quad 
      $\forall j\in \mathbb{N}, \displaystyle\bigoplus_{i \in \{ j \}} x_i = x_j$,\quad
      $\forall j, k\in \mathbb{N}, j\neq k, 
      \displaystyle\bigoplus_{i \in \{ j, k \}} x_i = x_j \oplus x_k$,
%
\item[$ii.$]
\emph{associativity and commutativity:}
for all $I \subseteq \mathbb{N}$
and all partition $(I_{j})_{j \in J}$ of $I$, %\subseteq \mathbb{N}$, 
\(
\displaystyle
\bigoplus_{j \in J}\bigoplus_{i \in I_j} x_i = 
\bigoplus_{i \in I} x_i
\),
%
\item[$iii.$] 
\emph{distributivity of product over infinite sum:}\\
for all $I \subseteq \mathbb{N}$,
\(
\displaystyle
\bigoplus_{i \in I} (x \otimes y_i) = x \otimes \bigoplus_{i\in I} y_i\), and
\(
\displaystyle
\bigoplus_{i \in I} (x_i \otimes y) = (\bigoplus_{i \in I} x_i ) \otimes y\).
\end{description}



\begin{example}
semirings      
\end{example}
      

\subsection{Label Theory}
\label{section:symbols}
 We shall define the functions labeling the transitions of Sw automata and transducers.
Let $\Sigma$ and $\Delta$ be two countable sets of symbols
called respectively input and output \emph{alphabets}, 
and let $\< \Semiring, \oplus, \zero, \otimes, \one>$ be a commutative semiring.

\noindent 
A \emph{label theory} over $\Sigma$ and $\Delta$
is made of 4 recursively enumerable sets:
%$\Phi_0$, \Phi_\Sigma \uplus \Phi_\Delta \uplus \Phi_{\Sigma, \Delta}$ 
$\Phi_\epsilon \subseteq \Semiring$, % containing constant functions valued in $\Semiring$, 
$\Phi_\Sigma$ and $\Phi_\Delta$, 
containing unary functions in $\Sigma \to \Semiring$, resp. $\Delta \to \Semiring$, 
and $\Phi_{\Sigma, \Delta}$  containing binary functions in $\Sigma \times \Delta \to \Semiring$.
Moreover, these sets are required to be closed under the operators 
$\oplus$ and $\otimes$ of~$\Semiring$.
More precisely, for all $\phi, \phi' \in \Phi_\Sigma$ all 
$\psi, \psi' \in \Phi_\Delta$, 
and $\eta, \eta' \in \Phi_{\Sigma, \Delta}$, the function
\begin{description}
\item $\phi \otimes \phi' : x \mapsto \phi(x) \otimes \phi'(x)$ belongs to $\Phi_\Sigma$, 
\item $\psi \otimes \psi' : y \mapsto \psi(y) \otimes \psi'(y)$ belongs to $\Phi_\Delta$,
\item $\phi \otimes \eta : x, y \mapsto \phi(x) \otimes \eta(x, y)$ belongs to $\Phi_{\Sigma, \Delta}$,
\item $\eta \otimes \psi : x, y \mapsto \eta(x, y) \otimes \psi(y)$ belongs to $\Phi_{\Sigma, \Delta}$,
\item $\eta \otimes \eta' : x, y \mapsto \eta(x, y) \otimes \eta'(x, y)$ belongs to $\Phi_{\Sigma, \Delta}$.
\end{description}
The same also holds for the binary sum operator $\oplus$.

\noindent
\marginpar{necessary?}
Finally, it is assumed that the codomain of every function of $\Phi_\Sigma$ and $\Phi_\Delta$
is a subset of $\Phi_\epsilon$.
and all partial applications of functions $\Phi_{\Sigma, \Delta}$, 
resp.  $f_a: y \mapsto f(a, y)$ for $a \in \Sigma$ and $y \in \Delta$
and  $f_b: x \mapsto f(x, b)$ for $b \in \Delta$ and $x \in \Sigma$, 
belong resp. to~$\Phi_\Sigma$ and~$\Phi_\Delta$.


\subsection{Definitions}
%(SWT)
\begin{definition}
A \emph{symbolic-weighted transducer} (\SWT) 
$T$ over the input and output alphabet $\Sigma$ and $\Delta$ 
and the semiring $\Semiring$ is a tuple
$T = \< Q, \init, \wei, \final >$,
where $Q$ is a finite set of states, 
$\mathsf{in} : Q \to \Semiring$, 
respectively $\mathsf{out} : Q \to \Semiring,$
are functions defining the weight for entering, 
respectively leaving, a state, 
and $\wei$ is a transition %weight 
function from $Q \times Q$ into %$\Phi$.
$\< \Phi_\epsilon, \Phi_\Sigma, \Phi_\Delta, \Phi_{\Sigma, \Delta}>$.
\end{definition}
%
We extend the above transition function into a function from
$Q \times (\Sigma \cup \{ \epsilon \}) \times (\Delta \cup \{ \epsilon \}) \times Q$
into $\Semiring$, also called $\wei$ for simplicity, such that 
for all $q, q' \in Q$, $a \in \Sigma$, $b \in \Delta$, 
and with 
$\< \phi_\epsilon, \phi_\Sigma, \phi_\Delta, \phi_{\Sigma, \Delta}> = \wei(q, q')$, 
\[
\begin{array}{rcl}
\wei(q, \epsilon, \epsilon, q') & = & \phi_\epsilon\\
\wei(q, a, \epsilon, q') & = & \phi_\Sigma(a)\\
\wei(q, \epsilon, b, q') & = & \phi_\Delta(b)\\
\wei(q, a, b, q') & = & \phi_{\Sigma, \Delta}(a, b)
\end{array}      
\]
%More precisely, $Q \times Q$, 
%resp. $Q \times \Sigma \times Q$,
%$Q \times \Delta \times Q$,
%$Q \times \Sigma \times \Delta \times Q$,
%into resp. $\Phi_0$, $\Phi_\Sigma$, $\Phi_\Delta$ $\Phi_{\Sigma, \Delta}$.

These functions $\phi$ act as guards for the transducer's transitions, 
preventing a transition when they return the absorbing $\zero$ of $\Semiring$.

The symbolic-weighted transducer $T$ defines a mapping 
from the pairs of strings of $\Sigma^* \times \Delta^*$ 
into the weights of~$\Semiring$,
based on the following intermediate function $\weight_T$
defined recursively for every $q, q' \in Q$, 
%$a \in \Sigma$, $b \in \Delta$ 
for every strings of $s \in \Sigma^*$, $t \in \Delta^*$:
\[
\begin{array}{rccl}
\weight_T(q, s, t, q') & = & & \wei(q, \epsilon, \epsilon, q')\\
 & & \oplus \displaystyle\bigoplus_{\begin{array}{c}
                                      \scriptstyle q'' \in Q\\[-2pt]
                                      \scriptstyle s = au, a \in \Sigma
                                      \end{array}} &
     \wei(q, a, \epsilon, q'') \otimes \weight_T(q'', u, t, q')\\
 & & \oplus \displaystyle\bigoplus_{\begin{array}{c}
                                    \scriptstyle q'' \in Q\\[-2pt]
                                    \scriptstyle t = bv, b \in \Delta
                                    \end{array}} &
      \wei(q, \epsilon, b, q'') \otimes \weight_T(q'', s, v, q')\\ 
      & & \oplus \displaystyle\bigoplus_{\begin{array}{c}
                                         \scriptstyle q'' \in Q\\[-2pt]
                                         \scriptstyle s = au, a \in \Sigma\\[-2pt]
                                         \scriptstyle t = bv, b \in \Delta
                                         \end{array}} &
      \wei(q, a, b, q'') \otimes \weight_T(q'', u, v, q')\\ 
\end{array}
\]
Recall that by convention, an empty sum with $\oplus$ is $\zero$. 

The above expression of $\weight_T$ can be seen as a stateful definition of 
an edit-distance between a word $s \in \Sigma^*$ and a word $t \in \Delta^*$,
see also~\cite{Mohri03ijfcs}.
Intuitively, 
$\wei(q, a, \epsilon, q'')$, in the second line, is the cost of 
the deletion of a symbol $a \in \Sigma$ in $s$, 
$\wei(q, \epsilon, b, q'')$, in the third line, is the cost 
of the deletion of insertion of  $b \in \Delta$ in $s$, 
$\wei(q, a, b, q'')$, in the last line, is the cost 
of the substitution of  $a \in \Sigma$ by $b \in \Delta$.
The cost of a sequence of such operations transforming $s$ into $t$ is 
the product with $\otimes$ of the costs of individual operations involved,
and the distance between $s$ and $t$ is the sum with $\oplus$
of all such cost products.


\medskip\noindent
The weight associated by $T$ to  $\< s, t> \in \Sigma^* \times \Delta^*$
is then defined as follows: 
\begin{equation}
T(s, t)  = 
\displaystyle\bigoplus_{q, q' \in Q} \mathsf{in}(q) 
\mathop{\otimes} \weight_T(q, s, t, q') \mathop{\otimes} \mathsf{out}(q').
\label{eq:weightT}
\end{equation}

\begin{example}
comparison of two sequences of timestamped events      
\end{example}

\noindent
A \emph{symbolic weighted automata} (\SWA) $A = \< Q, \init, \weight, \final >$
over $\Sigma$ and $\Semiring$ 
is defined in a similar way by simply omitting the output symbols,
\ie $\wei$ is a function from~$Q \times Q$ into %$\Phi$.
$\< \Phi_\epsilon, \Phi_\Sigma >$, 
or equivalently from~$Q \times (\Sigma \cup \{ \epsilon \}) \times Q$ into~$\Semiring$.

      


\subsection{Properties}

\begin{proposition}
Given a \SWT $T$ 
over $\Sigma$, $\Delta$ and $\Semiring$, 
and a word $s \in \Sigma^*$, 
one can construct a \SWA 
$A_{s, T}$ such that for all $t \in \Delta^*$, 
$A_{s, T}(t) = T(s, t)$.
\end{proposition}
The construction time and size for $A_{s, T}$ are $O(| s | . \| T \|)$.



\begin{proposition}
      ...removal of $\epsilon$ transitions for \SWA...
      \end{proposition}
      
      


\section{SW Visibly Pushdown Automata}
\label{section:SWVPA}\label{sec:SWVPA}
The following model generalizes Symbolic VPA~\cite{dAntonyAlur14SVPDA}
from Boolean semirings to arbitrary semiring weight domains.

\subsection{Definition}
Let $\Sigma$ be a countable alphabet 
%finite (large) or infinite,
that we assume partitioned into three subsets 
$\Sigmai \uplus \Sigmac \uplus \Sigmac$ 
respectively called of \emph{internal}, \emph{call} and \emph{return}
symbols.
% \begin{itemize}
% \item a set $\Sigmai$ of \emph{internal symbols} denoted $a$,
% \item a set $\Sigmac$ of \emph{call symbols} denoted $\call{a}$,
% \item a set $\Sigmar$ of \emph{return symbols} denoted $\return{a}$.
% \end{itemize}
Let~$\< \Semiring, \oplus, \zero, \otimes, \one>$ be a commutative semiring and  
let  $(\Phi_\epsilon, \Phic, \Phir, \Phicr)$ be a label theory over $\Semiring$
%In order to simplify notations, %and following the definition of Section~\ref{section:transducer}, 
%we shall write respectively 
where $\Phic$, $\Phir$ and~$\Phicr$ stand respectively 
for~$\Phi_\Sigmac$, $\Phi_\Sigmar$ and~$\Phi_{\Sigmac, \Sigmar}$.
%
Moreover, we extend this theory with a set $\Phii$ 
of unary functions in $\Sigmai \to \Semiring$,
closed under $\oplus$ and $\otimes$.

\begin{definition}
A \emph{Symbolic Weighted Visibly Pushdown Automata} (\SWVPA)~$A$ 
over  $\Sigma = \Sigmai \uplus \Sigmac \uplus \Sigmar$ and $\Semiring$ is a tuple
$T = \< Q, P, \init, \weii, \weic, \weir, \weie, \final >$,
where $Q$ is a finite set of states, 
$P$ is a finite set of stack symbols, 
$\mathsf{in} : Q \to \Semiring$, 
respectively $\mathsf{out} : Q \to \Semiring,$
are functions defining the weight for entering, 
respectively leaving, a state, 
and 
$\weii : Q \times Q \to \Phii$,  
$\weic : Q \times Q \times P \to \Phic$,  
$\weir : Q \times P \times Q \to \Phicr$,  
$\weie : Q \times Q \to \Phir$,  
are transition functions.
\end{definition}
%
Similarly as in Section~\ref{section:transducer}, 
we extend the above transition functions as follows
for all $q, q' \in Q$, $p \in P$, 
$a \in \Sigmai$, 
$\call{c} \in \Sigmac$, 
$\return{r} \in \Sigmar$, 
overloading their names: % for simplicity:
\[
\begin{array}{lll}
\weii: Q \times \Sigmai \times Q \to \Semiring & 
\weii(q, a, q') = \phi_\mathsf{i}(a) & 
\mathrm{where~} \phi_\mathsf{i} = \weii(q, q'),\\
%
\weic: Q \times \Sigmac \times Q \times P \to \Semiring & 
\weic(q, \call{c}, q', p) = \phi_\mathsf{c}(\call{c}) & 
\mathrm{where~} \phi_\mathsf{c} = \weic(q, q', p),\\
%
\weir: Q \times \Sigmac \times P \times \Sigmar \times Q \to \Semiring & 
\weir(q, {\call{c}},  p, {\return{r}}, q') = \phi_\mathsf{r}({\call{c}},  {\return{r}}) & 
\mathrm{where~} \phi_\mathsf{r} = \weir(q, p, q'),\\
%
\weie: Q \times \Sigmar \times Q \to \Semiring & 
\weie(q, {\return{r}}, q') = \phi_\mathsf{e}({\return{r}}) &
\mathrm{where~} \phi_\mathsf{e} = \weie(q, q').\\
\end{array}      
\]

\noindent
The intuition is the following for the above transitions.
\begin{description}
\item $\weii$ : read the input internal symbol $a$, change state to $q'$.
\item $\weic$ : read the input call symbol $\call{c}$, push it to the stack along with $p$, change state to $q'$.
\item $\weir$ : when the stack is not empty, 
      read and pop from stack a pair made of $\call{c}$ and $p$, 
      read the input return symbol $\return{r}$, change state to $q'$.
      In this case, the weight function $\phi_\mathsf{r}$ 
      computes a value of matching between the call and return symbols.
      This value might be $\zero$ in order to express that the symbols do not match.
\item $\weie$ : when the stack is empty, 
      read the input symbol $\call{r}$, change state to $q'$.
\end{description}

We give now a formal definition of these transitions of the automaton $A$
in term of a weight value
computed by an intermediate function $\weight_A$.
In the case of a pushdown automaton, a configuration is composed 
of a state $q \in Q$ and a stack content $\theta \in \Theta^*$, where $\Theta = \Sigmac \times P$.
Therefore, $\weight_A$ is a function from 
$Q \times \Theta^* \times \Sigma^* \times Q \times \Theta^*$ into $\Semiring$.
\[
\begin{array}{rcl}
\weight_A\bigl(\config{q}{\theta}, a\, u, \config{q'}{\theta'}\bigr) & = & 
 {\displaystyle\bigoplus_{q'' \in Q}} \weii(q, a, q'') 
 \otimes \weight_A\bigl(\config{q''}{\theta}, u, \config{q'}{\theta'}\bigr)\\
%
\weight_A\bigl(\config{q}{\theta}, {\call{c}}\, u, \config{q'}{\theta'}\bigr) & = & 
 {\displaystyle\bigoplus_{\begin{array}{c}
                          \scriptstyle q'' \in Q\\[-2pt]
                          \scriptstyle p \in P
                          \end{array}}}
 \weic\bigl(q, {\call{c}}, q'', p\bigr) 
 \otimes \weight_A\bigl(\config{q''}{{\call{c}}\, p\cdot \theta}, u, \config{q'}{\theta'}\bigr)\\[1mm]
%
\weight_A\bigl(\config{q}{{\call{c}}\, p\cdot \theta}, {\return{r}}\, u, \config{q'}{\theta'}\bigr) & = & 
 {\displaystyle\bigoplus_{q'' \in Q}} 
 \weir\bigl(q, {\call{c}}, p, {\return{r}}, q''\bigr) 
 \otimes \weight_A\bigl(\config{q''}{\theta}, u, \config{q'}{\theta'}\bigr)\\
%
\weight_A\bigl(\config{q}{\bot}, {\return{r}}\, u, \config{q'}{\theta'}\bigr) & = & 
 {\displaystyle\bigoplus_{q'' \in Q}} \weie(q, {\return{r}}, q'') 
 \otimes \weight_A\bigl(\config{q''}{\bot}, u, \config{q'}{\theta'}\bigr)\\
\end{array}
\]
where $\bot$ denotes the empty stack and ${\call{c}}\, p\cdot \theta$ 
denotes a stack with the pair made of ${\call{c}}$ and $p$ on its top and $\theta$
as the rest of stack.

\noindent
The weight associated by $A$ to $s \in \Sigma^*$
is then defined as follows,
following empty stack semantics: 
\begin{equation}
A(s)  = 
{\displaystyle\bigoplus_{q, q' \in Q}} \textstyle
\mathsf{in}(q) \mathop{\otimes} 
\weight_A\bigl(\config{q}{\bot}, s, \config{q'}{\bot}\bigr) 
\mathop{\otimes} \mathsf{out}(q').
\label{eq:weightA}
\end{equation}

\begin{example}
structured words...
intro language of music notation ?
\end{example}


\subsection{Properties}
The class of \SWVPA is closed under the binary operators of the underlying semiring.
%
\begin{proposition}
Let $A_1$ and $A_2$ be two (\SWVPA)
over the same $\Sigma$ and $\Semiring$.
There exists two $\SWVPA$ $A_1 \oplus A_2$ and $A_1 \otimes A_2$, 
effectively constructible, 
such that for all $s \in \Sigma^*$, 
$(A_1 \oplus A_2)(s) = A_1(s) \oplus A_2(s)$ and 
$(A_1 \otimes A_2)(s) = A_1(s) \otimes A_2(s)$.
\end{proposition}
The construction is essentially the same 
as the one of~\cite{dAntonyAlur14SVPDA}, in the case of the Boolean semiring.


\subsection{Best-first Search}
Assume a semiring $\Semiring$
commutative, complete, idempotent, superior, and total.
% total ? 
% monotonic and superior writ natural ordering
%Regarding the infinite sum operator, note that
%$\bigoplus_{x \in \Phi_\Sigma} \phi(x)$, 
%$\bigoplus_{y \in \Phi_\Delta} \psi(y)$, and  
%... exist and in $\Semiring$.
We propose a Dijkstra algorithm computing the minimal weight by $A$, 
\wrt $\leq_\oplus$, for a word in $\Semiring^*$.

\noindent
More precisely, 
let $\top$ be a fresh stack symbol which does not belong to $\Theta$,
and for every two states $q, q' \in Q$ and $\sigma \in \{ \bot, \top \}$, 
let 
\[ 
  d_0(q, \sigma, q') = \bigoplus_{s\in \Sigma^*} 
  \textstyle
  \weight_A\bigl(\config{q}{\sigma}, s, \config{q'}{\sigma}\bigr). 
\]
Since $\Semiring$ is complete, this infinite sum is well defined, 
and since $\leq_\oplus$ is assumed total, it is the minimum in $\Sigma^*$
of $s \mapsto \weight_A(\config{q}{\sigma}, s, \config{q'}{\sigma})$ \wrt this ordering.
%
When $\sigma = \bot$, $d_0(q, \sigma, q')$ is the central 
expression in a term of the definition (\ref{eq:weightA}) of $A(s_0)$ for the minimum $s_0$
(for the above function).
When $\sigma = \bot$, intuitively, it is the minimum weight of a computation of $A$
starting in state $q$ with a stack $\theta \in \Theta^*$ (possibly empty), 
and ending in state $q$ with the same stack $\theta$, such that moreover 
the computation does not touch a symbol of $\theta$. 
That means that during the computation, 
$A$ may apply the first case of in the definition of $\weight_A$ (internal symbol),
as well as the second case, to can push call symbols on the top of $\theta$, 
and may pop these symbols with the third case (return symbol). 
However, it cannot apply one of the two last cases (return symbol and empty stack)
when the current stack is $\theta$.
%pop symbols in $\theta$.
% Note that having a stack reduced to such a symbol makes impossible the application of the 
% two last cases in the definition of $\weight_A$ (return symbol and empty stack). 
% However, it is possible to apply the two first cases 
% (internal symbol or call symbol, with a push on the top of $\top$).

The algorithm~\ref{algo:Dijkstra}
constructs iteratively a a marking $d : Q \times \{ \bot, \top \} \times Q \to \Semiring$
%of the triplets $\<q, \sigma, q'>$ 
%of states of $A$ by weight values in $\Semiring$, 
that converges eventually to $d_0(q, \sigma, q')$. 
%It uses for that purpose a priority queue $P$ containing triplets of 
%$Q \times \{ \bot, \top \} \times Q$.


\begin{algo}[1-best for \SWVPA] \label{algo:Dijkstra}
\textbf{initially} let $P = Q \times \{ \bot, \top \} \times Q$, %contains all %triplets 
%$\< q_1, \bot, q_2>$ and $\<q_1, \top, q_2>$ for $q_1, q_2 \in Q$, with 
and 
$d(q_1, \bot, q_2) = d(q_1, \top, q_2) = \one$ if $q_1 = q_2$ and
$d(q_1, \bot, q_2) = d(q_1, \top, q_2) = \zero$ otherwise.

\smallskip\noindent
\textbf{while} $P$ is not empty

\noindent
\quad\textbf{extract} $\< q_1, \sigma, q_2>$ from $P$ 
 such that $d(q_1, \sigma, q_2)$ is minimal wrt $\leq_\oplus$.

\noindent\quad \textbf{for all} $q_0, q_3 \in Q$ and $p \in P$ do

\noindent
\qquad
\(\begin{array}{rrcl}
 & d(q_1, \sigma, q_3) & \opluseq &
   d(q_1, \sigma, q_2) \otimes \displaystyle\bigoplus_{a \in \Sigmai} \weii(q_2, a, q_3)\\
%
%  & d(q_0, \sigma, q_2) & \opluseq & 
%    \displaystyle\bigoplus_{a \in \Sigmai} \weii(q_0, a, q_1) \otimes d(q_1, \sigma, q_2)\\
%
\mathrm{if~} \sigma = \top & d(q_0, \top, q_3) & \opluseq &
d(q_1, \sigma, q_2) \otimes
%\displaystyle\bigoplus_{p \in P} 
\displaystyle\bigoplus_{{\call{c}} \in \Sigmac} 
\displaystyle\bigoplus_{{\return{r}} \in \Sigmar} \eta({\call{c}}, {\return{r}})\\
\mathrm{and} &  d(q_0, \bot, q_3) & \opluseq &
d(q_1, \sigma, q_2) \otimes
%\displaystyle\bigoplus_{p \in P} 
\displaystyle\bigoplus_{{\call{c}} \in \Sigmac} 
\displaystyle\bigoplus_{{\return{r}} \in \Sigmar} \eta({\call{c}}, {\return{r}})\\
& & & \mathrm{where~} \eta = \weic(q_0, q_1, p) \otimes \weir(q_2, p, q_3)\\
%
\mathrm{if~} \sigma = \bot & d(q_1, \bot, q_3) & \opluseq &
  d(q_1, \sigma, q_2) \otimes \displaystyle\bigoplus_{\return{r} \in \Sigmar} \weie(q_2, {\return{r}}, q_3)\\
%
%& d(q_0, \bot, q_2) & \opluseq & 
%d(q_0, \bot, q_1) \otimes d(q_1, \sigma, q_2), \mathrm{if~} \< q_0, \bot, q_1> \notin P \\
%
%\mathrm{if~} \sigma = \top & d(q_0, \top, q_2) & \opluseq & 
%d(q_0, \top, q_1) \otimes d(q_1, \sigma, q_2), \mathrm{if~} \< q_0, \top, q_1> \notin P \\
%
& d(q_1, \bot, q_3) & \opluseq & 
   d(q_1, \sigma, q_2) \otimes d(q_2, \bot, q_3), \mathrm{if~} \< q_2, \bot, q_3> \notin P \\
%
\mathrm{if~} \sigma = \top & d(q_1, \top, q_3) & \opluseq & 
    d(q_1, \sigma, q_2) \otimes d(q_2, \top, q_3), \mathrm{if~} \< q_2, \top, q_3> \notin P \\
\end{array}
\) 
\end{algo}

\noindent
The infinite sums in the updates of $d$ in Algorithm~\ref{algo:Dijkstra} are well defined
since~$\Semiring$ is complete.
The algorithm performs $2.|Q|^2$ iterations until $P$ is empty, 
and each iteration has a time complexity $O(|Q|^2 . |P|)$.
This gives a time complexity $O(|Q|^4 . |P|)$. 
It can be reduced by implementing $P$ as a priority queue, 
prioritized by the value returned by $d$
***complete***. %$|Q|^3.\log(|Q|^2)$

The correctness of Algorithm~\ref{algo:Dijkstra} 
is ensured by the invariant expressed in the following lemma.
\begin{lemma}
For all $\< q_1, \sigma, q_2> \notin P$, $d(q_1, \sigma, q_2) =  d_0(q_1, \sigma, q_2)$.
\end{lemma}
The proof is by contradiction, 
assuming a counter-example minimal in the length of the witness word.


% \begin{algorithm}
% \caption{<your caption for this algorithm>}
% \label{<your label for references later in your document>}
% \begin{program}
% \seq{|line| := `` '', i := 1};
% \WHILE i \neq n+1 \DO
%       |line| := |item|[i] \concat `` '' \concat |number|[i]; 
%       i := i+1; 
%       \WHILE i \neq n+1 \AND |item|[i] = |item|[i-1] \DO 
%       |line| := |line| \concat ``, '' \concat |number|[i]);
%       i := i+1 \OD ; 
%       |write|(|line|) \OD 
% \end{program}
% \end{algorithm}

% The weight of a transition acts as a guard: 
% a transition is activated for a symbol $`a`$ iff its weight $`\phi(a) \neq 0`$ (or $`\psi(a, b) \neq 0`$), 
% the absorbing element.

%\begin{lemma}
\noindent
For computing the minimal weight of a computation of $A$, we use the fact that,
at the termination of Algorithm~\ref{algo:Dijkstra}, %it holds that,
%There exist $q_1, q_2 \in Q$
\[
  {\displaystyle \bigoplus_{s \in \Sigma^*} A(s)} = 
  {\displaystyle\bigoplus_{q, q' \in Q}} \textstyle
  \mathsf{in}(q) \mathop{\otimes} d(q, \bot, q') \mathop{\otimes} \mathsf{out}(q').
\]
%\end{lemma}

%\medskip
\noindent
In order to obtain effectively a witness 
(word of $\Semiring^*$ with computation of $A$ of minimal weight), 
we require an additional property the of weight functions.
\begin{definition}
Let $\Sigma$ be an alphabet and $\Semiring$ a complete semiring.
A function $\phi$ from $\Sigma^n$ into $\Semiring$
is called $k$-\emph{convex} for a natural number $k$ iff 
$\mathit{card}\{ \mathbf{a} \in \Sigma^n \mid \phi(\mathbf{a}) = 
                 \displaystyle\bigoplus_{\mathbf{p} \in \Sigma^n} \phi(\mathbf{p}) \} \leq k$.
\end{definition}
A label theory is $k$-convex if all its functions are $k$-convex.

\begin{proposition}
For a \SWVPA $A$ over a 
commutative, idempotent, superior, total and complete semiring 
and an alphabet $\Sigma$ with a $k$-convex label theory, 
one can construct in PTIME a word $s \in \Sigma^*$ 
such that $A(s)$ is minimal \wrt the natural ordering for $\Semiring$. 
%$\leg_\oplus$.
\end{proposition}



\section{Symbolic Weighted Parsing}



\subsection{Application to Amtomated Music Transcription}
\label{sec:transcription}
Symbolic Automated Music Transcription
and analysis of music performances

\subsubsection{Time Scales}
Real-Time Unit (RTU) = seconds

\noindent 
Musical-Time Unit (MTU) = number of measures

\noindent 
conversion via tempo value

\subsubsection{Representation of Music Performances}
We consider symbolic representations of musical performances, as finite sequences of events.
It corresponds to the concrete case of a MIDI file~\cite{SMF} 
recorded  from an electronic keyboard, 
or the output of a transcription from audio files~\cite{Benetos18AMTsurvey}.
%
For the sake of simplicity, 
we shall only consider here the case of monophonic performances, 
where at most one note is sounding at a time. 
The approach however extends to the polyphonic case.

A music performance is a finite sequence of events in a set~$\Sigma$.
Every event $e \in \Sigma$ has attributes such from a finite domain, 
like a number of key for a note 
or a flag indicating that it is a rest 
(\textsf{ON} and \textsf{OFF} messages in~\cite{SMF})
and a velocity value (0..127 in~\cite{SMF})).
%This representation is similar to the piano roll ~\cite{Muller15fundamentals} chap.1. 
Moreover, it contains a RTU value $\ioi{e}$ (real number) 
representing the time distance to the next event, 
or to the end of performance for the last event,
also called \emph{inter-onset interval}.


\subsubsection{Representation of Music Scores}
Music score are represented as structured words
made of timed %quantified 
events and parenthesized markups,
akin of nested words~\cite{AlurMadhusudan09nested}.

We consider an alphabet $\Delta$, every symbol of which is 
composed of a tag, in a finite set $\Xi$, 
and an MTU (rational) IOI duration value.
%The alphabet $\Delta$ 
It is partitioned into 
$\Delta = \Deltai \uplus \Deltac \uplus \Deltar$, 
like in Section~\ref{section:SWVPA}.
%
\noindent
The symbols of $\Deltai$ represent events:
% (infinite alphabet of internal symbols) made of:
with tags indicating a new note or grace-note (with null IOI), 
a rest or the continuation of the previous note (tie or dot).
%
The elements of $\Deltac \uplus \Deltar$ are matched
markups for describing the structure of the score, 
\ie the hierarchical grouping of events, and also, 
importantly the division of time in measures, tuplets...
%- parentheses for time divisions : tuplets, bars...
(linearization of rhythm trees \cite{jacquemard:hal-01138642}...).
They contain additional info such as tuple number, beaming policy...

\noindent
The duration values of letters of $\Delta$, in MTU (rational), 
can be computed with the markups and tags (\eg grace note has duration 0).

%\noindent
%There are simultaneous events, since grace notes has duration 0. They are ordered.
%
%\noindent
%Finite bound on the number of duration ratio. ?

\begin{example}
...      
\end{example}

\subsubsection{Performance/Score Distance Computation}
\label{app:distance}
We define a distance between performance and score representations
by a $\SWT$ $T = \< Q, \init, \wei, \final >$, over a semiring $\Semiring$.
** detail the elements of $\Semiring$ ....**
%are quadruplets of the form
%$\< t, s, \delta_t, \delta_s>$

Every state of $Q$ contains a 
tempo value in a finite domain (e.g. 30..300 bpm).
This value can be fixed 
or recomputed by the $T$ %transducer 
after reading each event, 
according to a perceptive/cognitive model of tempo 
such as~\cite{LargeJones99tempo}
(also used in the context of score following~\cite{Cont10TPAMI}).
% we wont detail here.


\subsection{Transcription by Best-first Search}
We assume a score language defined by a \SWVPA over the semiring 
$\Semiring$ of Section~\ref{app:distance}.






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% BIBLIO                                                                     %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\bibliographystyle{plain}
%\bibliographystyle{plainurl} 
\bibliographystyle{abbrv}
%\bibliographystyle{splncs04}
\bibliography{references}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% APPENDIX                                                                   %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\appendix 

\section{Edit-Distance}

%\subsection{Distance between words or languages}
...algebraic definition of edit-distance of Mohri, in \cite{Mohri03EDWA}
% Mehryar Mohri 
% Edit-distance of weighted automata: General definitions and algorithms
% International Journal of Foundations of Computer Science 14.06 (2003): 957-982.
distance $d$ over $\Sigma^* \times \Sigma^*$ 
into a semiring  $\Semiring = ( \Semiring, \oplus, \zero, \otimes, \one)$.

%\noindent
Let $\Omega = \Sigma \cup \{ \epsilon \} \times \Sigma \cup \{ \epsilon \} \setminus \{ (\epsilon, \epsilon) \}$,
and let $h$ be the morphism from $\Omega^*$ into $\Sigma^* \times \Sigma^*$  
defined over the concatenation of strings of $\Sigma^*$ (that removes the $\epsilon$'s).
%
\noindent
An \emph{alignment} between 2 strings  $s, t \in \Sigma^*$ is an element $\omega \in \Omega^*$ 
such that $h(\omega) = (s, t)$.
%
\noindent
We assume a base cost function $\Omega$ : $\delta: \Omega \to S$, extended to $\Omega^*$ as follows  
(for $\omega \in \Omega^*$): 
\(
\displaystyle\delta(\omega) = \bigotimes_{0 \leq i < |\omega|} \delta(\omega_i)
\).

\noindent
\begin{definition}
For  $s, t \in \Sigma^*$, the edit-distance between $s$ and $t$ is  
\( 
d(s, t) = \displaystyle\bigoplus_{\omega \in \Omega^*\, h(\omega) = (s, t)} \delta(\omega)
\).
\end{definition}

e.g. Levenstein edit-distance: $S$ is min-plus and $\delta(a, b) = 1$ for all $(a, b) \in \Omega$.


%\paragraph{Distance between a word and a regular language}


\end{document}

